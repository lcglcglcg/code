/* soapStub.h
   Generated by gSOAP 2.8.14 from baidu.h

Copyright(C) 2000-2013, Robert van Engelen, Genivia Inc. All Rights Reserved.
The generated code is released under ONE of the following licenses:
GPL or Genivia's license for commercial use.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
*/

#ifndef soapStub_H
#define soapStub_H
#define SOAP_NAMESPACE_OF_ns1	"https://api.baidu.com/sem/sms/v2"
#define SOAP_NAMESPACE_OF_ns2	"http://api.baidu.com/sem/common/v2"
#include "stdsoap2.h"
#if GSOAP_VERSION != 20814
# error "GSOAP VERSION MISMATCH IN GENERATED CODE: PLEASE REINSTALL PACKAGE"
#endif

#ifdef __cplusplus
extern "C" {
#endif

/******************************************************************************\
 *                                                                            *
 * Enumerations                                                               *
 *                                                                            *
\******************************************************************************/


#ifndef SOAP_TYPE_xsd__boolean
#define SOAP_TYPE_xsd__boolean (7)
/* xsd:boolean */
enum xsd__boolean { xsd__boolean__false_ = 0, xsd__boolean__true_ = 1 };
#endif

/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Classes and Structs                                                        *
 *                                                                            *
\******************************************************************************/


#if 0 /* volatile type: do not declare here, declared elsewhere */

#endif

#ifndef SOAP_TYPE_ns1__ReportRequestType
#define SOAP_TYPE_ns1__ReportRequestType (8)
/* ns1:ReportRequestType */
struct ns1__ReportRequestType
{
	int __sizeperformanceData;	/* sequence of elements <performanceData> */
	char **performanceData;	/* required element of type xsd:string */
	time_t startDate;	/* required element of type xsd:dateTime */
	time_t endDate;	/* required element of type xsd:dateTime */
	enum xsd__boolean *idOnly;	/* optional element of type xsd:boolean */
	int *levelOfDetails;	/* optional element of type xsd:int */
	int __sizeattributes;	/* sequence of elements <attributes> */
	struct ns1__AttributeType *attributes;	/* optional element of type ns1:AttributeType */
	int *format;	/* optional element of type xsd:int */
	int reportType;	/* required element of type xsd:int */
	int __sizestatIds;	/* sequence of elements <statIds> */
	LONG64 *statIds;	/* optional element of type xsd:long */
	int *statRange;	/* optional element of type xsd:int */
	int *unitOfTime;	/* optional element of type xsd:int */
	int *platform;	/* optional element of type xsd:int */
};
#endif

#ifndef SOAP_TYPE_ns1__AttributeType
#define SOAP_TYPE_ns1__AttributeType (13)
/* ns1:AttributeType */
struct ns1__AttributeType
{
	char *key;	/* optional element of type xsd:string */
	int __sizevalue;	/* sequence of elements <value> */
	int *value;	/* optional element of type xsd:int */
};
#endif

#ifndef SOAP_TYPE__ns1__getProfessionalReportIdRequest
#define SOAP_TYPE__ns1__getProfessionalReportIdRequest (17)
/* ns1:getProfessionalReportIdRequest */
struct _ns1__getProfessionalReportIdRequest
{
	struct ns1__ReportRequestType *reportRequestType;	/* required element of type ns1:ReportRequestType */
};
#endif

#ifndef SOAP_TYPE__ns1__getProfessionalReportIdResponse
#define SOAP_TYPE__ns1__getProfessionalReportIdResponse (19)
/* ns1:getProfessionalReportIdResponse */
struct _ns1__getProfessionalReportIdResponse
{
	char *reportId;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:string */
};
#endif

#ifndef SOAP_TYPE__ns1__getReportStateRequest
#define SOAP_TYPE__ns1__getReportStateRequest (20)
/* ns1:getReportStateRequest */
struct _ns1__getReportStateRequest
{
	char *reportId;	/* required element of type xsd:string */
};
#endif

#ifndef SOAP_TYPE__ns1__getReportStateResponse
#define SOAP_TYPE__ns1__getReportStateResponse (21)
/* ns1:getReportStateResponse */
struct _ns1__getReportStateResponse
{
	int *isGenerated;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:int */
};
#endif

#ifndef SOAP_TYPE__ns1__getReportFileUrlRequest
#define SOAP_TYPE__ns1__getReportFileUrlRequest (22)
/* ns1:getReportFileUrlRequest */
struct _ns1__getReportFileUrlRequest
{
	char *reportId;	/* optional element of type xsd:string */
};
#endif

#ifndef SOAP_TYPE__ns1__getReportFileUrlResponse
#define SOAP_TYPE__ns1__getReportFileUrlResponse (23)
/* ns1:getReportFileUrlResponse */
struct _ns1__getReportFileUrlResponse
{
	char *reportFilePath;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:string */
};
#endif

#ifndef SOAP_TYPE_ns2__OptType
#define SOAP_TYPE_ns2__OptType (24)
/* ns2:OptType */
struct ns2__OptType
{
	int __sizeoptString;	/* sequence of elements <optString> */
	struct ns2__StringMapItemType *optString;	/* optional element of type ns2:StringMapItemType */
	int __sizeoptInt;	/* sequence of elements <optInt> */
	struct ns2__IntMapItemType *optInt;	/* optional element of type ns2:IntMapItemType */
	int __sizeoptLong;	/* sequence of elements <optLong> */
	struct ns2__LongMapItemType *optLong;	/* optional element of type ns2:LongMapItemType */
	int __sizeoptFloat;	/* sequence of elements <optFloat> */
	struct ns2__FloatMapItemType *optFloat;	/* optional element of type ns2:FloatMapItemType */
	int __sizeoptDouble;	/* sequence of elements <optDouble> */
	struct ns2__DoubleMapItemType *optDouble;	/* optional element of type ns2:DoubleMapItemType */
};
#endif

#ifndef SOAP_TYPE_ns2__StringMapItemType
#define SOAP_TYPE_ns2__StringMapItemType (25)
/* ns2:StringMapItemType */
struct ns2__StringMapItemType
{
	char *key;	/* required element of type xsd:string */
	char *value;	/* required element of type xsd:string */
};
#endif

#ifndef SOAP_TYPE_ns2__IntMapItemType
#define SOAP_TYPE_ns2__IntMapItemType (27)
/* ns2:IntMapItemType */
struct ns2__IntMapItemType
{
	char *key;	/* required element of type xsd:string */
	int value;	/* required element of type xsd:int */
};
#endif

#ifndef SOAP_TYPE_ns2__LongMapItemType
#define SOAP_TYPE_ns2__LongMapItemType (29)
/* ns2:LongMapItemType */
struct ns2__LongMapItemType
{
	char *key;	/* required element of type xsd:string */
	LONG64 value;	/* required element of type xsd:long */
};
#endif

#ifndef SOAP_TYPE_ns2__FloatMapItemType
#define SOAP_TYPE_ns2__FloatMapItemType (31)
/* ns2:FloatMapItemType */
struct ns2__FloatMapItemType
{
	char *key;	/* required element of type xsd:string */
	float value;	/* required element of type xsd:float */
};
#endif

#ifndef SOAP_TYPE_ns2__DoubleMapItemType
#define SOAP_TYPE_ns2__DoubleMapItemType (33)
/* ns2:DoubleMapItemType */
struct ns2__DoubleMapItemType
{
	char *key;	/* required element of type xsd:string */
	double value;	/* required element of type xsd:double */
};
#endif

#ifndef SOAP_TYPE_ns2__AuthHeader
#define SOAP_TYPE_ns2__AuthHeader (37)
/* ns2:AuthHeader */
struct ns2__AuthHeader
{
	char *username;	/* optional element of type xsd:string */
	char *password;	/* optional element of type xsd:string */
	char *token;	/* required element of type xsd:string */
	char *target;	/* optional element of type xsd:string */
	char *accessToken;	/* optional element of type xsd:string */
	int *account_USCOREtype;	/* optional element of type xsd:int */
};
#endif

#ifndef SOAP_TYPE_ns2__ResHeader
#define SOAP_TYPE_ns2__ResHeader (38)
/* ns2:ResHeader */
struct ns2__ResHeader
{
	char *desc;	/* required element of type xsd:string */
	int __sizefailures;	/* sequence of elements <failures> */
	struct ns2__Failure *failures;	/* optional element of type ns2:Failure */
	int *oprs;	/* optional element of type xsd:int */
	int *oprtime;	/* optional element of type xsd:int */
	int *quota;	/* optional element of type xsd:int */
	int *rquota;	/* optional element of type xsd:int */
	int status;	/* required element of type xsd:int */
};
#endif

#ifndef SOAP_TYPE_ns2__Failure
#define SOAP_TYPE_ns2__Failure (39)
/* ns2:Failure */
struct ns2__Failure
{
	int code;	/* required element of type xsd:int */
	char *message;	/* optional element of type xsd:string */
	char *position;	/* required element of type xsd:string */
	char *content;	/* optional element of type xsd:string */
};
#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (41)
/* SOAP Header: */
struct SOAP_ENV__Header
{
	struct ns2__AuthHeader *ns2__AuthHeader;	/* mustUnderstand */
	struct ns2__ResHeader *ns2__ResHeader;	/* optional element of type ns2:ResHeader */
};
#endif

#endif

#ifndef SOAP_TYPE___ns1__getProfessionalReportId
#define SOAP_TYPE___ns1__getProfessionalReportId (47)
/* Operation wrapper: */
struct __ns1__getProfessionalReportId
{
	struct _ns1__getProfessionalReportIdRequest *ns1__getProfessionalReportIdRequest;	/* optional element of type ns1:getProfessionalReportIdRequest */
};
#endif

#ifndef SOAP_TYPE___ns1__getReportState
#define SOAP_TYPE___ns1__getReportState (51)
/* Operation wrapper: */
struct __ns1__getReportState
{
	struct _ns1__getReportStateRequest *ns1__getReportStateRequest;	/* optional element of type ns1:getReportStateRequest */
};
#endif

#ifndef SOAP_TYPE___ns1__getReportFileUrl
#define SOAP_TYPE___ns1__getReportFileUrl (55)
/* Operation wrapper: */
struct __ns1__getReportFileUrl
{
	struct _ns1__getReportFileUrlRequest *ns1__getReportFileUrlRequest;	/* optional element of type ns1:getReportFileUrlRequest */
};
#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (56)
/* SOAP Fault Code: */
struct SOAP_ENV__Code
{
	char *SOAP_ENV__Value;	/* optional element of type xsd:QName */
	struct SOAP_ENV__Code *SOAP_ENV__Subcode;	/* optional element of type SOAP-ENV:Code */
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (58)
/* SOAP-ENV:Detail */
struct SOAP_ENV__Detail
{
	char *__any;
	int __type;	/* any type of element <fault> (defined below) */
	void *fault;	/* transient */
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (61)
/* SOAP-ENV:Reason */
struct SOAP_ENV__Reason
{
	char *SOAP_ENV__Text;	/* optional element of type xsd:string */
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (62)
/* SOAP Fault: */
struct SOAP_ENV__Fault
{
	char *faultcode;	/* optional element of type xsd:QName */
	char *faultstring;	/* optional element of type xsd:string */
	char *faultactor;	/* optional element of type xsd:string */
	struct SOAP_ENV__Detail *detail;	/* optional element of type SOAP-ENV:Detail */
	struct SOAP_ENV__Code *SOAP_ENV__Code;	/* optional element of type SOAP-ENV:Code */
	struct SOAP_ENV__Reason *SOAP_ENV__Reason;	/* optional element of type SOAP-ENV:Reason */
	char *SOAP_ENV__Node;	/* optional element of type xsd:string */
	char *SOAP_ENV__Role;	/* optional element of type xsd:string */
	struct SOAP_ENV__Detail *SOAP_ENV__Detail;	/* optional element of type SOAP-ENV:Detail */
};
#endif

#endif

/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/

#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (5)
typedef char *_QName;
#endif

#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (6)
typedef char *_XML;
#endif


/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Client-Side Call Stubs                                                     *
 *                                                                            *
\******************************************************************************/


SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__getProfessionalReportId(struct soap *soap, const char *soap_endpoint, const char *soap_action, struct _ns1__getProfessionalReportIdRequest *ns1__getProfessionalReportIdRequest, struct _ns1__getProfessionalReportIdResponse *ns1__getProfessionalReportIdResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__getReportState(struct soap *soap, const char *soap_endpoint, const char *soap_action, struct _ns1__getReportStateRequest *ns1__getReportStateRequest, struct _ns1__getReportStateResponse *ns1__getReportStateResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__getReportFileUrl(struct soap *soap, const char *soap_endpoint, const char *soap_action, struct _ns1__getReportFileUrlRequest *ns1__getReportFileUrlRequest, struct _ns1__getReportFileUrlResponse *ns1__getReportFileUrlResponse);

#ifdef __cplusplus
}
#endif

#endif

/* End of soapStub.h */
