/* soapC.c
   Generated by gSOAP 2.8.14 from demo.h

Copyright(C) 2000-2013, Robert van Engelen, Genivia Inc. All Rights Reserved.
The generated code is released under ONE of the following licenses:
GPL or Genivia's license for commercial use.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

#ifdef __cplusplus
extern "C" {
#endif

SOAP_SOURCE_STAMP("@(#) soapC.c ver 2.8.14 2013-07-02 10:03:49 GMT")
SOAP_NMAC struct Namespace namespaces[] =
{
	{"SOAP-ENV", "http://schemas.xmlsoap.org/soap/envelope/", "http://www.w3.org/*/soap-envelope", NULL},
	{"SOAP-ENC", "http://schemas.xmlsoap.org/soap/encoding/", "http://www.w3.org/*/soap-encoding", NULL},
	{"xsi", "http://www.w3.org/2001/XMLSchema-instance", "http://www.w3.org/*/XMLSchema-instance", NULL},
	{"xsd", "http://www.w3.org/2001/XMLSchema", "http://www.w3.org/*/XMLSchema", NULL},
	{"ns2", "http://api.baidu.com/sem/common/v2", NULL, NULL},
	{"ns1", "https://api.baidu.com/sem/sms/v2", NULL, NULL},
	{NULL, NULL, NULL, NULL}
};


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", soap->header, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->version && soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->version && soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (soap->header == NULL)
	{	if ((soap->header = (struct SOAP_ENV__Header*)soap_malloc(soap, sizeof(struct SOAP_ENV__Header))))
			soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (soap->fault == NULL)
	{	soap->fault = (struct SOAP_ENV__Fault*)soap_malloc(soap, sizeof(struct SOAP_ENV__Fault));
		if (soap->fault == NULL)
			return;
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = (struct SOAP_ENV__Code*)soap_malloc(soap, sizeof(struct SOAP_ENV__Code));
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = (struct SOAP_ENV__Reason*)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason));
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode == NULL)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = (struct SOAP_ENV__Code*)soap_malloc(soap, sizeof(struct SOAP_ENV__Code));
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code && soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode && soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
			return soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
		return NULL;
	}
	return soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Detail == NULL)
		{	soap->fault->SOAP_ENV__Detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
			soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
		}
		return (const char**)&soap->fault->SOAP_ENV__Detail->__any;
	}
	if (soap->fault->detail == NULL)
	{	soap->fault->detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
		soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
	}
	return (const char**)&soap->fault->detail->__any;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Detail)
		return soap->fault->SOAP_ENV__Detail->__any;
	if (soap->fault->detail)
		return soap->fault->detail->__any;
	return NULL;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	if (soap->version == 1)
	{	for (;;)
		{	if (!soap_getelement(soap, &t))
				if (soap->error || soap_ignore_element(soap))
					break;
		}
	}
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{	(void)type;
	if (soap_peek_element(soap))
		return NULL;
#ifndef WITH_NOIDREF
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_LONG64:
		return soap_in_LONG64(soap, NULL, NULL, "xsd:long");
	case SOAP_TYPE_float:
		return soap_in_float(soap, NULL, NULL, "xsd:float");
	case SOAP_TYPE_double:
		return soap_in_double(soap, NULL, NULL, "xsd:double");
	case SOAP_TYPE_time:
		return soap_in_time(soap, NULL, NULL, "xsd:dateTime");
	case SOAP_TYPE_xsd__boolean:
		return soap_in_xsd__boolean(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_ns2__Failure:
		return soap_in_ns2__Failure(soap, NULL, NULL, "ns2:Failure");
	case SOAP_TYPE_ns2__ResHeader:
		return soap_in_ns2__ResHeader(soap, NULL, NULL, "ns2:ResHeader");
	case SOAP_TYPE_ns2__AuthHeader:
		return soap_in_ns2__AuthHeader(soap, NULL, NULL, "ns2:AuthHeader");
	case SOAP_TYPE_ns2__DoubleMapItemType:
		return soap_in_ns2__DoubleMapItemType(soap, NULL, NULL, "ns2:DoubleMapItemType");
	case SOAP_TYPE_ns2__FloatMapItemType:
		return soap_in_ns2__FloatMapItemType(soap, NULL, NULL, "ns2:FloatMapItemType");
	case SOAP_TYPE_ns2__LongMapItemType:
		return soap_in_ns2__LongMapItemType(soap, NULL, NULL, "ns2:LongMapItemType");
	case SOAP_TYPE_ns2__IntMapItemType:
		return soap_in_ns2__IntMapItemType(soap, NULL, NULL, "ns2:IntMapItemType");
	case SOAP_TYPE_ns2__StringMapItemType:
		return soap_in_ns2__StringMapItemType(soap, NULL, NULL, "ns2:StringMapItemType");
	case SOAP_TYPE_ns1__ChangedNewCreativeScaleType:
		return soap_in_ns1__ChangedNewCreativeScaleType(soap, NULL, NULL, "ns1:ChangedNewCreativeScaleType");
	case SOAP_TYPE_ns1__ChangedNewCreativeType:
		return soap_in_ns1__ChangedNewCreativeType(soap, NULL, NULL, "ns1:ChangedNewCreativeType");
	case SOAP_TYPE_ns1__TopNkeywordsData:
		return soap_in_ns1__TopNkeywordsData(soap, NULL, NULL, "ns1:TopNkeywordsData");
	case SOAP_TYPE_ns1__VariableColumn:
		return soap_in_ns1__VariableColumn(soap, NULL, NULL, "ns1:VariableColumn");
	case SOAP_TYPE_ns1__ChangedItemType:
		return soap_in_ns1__ChangedItemType(soap, NULL, NULL, "ns1:ChangedItemType");
	case SOAP_TYPE_ns1__ChangedAdgroupIdType:
		return soap_in_ns1__ChangedAdgroupIdType(soap, NULL, NULL, "ns1:ChangedAdgroupIdType");
	case SOAP_TYPE_ns1__ChangedCampaignIdType:
		return soap_in_ns1__ChangedCampaignIdType(soap, NULL, NULL, "ns1:ChangedCampaignIdType");
	case SOAP_TYPE_ns2__OptType:
		return soap_in_ns2__OptType(soap, NULL, NULL, "ns2:OptType");
	case SOAP_TYPE_ns1__AccountInfoType:
		return soap_in_ns1__AccountInfoType(soap, NULL, NULL, "ns1:AccountInfoType");
	case SOAP_TYPE_PointerTo_ns1__GetChangedNewCreativeIdResponse:
		return soap_in_PointerTo_ns1__GetChangedNewCreativeIdResponse(soap, NULL, NULL, "ns1:GetChangedNewCreativeIdResponse");
	case SOAP_TYPE_PointerTo_ns1__GetChangedNewCreativeIdRequest:
		return soap_in_PointerTo_ns1__GetChangedNewCreativeIdRequest(soap, NULL, NULL, "ns1:GetChangedNewCreativeIdRequest");
	case SOAP_TYPE_PointerTo_ns1__getAccountBudgetResponse:
		return soap_in_PointerTo_ns1__getAccountBudgetResponse(soap, NULL, NULL, "ns1:getAccountBudgetResponse");
	case SOAP_TYPE_PointerTo_ns1__getAccountBudgetRequest:
		return soap_in_PointerTo_ns1__getAccountBudgetRequest(soap, NULL, NULL, "ns1:getAccountBudgetRequest");
	case SOAP_TYPE_PointerTo_ns1__updateAccountBudgetResponse:
		return soap_in_PointerTo_ns1__updateAccountBudgetResponse(soap, NULL, NULL, "ns1:updateAccountBudgetResponse");
	case SOAP_TYPE_PointerTo_ns1__updateAccountBudgetRequest:
		return soap_in_PointerTo_ns1__updateAccountBudgetRequest(soap, NULL, NULL, "ns1:updateAccountBudgetRequest");
	case SOAP_TYPE_PointerTo_ns1__gettopNKeywordsDataResponse:
		return soap_in_PointerTo_ns1__gettopNKeywordsDataResponse(soap, NULL, NULL, "ns1:gettopNKeywordsDataResponse");
	case SOAP_TYPE_PointerTo_ns1__gettopNKeywordsDataRequest:
		return soap_in_PointerTo_ns1__gettopNKeywordsDataRequest(soap, NULL, NULL, "ns1:gettopNKeywordsDataRequest");
	case SOAP_TYPE_PointerTo_ns1__getAllChangedObjectsPathResponse:
		return soap_in_PointerTo_ns1__getAllChangedObjectsPathResponse(soap, NULL, NULL, "ns1:getAllChangedObjectsPathResponse");
	case SOAP_TYPE_PointerTo_ns1__getAllChangedObjectsPathRequest:
		return soap_in_PointerTo_ns1__getAllChangedObjectsPathRequest(soap, NULL, NULL, "ns1:getAllChangedObjectsPathRequest");
	case SOAP_TYPE_PointerTo_ns1__getAllChangedObjectsResponse:
		return soap_in_PointerTo_ns1__getAllChangedObjectsResponse(soap, NULL, NULL, "ns1:getAllChangedObjectsResponse");
	case SOAP_TYPE_PointerTo_ns1__getAllChangedObjectsRequest:
		return soap_in_PointerTo_ns1__getAllChangedObjectsRequest(soap, NULL, NULL, "ns1:getAllChangedObjectsRequest");
	case SOAP_TYPE_PointerTo_ns1__getSelectedObjectsPathResponse:
		return soap_in_PointerTo_ns1__getSelectedObjectsPathResponse(soap, NULL, NULL, "ns1:getSelectedObjectsPathResponse");
	case SOAP_TYPE_PointerTo_ns1__getSelectedObjectsPathRequest:
		return soap_in_PointerTo_ns1__getSelectedObjectsPathRequest(soap, NULL, NULL, "ns1:getSelectedObjectsPathRequest");
	case SOAP_TYPE_PointerTo_ns1__getAllObjectsPathResponse:
		return soap_in_PointerTo_ns1__getAllObjectsPathResponse(soap, NULL, NULL, "ns1:getAllObjectsPathResponse");
	case SOAP_TYPE_PointerTo_ns1__getAllObjectsPathRequest:
		return soap_in_PointerTo_ns1__getAllObjectsPathRequest(soap, NULL, NULL, "ns1:getAllObjectsPathRequest");
	case SOAP_TYPE_PointerTo_ns1__getFileStateResponse:
		return soap_in_PointerTo_ns1__getFileStateResponse(soap, NULL, NULL, "ns1:getFileStateResponse");
	case SOAP_TYPE_PointerTo_ns1__getFileStateRequest:
		return soap_in_PointerTo_ns1__getFileStateRequest(soap, NULL, NULL, "ns1:getFileStateRequest");
	case SOAP_TYPE_PointerTo_ns1__getSelectedObjectsResponse:
		return soap_in_PointerTo_ns1__getSelectedObjectsResponse(soap, NULL, NULL, "ns1:getSelectedObjectsResponse");
	case SOAP_TYPE_PointerTo_ns1__getSelectedObjectsRequest:
		return soap_in_PointerTo_ns1__getSelectedObjectsRequest(soap, NULL, NULL, "ns1:getSelectedObjectsRequest");
	case SOAP_TYPE_PointerTo_ns1__getChangedScaleResponse:
		return soap_in_PointerTo_ns1__getChangedScaleResponse(soap, NULL, NULL, "ns1:getChangedScaleResponse");
	case SOAP_TYPE_PointerTo_ns1__getChangedScaleRequest:
		return soap_in_PointerTo_ns1__getChangedScaleRequest(soap, NULL, NULL, "ns1:getChangedScaleRequest");
	case SOAP_TYPE_PointerTo_ns1__getAllObjectsResponse:
		return soap_in_PointerTo_ns1__getAllObjectsResponse(soap, NULL, NULL, "ns1:getAllObjectsResponse");
	case SOAP_TYPE_PointerTo_ns1__getAllObjectsRequest:
		return soap_in_PointerTo_ns1__getAllObjectsRequest(soap, NULL, NULL, "ns1:getAllObjectsRequest");
	case SOAP_TYPE_PointerTo_ns1__getChangedIdResponse:
		return soap_in_PointerTo_ns1__getChangedIdResponse(soap, NULL, NULL, "ns1:getChangedIdResponse");
	case SOAP_TYPE_PointerTo_ns1__getChangedIdRequest:
		return soap_in_PointerTo_ns1__getChangedIdRequest(soap, NULL, NULL, "ns1:getChangedIdRequest");
	case SOAP_TYPE_PointerTo_ns1__getChangedItemIdResponse:
		return soap_in_PointerTo_ns1__getChangedItemIdResponse(soap, NULL, NULL, "ns1:getChangedItemIdResponse");
	case SOAP_TYPE_PointerTo_ns1__getChangedItemIdRequest:
		return soap_in_PointerTo_ns1__getChangedItemIdRequest(soap, NULL, NULL, "ns1:getChangedItemIdRequest");
	case SOAP_TYPE_PointerTo_ns1__getChangedAdgroupIdResponse:
		return soap_in_PointerTo_ns1__getChangedAdgroupIdResponse(soap, NULL, NULL, "ns1:getChangedAdgroupIdResponse");
	case SOAP_TYPE_PointerTo_ns1__getChangedAdgroupIdRequest:
		return soap_in_PointerTo_ns1__getChangedAdgroupIdRequest(soap, NULL, NULL, "ns1:getChangedAdgroupIdRequest");
	case SOAP_TYPE_PointerTo_ns1__getChangedCampaignIdResponse:
		return soap_in_PointerTo_ns1__getChangedCampaignIdResponse(soap, NULL, NULL, "ns1:getChangedCampaignIdResponse");
	case SOAP_TYPE_PointerTo_ns1__getChangedCampaignIdRequest:
		return soap_in_PointerTo_ns1__getChangedCampaignIdRequest(soap, NULL, NULL, "ns1:getChangedCampaignIdRequest");
	case SOAP_TYPE_PointerTo_ns1__updateAccountInfoResponse:
		return soap_in_PointerTo_ns1__updateAccountInfoResponse(soap, NULL, NULL, "ns1:updateAccountInfoResponse");
	case SOAP_TYPE_PointerTo_ns1__updateAccountInfoRequest:
		return soap_in_PointerTo_ns1__updateAccountInfoRequest(soap, NULL, NULL, "ns1:updateAccountInfoRequest");
	case SOAP_TYPE_PointerTo_ns1__getAccountInfoResponse:
		return soap_in_PointerTo_ns1__getAccountInfoResponse(soap, NULL, NULL, "ns1:getAccountInfoResponse");
	case SOAP_TYPE_PointerTo_ns1__getAccountInfoRequest:
		return soap_in_PointerTo_ns1__getAccountInfoRequest(soap, NULL, NULL, "ns1:getAccountInfoRequest");
	case SOAP_TYPE_PointerTons2__ResHeader:
		return soap_in_PointerTons2__ResHeader(soap, NULL, NULL, "ns2:ResHeader");
	case SOAP_TYPE_PointerTons2__AuthHeader:
		return soap_in_PointerTons2__AuthHeader(soap, NULL, NULL, "ns2:AuthHeader");
	case SOAP_TYPE_PointerTons2__Failure:
		return soap_in_PointerTons2__Failure(soap, NULL, NULL, "ns2:Failure");
	case SOAP_TYPE_PointerTons2__DoubleMapItemType:
		return soap_in_PointerTons2__DoubleMapItemType(soap, NULL, NULL, "ns2:DoubleMapItemType");
	case SOAP_TYPE_PointerTons2__FloatMapItemType:
		return soap_in_PointerTons2__FloatMapItemType(soap, NULL, NULL, "ns2:FloatMapItemType");
	case SOAP_TYPE_PointerTons2__LongMapItemType:
		return soap_in_PointerTons2__LongMapItemType(soap, NULL, NULL, "ns2:LongMapItemType");
	case SOAP_TYPE_PointerTons2__IntMapItemType:
		return soap_in_PointerTons2__IntMapItemType(soap, NULL, NULL, "ns2:IntMapItemType");
	case SOAP_TYPE_PointerTons2__StringMapItemType:
		return soap_in_PointerTons2__StringMapItemType(soap, NULL, NULL, "ns2:StringMapItemType");
	case SOAP_TYPE_PointerTons1__ChangedNewCreativeType:
		return soap_in_PointerTons1__ChangedNewCreativeType(soap, NULL, NULL, "ns1:ChangedNewCreativeType");
	case SOAP_TYPE_PointerTons1__TopNkeywordsData:
		return soap_in_PointerTons1__TopNkeywordsData(soap, NULL, NULL, "ns1:TopNkeywordsData");
	case SOAP_TYPE_PointerTons1__ChangedNewCreativeScaleType:
		return soap_in_PointerTons1__ChangedNewCreativeScaleType(soap, NULL, NULL, "ns1:ChangedNewCreativeScaleType");
	case SOAP_TYPE_PointerTons1__VariableColumn:
		return soap_in_PointerTons1__VariableColumn(soap, NULL, NULL, "ns1:VariableColumn");
	case SOAP_TYPE_PointerTons1__ChangedItemType:
		return soap_in_PointerTons1__ChangedItemType(soap, NULL, NULL, "ns1:ChangedItemType");
	case SOAP_TYPE_PointerTons1__ChangedAdgroupIdType:
		return soap_in_PointerTons1__ChangedAdgroupIdType(soap, NULL, NULL, "ns1:ChangedAdgroupIdType");
	case SOAP_TYPE_PointerTons1__ChangedCampaignIdType:
		return soap_in_PointerTons1__ChangedCampaignIdType(soap, NULL, NULL, "ns1:ChangedCampaignIdType");
	case SOAP_TYPE_PointerTotime:
		return soap_in_PointerTotime(soap, NULL, NULL, "xsd:dateTime");
	case SOAP_TYPE_PointerToxsd__boolean:
		return soap_in_PointerToxsd__boolean(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_PointerTons1__AccountInfoType:
		return soap_in_PointerTons1__AccountInfoType(soap, NULL, NULL, "ns1:AccountInfoType");
	case SOAP_TYPE_PointerTons2__OptType:
		return soap_in_PointerTons2__OptType(soap, NULL, NULL, "ns2:OptType");
	case SOAP_TYPE_PointerTostring:
		return soap_in_PointerTostring(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_PointerToint:
		return soap_in_PointerToint(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_PointerTodouble:
		return soap_in_PointerTodouble(soap, NULL, NULL, "xsd:double");
	case SOAP_TYPE_PointerToLONG64:
		return soap_in_PointerToLONG64(soap, NULL, NULL, "xsd:long");
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
#endif
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:long"))
		{	*type = SOAP_TYPE_LONG64;
			return soap_in_LONG64(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:float"))
		{	*type = SOAP_TYPE_float;
			return soap_in_float(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:double"))
		{	*type = SOAP_TYPE_double;
			return soap_in_double(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:dateTime"))
		{	*type = SOAP_TYPE_time;
			return soap_in_time(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_xsd__boolean;
			return soap_in_xsd__boolean(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:Failure"))
		{	*type = SOAP_TYPE_ns2__Failure;
			return soap_in_ns2__Failure(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ResHeader"))
		{	*type = SOAP_TYPE_ns2__ResHeader;
			return soap_in_ns2__ResHeader(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:AuthHeader"))
		{	*type = SOAP_TYPE_ns2__AuthHeader;
			return soap_in_ns2__AuthHeader(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:DoubleMapItemType"))
		{	*type = SOAP_TYPE_ns2__DoubleMapItemType;
			return soap_in_ns2__DoubleMapItemType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:FloatMapItemType"))
		{	*type = SOAP_TYPE_ns2__FloatMapItemType;
			return soap_in_ns2__FloatMapItemType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:LongMapItemType"))
		{	*type = SOAP_TYPE_ns2__LongMapItemType;
			return soap_in_ns2__LongMapItemType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:IntMapItemType"))
		{	*type = SOAP_TYPE_ns2__IntMapItemType;
			return soap_in_ns2__IntMapItemType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:StringMapItemType"))
		{	*type = SOAP_TYPE_ns2__StringMapItemType;
			return soap_in_ns2__StringMapItemType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ChangedNewCreativeScaleType"))
		{	*type = SOAP_TYPE_ns1__ChangedNewCreativeScaleType;
			return soap_in_ns1__ChangedNewCreativeScaleType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ChangedNewCreativeType"))
		{	*type = SOAP_TYPE_ns1__ChangedNewCreativeType;
			return soap_in_ns1__ChangedNewCreativeType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:TopNkeywordsData"))
		{	*type = SOAP_TYPE_ns1__TopNkeywordsData;
			return soap_in_ns1__TopNkeywordsData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:VariableColumn"))
		{	*type = SOAP_TYPE_ns1__VariableColumn;
			return soap_in_ns1__VariableColumn(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ChangedItemType"))
		{	*type = SOAP_TYPE_ns1__ChangedItemType;
			return soap_in_ns1__ChangedItemType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ChangedAdgroupIdType"))
		{	*type = SOAP_TYPE_ns1__ChangedAdgroupIdType;
			return soap_in_ns1__ChangedAdgroupIdType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ChangedCampaignIdType"))
		{	*type = SOAP_TYPE_ns1__ChangedCampaignIdType;
			return soap_in_ns1__ChangedCampaignIdType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:OptType"))
		{	*type = SOAP_TYPE_ns2__OptType;
			return soap_in_ns2__OptType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:AccountInfoType"))
		{	*type = SOAP_TYPE_ns1__AccountInfoType;
			return soap_in_ns1__AccountInfoType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
		if (!soap_match_tag(soap, t, "ns1:GetChangedNewCreativeIdResponse"))
		{	*type = SOAP_TYPE__ns1__GetChangedNewCreativeIdResponse;
			return soap_in__ns1__GetChangedNewCreativeIdResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetChangedNewCreativeIdRequest"))
		{	*type = SOAP_TYPE__ns1__GetChangedNewCreativeIdRequest;
			return soap_in__ns1__GetChangedNewCreativeIdRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getAccountBudgetResponse"))
		{	*type = SOAP_TYPE__ns1__getAccountBudgetResponse;
			return soap_in__ns1__getAccountBudgetResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getAccountBudgetRequest"))
		{	*type = SOAP_TYPE__ns1__getAccountBudgetRequest;
			return soap_in__ns1__getAccountBudgetRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:updateAccountBudgetResponse"))
		{	*type = SOAP_TYPE__ns1__updateAccountBudgetResponse;
			return soap_in__ns1__updateAccountBudgetResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:updateAccountBudgetRequest"))
		{	*type = SOAP_TYPE__ns1__updateAccountBudgetRequest;
			return soap_in__ns1__updateAccountBudgetRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:gettopNKeywordsDataResponse"))
		{	*type = SOAP_TYPE__ns1__gettopNKeywordsDataResponse;
			return soap_in__ns1__gettopNKeywordsDataResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:gettopNKeywordsDataRequest"))
		{	*type = SOAP_TYPE__ns1__gettopNKeywordsDataRequest;
			return soap_in__ns1__gettopNKeywordsDataRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getAllChangedObjectsPathResponse"))
		{	*type = SOAP_TYPE__ns1__getAllChangedObjectsPathResponse;
			return soap_in__ns1__getAllChangedObjectsPathResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getAllChangedObjectsPathRequest"))
		{	*type = SOAP_TYPE__ns1__getAllChangedObjectsPathRequest;
			return soap_in__ns1__getAllChangedObjectsPathRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getAllChangedObjectsResponse"))
		{	*type = SOAP_TYPE__ns1__getAllChangedObjectsResponse;
			return soap_in__ns1__getAllChangedObjectsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getAllChangedObjectsRequest"))
		{	*type = SOAP_TYPE__ns1__getAllChangedObjectsRequest;
			return soap_in__ns1__getAllChangedObjectsRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getSelectedObjectsPathResponse"))
		{	*type = SOAP_TYPE__ns1__getSelectedObjectsPathResponse;
			return soap_in__ns1__getSelectedObjectsPathResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getSelectedObjectsPathRequest"))
		{	*type = SOAP_TYPE__ns1__getSelectedObjectsPathRequest;
			return soap_in__ns1__getSelectedObjectsPathRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getAllObjectsPathResponse"))
		{	*type = SOAP_TYPE__ns1__getAllObjectsPathResponse;
			return soap_in__ns1__getAllObjectsPathResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getAllObjectsPathRequest"))
		{	*type = SOAP_TYPE__ns1__getAllObjectsPathRequest;
			return soap_in__ns1__getAllObjectsPathRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getFileStateResponse"))
		{	*type = SOAP_TYPE__ns1__getFileStateResponse;
			return soap_in__ns1__getFileStateResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getFileStateRequest"))
		{	*type = SOAP_TYPE__ns1__getFileStateRequest;
			return soap_in__ns1__getFileStateRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getSelectedObjectsResponse"))
		{	*type = SOAP_TYPE__ns1__getSelectedObjectsResponse;
			return soap_in__ns1__getSelectedObjectsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getSelectedObjectsRequest"))
		{	*type = SOAP_TYPE__ns1__getSelectedObjectsRequest;
			return soap_in__ns1__getSelectedObjectsRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getChangedScaleResponse"))
		{	*type = SOAP_TYPE__ns1__getChangedScaleResponse;
			return soap_in__ns1__getChangedScaleResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getChangedScaleRequest"))
		{	*type = SOAP_TYPE__ns1__getChangedScaleRequest;
			return soap_in__ns1__getChangedScaleRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getAllObjectsResponse"))
		{	*type = SOAP_TYPE__ns1__getAllObjectsResponse;
			return soap_in__ns1__getAllObjectsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getAllObjectsRequest"))
		{	*type = SOAP_TYPE__ns1__getAllObjectsRequest;
			return soap_in__ns1__getAllObjectsRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getChangedIdResponse"))
		{	*type = SOAP_TYPE__ns1__getChangedIdResponse;
			return soap_in__ns1__getChangedIdResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getChangedIdRequest"))
		{	*type = SOAP_TYPE__ns1__getChangedIdRequest;
			return soap_in__ns1__getChangedIdRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getChangedItemIdResponse"))
		{	*type = SOAP_TYPE__ns1__getChangedItemIdResponse;
			return soap_in__ns1__getChangedItemIdResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getChangedItemIdRequest"))
		{	*type = SOAP_TYPE__ns1__getChangedItemIdRequest;
			return soap_in__ns1__getChangedItemIdRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getChangedAdgroupIdResponse"))
		{	*type = SOAP_TYPE__ns1__getChangedAdgroupIdResponse;
			return soap_in__ns1__getChangedAdgroupIdResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getChangedAdgroupIdRequest"))
		{	*type = SOAP_TYPE__ns1__getChangedAdgroupIdRequest;
			return soap_in__ns1__getChangedAdgroupIdRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getChangedCampaignIdResponse"))
		{	*type = SOAP_TYPE__ns1__getChangedCampaignIdResponse;
			return soap_in__ns1__getChangedCampaignIdResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getChangedCampaignIdRequest"))
		{	*type = SOAP_TYPE__ns1__getChangedCampaignIdRequest;
			return soap_in__ns1__getChangedCampaignIdRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:updateAccountInfoResponse"))
		{	*type = SOAP_TYPE__ns1__updateAccountInfoResponse;
			return soap_in__ns1__updateAccountInfoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:updateAccountInfoRequest"))
		{	*type = SOAP_TYPE__ns1__updateAccountInfoRequest;
			return soap_in__ns1__updateAccountInfoRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getAccountInfoResponse"))
		{	*type = SOAP_TYPE__ns1__getAccountInfoResponse;
			return soap_in__ns1__getAccountInfoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getAccountInfoRequest"))
		{	*type = SOAP_TYPE__ns1__getAccountInfoRequest;
			return soap_in__ns1__getAccountInfoRequest(soap, NULL, NULL, NULL);
		}
#ifndef WITH_NOIDREF
	}
#endif
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level=%u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{	(void)tag;
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_LONG64:
		return soap_out_LONG64(soap, tag, id, (const LONG64 *)ptr, "xsd:long");
	case SOAP_TYPE_float:
		return soap_out_float(soap, tag, id, (const float *)ptr, "xsd:float");
	case SOAP_TYPE_double:
		return soap_out_double(soap, tag, id, (const double *)ptr, "xsd:double");
	case SOAP_TYPE_time:
		return soap_out_time(soap, tag, id, (const time_t *)ptr, "xsd:dateTime");
	case SOAP_TYPE_xsd__boolean:
		return soap_out_xsd__boolean(soap, tag, id, (const enum xsd__boolean *)ptr, "xsd:boolean");
	case SOAP_TYPE_ns2__Failure:
		return soap_out_ns2__Failure(soap, tag, id, (const struct ns2__Failure *)ptr, "ns2:Failure");
	case SOAP_TYPE_ns2__ResHeader:
		return soap_out_ns2__ResHeader(soap, tag, id, (const struct ns2__ResHeader *)ptr, "ns2:ResHeader");
	case SOAP_TYPE_ns2__AuthHeader:
		return soap_out_ns2__AuthHeader(soap, tag, id, (const struct ns2__AuthHeader *)ptr, "ns2:AuthHeader");
	case SOAP_TYPE_ns2__DoubleMapItemType:
		return soap_out_ns2__DoubleMapItemType(soap, tag, id, (const struct ns2__DoubleMapItemType *)ptr, "ns2:DoubleMapItemType");
	case SOAP_TYPE_ns2__FloatMapItemType:
		return soap_out_ns2__FloatMapItemType(soap, tag, id, (const struct ns2__FloatMapItemType *)ptr, "ns2:FloatMapItemType");
	case SOAP_TYPE_ns2__LongMapItemType:
		return soap_out_ns2__LongMapItemType(soap, tag, id, (const struct ns2__LongMapItemType *)ptr, "ns2:LongMapItemType");
	case SOAP_TYPE_ns2__IntMapItemType:
		return soap_out_ns2__IntMapItemType(soap, tag, id, (const struct ns2__IntMapItemType *)ptr, "ns2:IntMapItemType");
	case SOAP_TYPE_ns2__StringMapItemType:
		return soap_out_ns2__StringMapItemType(soap, tag, id, (const struct ns2__StringMapItemType *)ptr, "ns2:StringMapItemType");
	case SOAP_TYPE__ns1__GetChangedNewCreativeIdResponse:
		return soap_out__ns1__GetChangedNewCreativeIdResponse(soap, "ns1:GetChangedNewCreativeIdResponse", id, (const struct _ns1__GetChangedNewCreativeIdResponse *)ptr, NULL);
	case SOAP_TYPE__ns1__GetChangedNewCreativeIdRequest:
		return soap_out__ns1__GetChangedNewCreativeIdRequest(soap, "ns1:GetChangedNewCreativeIdRequest", id, (const struct _ns1__GetChangedNewCreativeIdRequest *)ptr, NULL);
	case SOAP_TYPE__ns1__getAccountBudgetResponse:
		return soap_out__ns1__getAccountBudgetResponse(soap, "ns1:getAccountBudgetResponse", id, (const struct _ns1__getAccountBudgetResponse *)ptr, NULL);
	case SOAP_TYPE__ns1__getAccountBudgetRequest:
		return soap_out__ns1__getAccountBudgetRequest(soap, "ns1:getAccountBudgetRequest", id, (const struct _ns1__getAccountBudgetRequest *)ptr, NULL);
	case SOAP_TYPE__ns1__updateAccountBudgetResponse:
		return soap_out__ns1__updateAccountBudgetResponse(soap, "ns1:updateAccountBudgetResponse", id, (const struct _ns1__updateAccountBudgetResponse *)ptr, NULL);
	case SOAP_TYPE__ns1__updateAccountBudgetRequest:
		return soap_out__ns1__updateAccountBudgetRequest(soap, "ns1:updateAccountBudgetRequest", id, (const struct _ns1__updateAccountBudgetRequest *)ptr, NULL);
	case SOAP_TYPE__ns1__gettopNKeywordsDataResponse:
		return soap_out__ns1__gettopNKeywordsDataResponse(soap, "ns1:gettopNKeywordsDataResponse", id, (const struct _ns1__gettopNKeywordsDataResponse *)ptr, NULL);
	case SOAP_TYPE__ns1__gettopNKeywordsDataRequest:
		return soap_out__ns1__gettopNKeywordsDataRequest(soap, "ns1:gettopNKeywordsDataRequest", id, (const struct _ns1__gettopNKeywordsDataRequest *)ptr, NULL);
	case SOAP_TYPE__ns1__getAllChangedObjectsPathResponse:
		return soap_out__ns1__getAllChangedObjectsPathResponse(soap, "ns1:getAllChangedObjectsPathResponse", id, (const struct _ns1__getAllChangedObjectsPathResponse *)ptr, NULL);
	case SOAP_TYPE__ns1__getAllChangedObjectsPathRequest:
		return soap_out__ns1__getAllChangedObjectsPathRequest(soap, "ns1:getAllChangedObjectsPathRequest", id, (const struct _ns1__getAllChangedObjectsPathRequest *)ptr, NULL);
	case SOAP_TYPE__ns1__getAllChangedObjectsResponse:
		return soap_out__ns1__getAllChangedObjectsResponse(soap, "ns1:getAllChangedObjectsResponse", id, (const struct _ns1__getAllChangedObjectsResponse *)ptr, NULL);
	case SOAP_TYPE__ns1__getAllChangedObjectsRequest:
		return soap_out__ns1__getAllChangedObjectsRequest(soap, "ns1:getAllChangedObjectsRequest", id, (const struct _ns1__getAllChangedObjectsRequest *)ptr, NULL);
	case SOAP_TYPE__ns1__getSelectedObjectsPathResponse:
		return soap_out__ns1__getSelectedObjectsPathResponse(soap, "ns1:getSelectedObjectsPathResponse", id, (const struct _ns1__getSelectedObjectsPathResponse *)ptr, NULL);
	case SOAP_TYPE__ns1__getSelectedObjectsPathRequest:
		return soap_out__ns1__getSelectedObjectsPathRequest(soap, "ns1:getSelectedObjectsPathRequest", id, (const struct _ns1__getSelectedObjectsPathRequest *)ptr, NULL);
	case SOAP_TYPE__ns1__getAllObjectsPathResponse:
		return soap_out__ns1__getAllObjectsPathResponse(soap, "ns1:getAllObjectsPathResponse", id, (const struct _ns1__getAllObjectsPathResponse *)ptr, NULL);
	case SOAP_TYPE__ns1__getAllObjectsPathRequest:
		return soap_out__ns1__getAllObjectsPathRequest(soap, "ns1:getAllObjectsPathRequest", id, (const struct _ns1__getAllObjectsPathRequest *)ptr, NULL);
	case SOAP_TYPE__ns1__getFileStateResponse:
		return soap_out__ns1__getFileStateResponse(soap, "ns1:getFileStateResponse", id, (const struct _ns1__getFileStateResponse *)ptr, NULL);
	case SOAP_TYPE__ns1__getFileStateRequest:
		return soap_out__ns1__getFileStateRequest(soap, "ns1:getFileStateRequest", id, (const struct _ns1__getFileStateRequest *)ptr, NULL);
	case SOAP_TYPE__ns1__getSelectedObjectsResponse:
		return soap_out__ns1__getSelectedObjectsResponse(soap, "ns1:getSelectedObjectsResponse", id, (const struct _ns1__getSelectedObjectsResponse *)ptr, NULL);
	case SOAP_TYPE__ns1__getSelectedObjectsRequest:
		return soap_out__ns1__getSelectedObjectsRequest(soap, "ns1:getSelectedObjectsRequest", id, (const struct _ns1__getSelectedObjectsRequest *)ptr, NULL);
	case SOAP_TYPE__ns1__getChangedScaleResponse:
		return soap_out__ns1__getChangedScaleResponse(soap, "ns1:getChangedScaleResponse", id, (const struct _ns1__getChangedScaleResponse *)ptr, NULL);
	case SOAP_TYPE__ns1__getChangedScaleRequest:
		return soap_out__ns1__getChangedScaleRequest(soap, "ns1:getChangedScaleRequest", id, (const struct _ns1__getChangedScaleRequest *)ptr, NULL);
	case SOAP_TYPE__ns1__getAllObjectsResponse:
		return soap_out__ns1__getAllObjectsResponse(soap, "ns1:getAllObjectsResponse", id, (const struct _ns1__getAllObjectsResponse *)ptr, NULL);
	case SOAP_TYPE__ns1__getAllObjectsRequest:
		return soap_out__ns1__getAllObjectsRequest(soap, "ns1:getAllObjectsRequest", id, (const struct _ns1__getAllObjectsRequest *)ptr, NULL);
	case SOAP_TYPE__ns1__getChangedIdResponse:
		return soap_out__ns1__getChangedIdResponse(soap, "ns1:getChangedIdResponse", id, (const struct _ns1__getChangedIdResponse *)ptr, NULL);
	case SOAP_TYPE__ns1__getChangedIdRequest:
		return soap_out__ns1__getChangedIdRequest(soap, "ns1:getChangedIdRequest", id, (const struct _ns1__getChangedIdRequest *)ptr, NULL);
	case SOAP_TYPE__ns1__getChangedItemIdResponse:
		return soap_out__ns1__getChangedItemIdResponse(soap, "ns1:getChangedItemIdResponse", id, (const struct _ns1__getChangedItemIdResponse *)ptr, NULL);
	case SOAP_TYPE__ns1__getChangedItemIdRequest:
		return soap_out__ns1__getChangedItemIdRequest(soap, "ns1:getChangedItemIdRequest", id, (const struct _ns1__getChangedItemIdRequest *)ptr, NULL);
	case SOAP_TYPE__ns1__getChangedAdgroupIdResponse:
		return soap_out__ns1__getChangedAdgroupIdResponse(soap, "ns1:getChangedAdgroupIdResponse", id, (const struct _ns1__getChangedAdgroupIdResponse *)ptr, NULL);
	case SOAP_TYPE__ns1__getChangedAdgroupIdRequest:
		return soap_out__ns1__getChangedAdgroupIdRequest(soap, "ns1:getChangedAdgroupIdRequest", id, (const struct _ns1__getChangedAdgroupIdRequest *)ptr, NULL);
	case SOAP_TYPE__ns1__getChangedCampaignIdResponse:
		return soap_out__ns1__getChangedCampaignIdResponse(soap, "ns1:getChangedCampaignIdResponse", id, (const struct _ns1__getChangedCampaignIdResponse *)ptr, NULL);
	case SOAP_TYPE__ns1__getChangedCampaignIdRequest:
		return soap_out__ns1__getChangedCampaignIdRequest(soap, "ns1:getChangedCampaignIdRequest", id, (const struct _ns1__getChangedCampaignIdRequest *)ptr, NULL);
	case SOAP_TYPE__ns1__updateAccountInfoResponse:
		return soap_out__ns1__updateAccountInfoResponse(soap, "ns1:updateAccountInfoResponse", id, (const struct _ns1__updateAccountInfoResponse *)ptr, NULL);
	case SOAP_TYPE__ns1__updateAccountInfoRequest:
		return soap_out__ns1__updateAccountInfoRequest(soap, "ns1:updateAccountInfoRequest", id, (const struct _ns1__updateAccountInfoRequest *)ptr, NULL);
	case SOAP_TYPE__ns1__getAccountInfoResponse:
		return soap_out__ns1__getAccountInfoResponse(soap, "ns1:getAccountInfoResponse", id, (const struct _ns1__getAccountInfoResponse *)ptr, NULL);
	case SOAP_TYPE__ns1__getAccountInfoRequest:
		return soap_out__ns1__getAccountInfoRequest(soap, "ns1:getAccountInfoRequest", id, (const struct _ns1__getAccountInfoRequest *)ptr, NULL);
	case SOAP_TYPE_ns1__ChangedNewCreativeScaleType:
		return soap_out_ns1__ChangedNewCreativeScaleType(soap, tag, id, (const struct ns1__ChangedNewCreativeScaleType *)ptr, "ns1:ChangedNewCreativeScaleType");
	case SOAP_TYPE_ns1__ChangedNewCreativeType:
		return soap_out_ns1__ChangedNewCreativeType(soap, tag, id, (const struct ns1__ChangedNewCreativeType *)ptr, "ns1:ChangedNewCreativeType");
	case SOAP_TYPE_ns1__TopNkeywordsData:
		return soap_out_ns1__TopNkeywordsData(soap, tag, id, (const struct ns1__TopNkeywordsData *)ptr, "ns1:TopNkeywordsData");
	case SOAP_TYPE_ns1__VariableColumn:
		return soap_out_ns1__VariableColumn(soap, tag, id, (const struct ns1__VariableColumn *)ptr, "ns1:VariableColumn");
	case SOAP_TYPE_ns1__ChangedItemType:
		return soap_out_ns1__ChangedItemType(soap, tag, id, (const struct ns1__ChangedItemType *)ptr, "ns1:ChangedItemType");
	case SOAP_TYPE_ns1__ChangedAdgroupIdType:
		return soap_out_ns1__ChangedAdgroupIdType(soap, tag, id, (const struct ns1__ChangedAdgroupIdType *)ptr, "ns1:ChangedAdgroupIdType");
	case SOAP_TYPE_ns1__ChangedCampaignIdType:
		return soap_out_ns1__ChangedCampaignIdType(soap, tag, id, (const struct ns1__ChangedCampaignIdType *)ptr, "ns1:ChangedCampaignIdType");
	case SOAP_TYPE_ns2__OptType:
		return soap_out_ns2__OptType(soap, tag, id, (const struct ns2__OptType *)ptr, "ns2:OptType");
	case SOAP_TYPE_ns1__AccountInfoType:
		return soap_out_ns1__AccountInfoType(soap, tag, id, (const struct ns1__AccountInfoType *)ptr, "ns1:AccountInfoType");
	case SOAP_TYPE_PointerTo_ns1__GetChangedNewCreativeIdResponse:
		return soap_out_PointerTo_ns1__GetChangedNewCreativeIdResponse(soap, tag, id, (struct _ns1__GetChangedNewCreativeIdResponse *const*)ptr, "ns1:GetChangedNewCreativeIdResponse");
	case SOAP_TYPE_PointerTo_ns1__GetChangedNewCreativeIdRequest:
		return soap_out_PointerTo_ns1__GetChangedNewCreativeIdRequest(soap, tag, id, (struct _ns1__GetChangedNewCreativeIdRequest *const*)ptr, "ns1:GetChangedNewCreativeIdRequest");
	case SOAP_TYPE_PointerTo_ns1__getAccountBudgetResponse:
		return soap_out_PointerTo_ns1__getAccountBudgetResponse(soap, tag, id, (struct _ns1__getAccountBudgetResponse *const*)ptr, "ns1:getAccountBudgetResponse");
	case SOAP_TYPE_PointerTo_ns1__getAccountBudgetRequest:
		return soap_out_PointerTo_ns1__getAccountBudgetRequest(soap, tag, id, (struct _ns1__getAccountBudgetRequest *const*)ptr, "ns1:getAccountBudgetRequest");
	case SOAP_TYPE_PointerTo_ns1__updateAccountBudgetResponse:
		return soap_out_PointerTo_ns1__updateAccountBudgetResponse(soap, tag, id, (struct _ns1__updateAccountBudgetResponse *const*)ptr, "ns1:updateAccountBudgetResponse");
	case SOAP_TYPE_PointerTo_ns1__updateAccountBudgetRequest:
		return soap_out_PointerTo_ns1__updateAccountBudgetRequest(soap, tag, id, (struct _ns1__updateAccountBudgetRequest *const*)ptr, "ns1:updateAccountBudgetRequest");
	case SOAP_TYPE_PointerTo_ns1__gettopNKeywordsDataResponse:
		return soap_out_PointerTo_ns1__gettopNKeywordsDataResponse(soap, tag, id, (struct _ns1__gettopNKeywordsDataResponse *const*)ptr, "ns1:gettopNKeywordsDataResponse");
	case SOAP_TYPE_PointerTo_ns1__gettopNKeywordsDataRequest:
		return soap_out_PointerTo_ns1__gettopNKeywordsDataRequest(soap, tag, id, (struct _ns1__gettopNKeywordsDataRequest *const*)ptr, "ns1:gettopNKeywordsDataRequest");
	case SOAP_TYPE_PointerTo_ns1__getAllChangedObjectsPathResponse:
		return soap_out_PointerTo_ns1__getAllChangedObjectsPathResponse(soap, tag, id, (struct _ns1__getAllChangedObjectsPathResponse *const*)ptr, "ns1:getAllChangedObjectsPathResponse");
	case SOAP_TYPE_PointerTo_ns1__getAllChangedObjectsPathRequest:
		return soap_out_PointerTo_ns1__getAllChangedObjectsPathRequest(soap, tag, id, (struct _ns1__getAllChangedObjectsPathRequest *const*)ptr, "ns1:getAllChangedObjectsPathRequest");
	case SOAP_TYPE_PointerTo_ns1__getAllChangedObjectsResponse:
		return soap_out_PointerTo_ns1__getAllChangedObjectsResponse(soap, tag, id, (struct _ns1__getAllChangedObjectsResponse *const*)ptr, "ns1:getAllChangedObjectsResponse");
	case SOAP_TYPE_PointerTo_ns1__getAllChangedObjectsRequest:
		return soap_out_PointerTo_ns1__getAllChangedObjectsRequest(soap, tag, id, (struct _ns1__getAllChangedObjectsRequest *const*)ptr, "ns1:getAllChangedObjectsRequest");
	case SOAP_TYPE_PointerTo_ns1__getSelectedObjectsPathResponse:
		return soap_out_PointerTo_ns1__getSelectedObjectsPathResponse(soap, tag, id, (struct _ns1__getSelectedObjectsPathResponse *const*)ptr, "ns1:getSelectedObjectsPathResponse");
	case SOAP_TYPE_PointerTo_ns1__getSelectedObjectsPathRequest:
		return soap_out_PointerTo_ns1__getSelectedObjectsPathRequest(soap, tag, id, (struct _ns1__getSelectedObjectsPathRequest *const*)ptr, "ns1:getSelectedObjectsPathRequest");
	case SOAP_TYPE_PointerTo_ns1__getAllObjectsPathResponse:
		return soap_out_PointerTo_ns1__getAllObjectsPathResponse(soap, tag, id, (struct _ns1__getAllObjectsPathResponse *const*)ptr, "ns1:getAllObjectsPathResponse");
	case SOAP_TYPE_PointerTo_ns1__getAllObjectsPathRequest:
		return soap_out_PointerTo_ns1__getAllObjectsPathRequest(soap, tag, id, (struct _ns1__getAllObjectsPathRequest *const*)ptr, "ns1:getAllObjectsPathRequest");
	case SOAP_TYPE_PointerTo_ns1__getFileStateResponse:
		return soap_out_PointerTo_ns1__getFileStateResponse(soap, tag, id, (struct _ns1__getFileStateResponse *const*)ptr, "ns1:getFileStateResponse");
	case SOAP_TYPE_PointerTo_ns1__getFileStateRequest:
		return soap_out_PointerTo_ns1__getFileStateRequest(soap, tag, id, (struct _ns1__getFileStateRequest *const*)ptr, "ns1:getFileStateRequest");
	case SOAP_TYPE_PointerTo_ns1__getSelectedObjectsResponse:
		return soap_out_PointerTo_ns1__getSelectedObjectsResponse(soap, tag, id, (struct _ns1__getSelectedObjectsResponse *const*)ptr, "ns1:getSelectedObjectsResponse");
	case SOAP_TYPE_PointerTo_ns1__getSelectedObjectsRequest:
		return soap_out_PointerTo_ns1__getSelectedObjectsRequest(soap, tag, id, (struct _ns1__getSelectedObjectsRequest *const*)ptr, "ns1:getSelectedObjectsRequest");
	case SOAP_TYPE_PointerTo_ns1__getChangedScaleResponse:
		return soap_out_PointerTo_ns1__getChangedScaleResponse(soap, tag, id, (struct _ns1__getChangedScaleResponse *const*)ptr, "ns1:getChangedScaleResponse");
	case SOAP_TYPE_PointerTo_ns1__getChangedScaleRequest:
		return soap_out_PointerTo_ns1__getChangedScaleRequest(soap, tag, id, (struct _ns1__getChangedScaleRequest *const*)ptr, "ns1:getChangedScaleRequest");
	case SOAP_TYPE_PointerTo_ns1__getAllObjectsResponse:
		return soap_out_PointerTo_ns1__getAllObjectsResponse(soap, tag, id, (struct _ns1__getAllObjectsResponse *const*)ptr, "ns1:getAllObjectsResponse");
	case SOAP_TYPE_PointerTo_ns1__getAllObjectsRequest:
		return soap_out_PointerTo_ns1__getAllObjectsRequest(soap, tag, id, (struct _ns1__getAllObjectsRequest *const*)ptr, "ns1:getAllObjectsRequest");
	case SOAP_TYPE_PointerTo_ns1__getChangedIdResponse:
		return soap_out_PointerTo_ns1__getChangedIdResponse(soap, tag, id, (struct _ns1__getChangedIdResponse *const*)ptr, "ns1:getChangedIdResponse");
	case SOAP_TYPE_PointerTo_ns1__getChangedIdRequest:
		return soap_out_PointerTo_ns1__getChangedIdRequest(soap, tag, id, (struct _ns1__getChangedIdRequest *const*)ptr, "ns1:getChangedIdRequest");
	case SOAP_TYPE_PointerTo_ns1__getChangedItemIdResponse:
		return soap_out_PointerTo_ns1__getChangedItemIdResponse(soap, tag, id, (struct _ns1__getChangedItemIdResponse *const*)ptr, "ns1:getChangedItemIdResponse");
	case SOAP_TYPE_PointerTo_ns1__getChangedItemIdRequest:
		return soap_out_PointerTo_ns1__getChangedItemIdRequest(soap, tag, id, (struct _ns1__getChangedItemIdRequest *const*)ptr, "ns1:getChangedItemIdRequest");
	case SOAP_TYPE_PointerTo_ns1__getChangedAdgroupIdResponse:
		return soap_out_PointerTo_ns1__getChangedAdgroupIdResponse(soap, tag, id, (struct _ns1__getChangedAdgroupIdResponse *const*)ptr, "ns1:getChangedAdgroupIdResponse");
	case SOAP_TYPE_PointerTo_ns1__getChangedAdgroupIdRequest:
		return soap_out_PointerTo_ns1__getChangedAdgroupIdRequest(soap, tag, id, (struct _ns1__getChangedAdgroupIdRequest *const*)ptr, "ns1:getChangedAdgroupIdRequest");
	case SOAP_TYPE_PointerTo_ns1__getChangedCampaignIdResponse:
		return soap_out_PointerTo_ns1__getChangedCampaignIdResponse(soap, tag, id, (struct _ns1__getChangedCampaignIdResponse *const*)ptr, "ns1:getChangedCampaignIdResponse");
	case SOAP_TYPE_PointerTo_ns1__getChangedCampaignIdRequest:
		return soap_out_PointerTo_ns1__getChangedCampaignIdRequest(soap, tag, id, (struct _ns1__getChangedCampaignIdRequest *const*)ptr, "ns1:getChangedCampaignIdRequest");
	case SOAP_TYPE_PointerTo_ns1__updateAccountInfoResponse:
		return soap_out_PointerTo_ns1__updateAccountInfoResponse(soap, tag, id, (struct _ns1__updateAccountInfoResponse *const*)ptr, "ns1:updateAccountInfoResponse");
	case SOAP_TYPE_PointerTo_ns1__updateAccountInfoRequest:
		return soap_out_PointerTo_ns1__updateAccountInfoRequest(soap, tag, id, (struct _ns1__updateAccountInfoRequest *const*)ptr, "ns1:updateAccountInfoRequest");
	case SOAP_TYPE_PointerTo_ns1__getAccountInfoResponse:
		return soap_out_PointerTo_ns1__getAccountInfoResponse(soap, tag, id, (struct _ns1__getAccountInfoResponse *const*)ptr, "ns1:getAccountInfoResponse");
	case SOAP_TYPE_PointerTo_ns1__getAccountInfoRequest:
		return soap_out_PointerTo_ns1__getAccountInfoRequest(soap, tag, id, (struct _ns1__getAccountInfoRequest *const*)ptr, "ns1:getAccountInfoRequest");
	case SOAP_TYPE_PointerTons2__ResHeader:
		return soap_out_PointerTons2__ResHeader(soap, tag, id, (struct ns2__ResHeader *const*)ptr, "ns2:ResHeader");
	case SOAP_TYPE_PointerTons2__AuthHeader:
		return soap_out_PointerTons2__AuthHeader(soap, tag, id, (struct ns2__AuthHeader *const*)ptr, "ns2:AuthHeader");
	case SOAP_TYPE_PointerTons2__Failure:
		return soap_out_PointerTons2__Failure(soap, tag, id, (struct ns2__Failure *const*)ptr, "ns2:Failure");
	case SOAP_TYPE_PointerTons2__DoubleMapItemType:
		return soap_out_PointerTons2__DoubleMapItemType(soap, tag, id, (struct ns2__DoubleMapItemType *const*)ptr, "ns2:DoubleMapItemType");
	case SOAP_TYPE_PointerTons2__FloatMapItemType:
		return soap_out_PointerTons2__FloatMapItemType(soap, tag, id, (struct ns2__FloatMapItemType *const*)ptr, "ns2:FloatMapItemType");
	case SOAP_TYPE_PointerTons2__LongMapItemType:
		return soap_out_PointerTons2__LongMapItemType(soap, tag, id, (struct ns2__LongMapItemType *const*)ptr, "ns2:LongMapItemType");
	case SOAP_TYPE_PointerTons2__IntMapItemType:
		return soap_out_PointerTons2__IntMapItemType(soap, tag, id, (struct ns2__IntMapItemType *const*)ptr, "ns2:IntMapItemType");
	case SOAP_TYPE_PointerTons2__StringMapItemType:
		return soap_out_PointerTons2__StringMapItemType(soap, tag, id, (struct ns2__StringMapItemType *const*)ptr, "ns2:StringMapItemType");
	case SOAP_TYPE_PointerTons1__ChangedNewCreativeType:
		return soap_out_PointerTons1__ChangedNewCreativeType(soap, tag, id, (struct ns1__ChangedNewCreativeType *const*)ptr, "ns1:ChangedNewCreativeType");
	case SOAP_TYPE_PointerTons1__TopNkeywordsData:
		return soap_out_PointerTons1__TopNkeywordsData(soap, tag, id, (struct ns1__TopNkeywordsData *const*)ptr, "ns1:TopNkeywordsData");
	case SOAP_TYPE_PointerTons1__ChangedNewCreativeScaleType:
		return soap_out_PointerTons1__ChangedNewCreativeScaleType(soap, tag, id, (struct ns1__ChangedNewCreativeScaleType *const*)ptr, "ns1:ChangedNewCreativeScaleType");
	case SOAP_TYPE_PointerTons1__VariableColumn:
		return soap_out_PointerTons1__VariableColumn(soap, tag, id, (struct ns1__VariableColumn *const*)ptr, "ns1:VariableColumn");
	case SOAP_TYPE_PointerTons1__ChangedItemType:
		return soap_out_PointerTons1__ChangedItemType(soap, tag, id, (struct ns1__ChangedItemType *const*)ptr, "ns1:ChangedItemType");
	case SOAP_TYPE_PointerTons1__ChangedAdgroupIdType:
		return soap_out_PointerTons1__ChangedAdgroupIdType(soap, tag, id, (struct ns1__ChangedAdgroupIdType *const*)ptr, "ns1:ChangedAdgroupIdType");
	case SOAP_TYPE_PointerTons1__ChangedCampaignIdType:
		return soap_out_PointerTons1__ChangedCampaignIdType(soap, tag, id, (struct ns1__ChangedCampaignIdType *const*)ptr, "ns1:ChangedCampaignIdType");
	case SOAP_TYPE_PointerTotime:
		return soap_out_PointerTotime(soap, tag, id, (time_t *const*)ptr, "xsd:dateTime");
	case SOAP_TYPE_PointerToxsd__boolean:
		return soap_out_PointerToxsd__boolean(soap, tag, id, (enum xsd__boolean *const*)ptr, "xsd:boolean");
	case SOAP_TYPE_PointerTons1__AccountInfoType:
		return soap_out_PointerTons1__AccountInfoType(soap, tag, id, (struct ns1__AccountInfoType *const*)ptr, "ns1:AccountInfoType");
	case SOAP_TYPE_PointerTons2__OptType:
		return soap_out_PointerTons2__OptType(soap, tag, id, (struct ns2__OptType *const*)ptr, "ns2:OptType");
	case SOAP_TYPE_PointerTostring:
		return soap_out_PointerTostring(soap, tag, id, (char **const*)ptr, "xsd:string");
	case SOAP_TYPE_PointerToint:
		return soap_out_PointerToint(soap, tag, id, (int *const*)ptr, "xsd:int");
	case SOAP_TYPE_PointerTodouble:
		return soap_out_PointerTodouble(soap, tag, id, (double *const*)ptr, "xsd:double");
	case SOAP_TYPE_PointerToLONG64:
		return soap_out_PointerToLONG64(soap, tag, id, (LONG64 *const*)ptr, "xsd:long");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:QName");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE___ns1__getChangedNewCreativeId:
		soap_serialize___ns1__getChangedNewCreativeId(soap, (const struct __ns1__getChangedNewCreativeId *)ptr);
		break;
	case SOAP_TYPE___ns1__getAccountBudget:
		soap_serialize___ns1__getAccountBudget(soap, (const struct __ns1__getAccountBudget *)ptr);
		break;
	case SOAP_TYPE___ns1__updateAccountBudget:
		soap_serialize___ns1__updateAccountBudget(soap, (const struct __ns1__updateAccountBudget *)ptr);
		break;
	case SOAP_TYPE___ns1__gettopNKeywordsData:
		soap_serialize___ns1__gettopNKeywordsData(soap, (const struct __ns1__gettopNKeywordsData *)ptr);
		break;
	case SOAP_TYPE___ns1__getAllChangedObjectsPath:
		soap_serialize___ns1__getAllChangedObjectsPath(soap, (const struct __ns1__getAllChangedObjectsPath *)ptr);
		break;
	case SOAP_TYPE___ns1__getAllChangedObjects:
		soap_serialize___ns1__getAllChangedObjects(soap, (const struct __ns1__getAllChangedObjects *)ptr);
		break;
	case SOAP_TYPE___ns1__getSelectedObjectsPath:
		soap_serialize___ns1__getSelectedObjectsPath(soap, (const struct __ns1__getSelectedObjectsPath *)ptr);
		break;
	case SOAP_TYPE___ns1__getAllObjectsPath:
		soap_serialize___ns1__getAllObjectsPath(soap, (const struct __ns1__getAllObjectsPath *)ptr);
		break;
	case SOAP_TYPE___ns1__getFileState:
		soap_serialize___ns1__getFileState(soap, (const struct __ns1__getFileState *)ptr);
		break;
	case SOAP_TYPE___ns1__getSelectedObjects:
		soap_serialize___ns1__getSelectedObjects(soap, (const struct __ns1__getSelectedObjects *)ptr);
		break;
	case SOAP_TYPE___ns1__getChangedScale:
		soap_serialize___ns1__getChangedScale(soap, (const struct __ns1__getChangedScale *)ptr);
		break;
	case SOAP_TYPE___ns1__getAllObjects:
		soap_serialize___ns1__getAllObjects(soap, (const struct __ns1__getAllObjects *)ptr);
		break;
	case SOAP_TYPE___ns1__getChangedId:
		soap_serialize___ns1__getChangedId(soap, (const struct __ns1__getChangedId *)ptr);
		break;
	case SOAP_TYPE___ns1__getChangedItemId:
		soap_serialize___ns1__getChangedItemId(soap, (const struct __ns1__getChangedItemId *)ptr);
		break;
	case SOAP_TYPE___ns1__getChangedAdgroupId:
		soap_serialize___ns1__getChangedAdgroupId(soap, (const struct __ns1__getChangedAdgroupId *)ptr);
		break;
	case SOAP_TYPE___ns1__getChangedCampaignId:
		soap_serialize___ns1__getChangedCampaignId(soap, (const struct __ns1__getChangedCampaignId *)ptr);
		break;
	case SOAP_TYPE___ns1__updateAccountInfo:
		soap_serialize___ns1__updateAccountInfo(soap, (const struct __ns1__updateAccountInfo *)ptr);
		break;
	case SOAP_TYPE___ns1__getAccountInfo:
		soap_serialize___ns1__getAccountInfo(soap, (const struct __ns1__getAccountInfo *)ptr);
		break;
	case SOAP_TYPE_ns2__Failure:
		soap_serialize_ns2__Failure(soap, (const struct ns2__Failure *)ptr);
		break;
	case SOAP_TYPE_ns2__ResHeader:
		soap_serialize_ns2__ResHeader(soap, (const struct ns2__ResHeader *)ptr);
		break;
	case SOAP_TYPE_ns2__AuthHeader:
		soap_serialize_ns2__AuthHeader(soap, (const struct ns2__AuthHeader *)ptr);
		break;
	case SOAP_TYPE_ns2__DoubleMapItemType:
		soap_serialize_ns2__DoubleMapItemType(soap, (const struct ns2__DoubleMapItemType *)ptr);
		break;
	case SOAP_TYPE_ns2__FloatMapItemType:
		soap_serialize_ns2__FloatMapItemType(soap, (const struct ns2__FloatMapItemType *)ptr);
		break;
	case SOAP_TYPE_ns2__LongMapItemType:
		soap_serialize_ns2__LongMapItemType(soap, (const struct ns2__LongMapItemType *)ptr);
		break;
	case SOAP_TYPE_ns2__IntMapItemType:
		soap_serialize_ns2__IntMapItemType(soap, (const struct ns2__IntMapItemType *)ptr);
		break;
	case SOAP_TYPE_ns2__StringMapItemType:
		soap_serialize_ns2__StringMapItemType(soap, (const struct ns2__StringMapItemType *)ptr);
		break;
	case SOAP_TYPE__ns1__GetChangedNewCreativeIdResponse:
		soap_serialize__ns1__GetChangedNewCreativeIdResponse(soap, (const struct _ns1__GetChangedNewCreativeIdResponse *)ptr);
		break;
	case SOAP_TYPE__ns1__GetChangedNewCreativeIdRequest:
		soap_serialize__ns1__GetChangedNewCreativeIdRequest(soap, (const struct _ns1__GetChangedNewCreativeIdRequest *)ptr);
		break;
	case SOAP_TYPE__ns1__getAccountBudgetResponse:
		soap_serialize__ns1__getAccountBudgetResponse(soap, (const struct _ns1__getAccountBudgetResponse *)ptr);
		break;
	case SOAP_TYPE__ns1__getAccountBudgetRequest:
		soap_serialize__ns1__getAccountBudgetRequest(soap, (const struct _ns1__getAccountBudgetRequest *)ptr);
		break;
	case SOAP_TYPE__ns1__updateAccountBudgetResponse:
		soap_serialize__ns1__updateAccountBudgetResponse(soap, (const struct _ns1__updateAccountBudgetResponse *)ptr);
		break;
	case SOAP_TYPE__ns1__updateAccountBudgetRequest:
		soap_serialize__ns1__updateAccountBudgetRequest(soap, (const struct _ns1__updateAccountBudgetRequest *)ptr);
		break;
	case SOAP_TYPE__ns1__gettopNKeywordsDataResponse:
		soap_serialize__ns1__gettopNKeywordsDataResponse(soap, (const struct _ns1__gettopNKeywordsDataResponse *)ptr);
		break;
	case SOAP_TYPE__ns1__gettopNKeywordsDataRequest:
		soap_serialize__ns1__gettopNKeywordsDataRequest(soap, (const struct _ns1__gettopNKeywordsDataRequest *)ptr);
		break;
	case SOAP_TYPE__ns1__getAllChangedObjectsPathResponse:
		soap_serialize__ns1__getAllChangedObjectsPathResponse(soap, (const struct _ns1__getAllChangedObjectsPathResponse *)ptr);
		break;
	case SOAP_TYPE__ns1__getAllChangedObjectsPathRequest:
		soap_serialize__ns1__getAllChangedObjectsPathRequest(soap, (const struct _ns1__getAllChangedObjectsPathRequest *)ptr);
		break;
	case SOAP_TYPE__ns1__getAllChangedObjectsResponse:
		soap_serialize__ns1__getAllChangedObjectsResponse(soap, (const struct _ns1__getAllChangedObjectsResponse *)ptr);
		break;
	case SOAP_TYPE__ns1__getAllChangedObjectsRequest:
		soap_serialize__ns1__getAllChangedObjectsRequest(soap, (const struct _ns1__getAllChangedObjectsRequest *)ptr);
		break;
	case SOAP_TYPE__ns1__getSelectedObjectsPathResponse:
		soap_serialize__ns1__getSelectedObjectsPathResponse(soap, (const struct _ns1__getSelectedObjectsPathResponse *)ptr);
		break;
	case SOAP_TYPE__ns1__getSelectedObjectsPathRequest:
		soap_serialize__ns1__getSelectedObjectsPathRequest(soap, (const struct _ns1__getSelectedObjectsPathRequest *)ptr);
		break;
	case SOAP_TYPE__ns1__getAllObjectsPathResponse:
		soap_serialize__ns1__getAllObjectsPathResponse(soap, (const struct _ns1__getAllObjectsPathResponse *)ptr);
		break;
	case SOAP_TYPE__ns1__getAllObjectsPathRequest:
		soap_serialize__ns1__getAllObjectsPathRequest(soap, (const struct _ns1__getAllObjectsPathRequest *)ptr);
		break;
	case SOAP_TYPE__ns1__getFileStateResponse:
		soap_serialize__ns1__getFileStateResponse(soap, (const struct _ns1__getFileStateResponse *)ptr);
		break;
	case SOAP_TYPE__ns1__getFileStateRequest:
		soap_serialize__ns1__getFileStateRequest(soap, (const struct _ns1__getFileStateRequest *)ptr);
		break;
	case SOAP_TYPE__ns1__getSelectedObjectsResponse:
		soap_serialize__ns1__getSelectedObjectsResponse(soap, (const struct _ns1__getSelectedObjectsResponse *)ptr);
		break;
	case SOAP_TYPE__ns1__getSelectedObjectsRequest:
		soap_serialize__ns1__getSelectedObjectsRequest(soap, (const struct _ns1__getSelectedObjectsRequest *)ptr);
		break;
	case SOAP_TYPE__ns1__getChangedScaleResponse:
		soap_serialize__ns1__getChangedScaleResponse(soap, (const struct _ns1__getChangedScaleResponse *)ptr);
		break;
	case SOAP_TYPE__ns1__getChangedScaleRequest:
		soap_serialize__ns1__getChangedScaleRequest(soap, (const struct _ns1__getChangedScaleRequest *)ptr);
		break;
	case SOAP_TYPE__ns1__getAllObjectsResponse:
		soap_serialize__ns1__getAllObjectsResponse(soap, (const struct _ns1__getAllObjectsResponse *)ptr);
		break;
	case SOAP_TYPE__ns1__getAllObjectsRequest:
		soap_serialize__ns1__getAllObjectsRequest(soap, (const struct _ns1__getAllObjectsRequest *)ptr);
		break;
	case SOAP_TYPE__ns1__getChangedIdResponse:
		soap_serialize__ns1__getChangedIdResponse(soap, (const struct _ns1__getChangedIdResponse *)ptr);
		break;
	case SOAP_TYPE__ns1__getChangedIdRequest:
		soap_serialize__ns1__getChangedIdRequest(soap, (const struct _ns1__getChangedIdRequest *)ptr);
		break;
	case SOAP_TYPE__ns1__getChangedItemIdResponse:
		soap_serialize__ns1__getChangedItemIdResponse(soap, (const struct _ns1__getChangedItemIdResponse *)ptr);
		break;
	case SOAP_TYPE__ns1__getChangedItemIdRequest:
		soap_serialize__ns1__getChangedItemIdRequest(soap, (const struct _ns1__getChangedItemIdRequest *)ptr);
		break;
	case SOAP_TYPE__ns1__getChangedAdgroupIdResponse:
		soap_serialize__ns1__getChangedAdgroupIdResponse(soap, (const struct _ns1__getChangedAdgroupIdResponse *)ptr);
		break;
	case SOAP_TYPE__ns1__getChangedAdgroupIdRequest:
		soap_serialize__ns1__getChangedAdgroupIdRequest(soap, (const struct _ns1__getChangedAdgroupIdRequest *)ptr);
		break;
	case SOAP_TYPE__ns1__getChangedCampaignIdResponse:
		soap_serialize__ns1__getChangedCampaignIdResponse(soap, (const struct _ns1__getChangedCampaignIdResponse *)ptr);
		break;
	case SOAP_TYPE__ns1__getChangedCampaignIdRequest:
		soap_serialize__ns1__getChangedCampaignIdRequest(soap, (const struct _ns1__getChangedCampaignIdRequest *)ptr);
		break;
	case SOAP_TYPE__ns1__updateAccountInfoResponse:
		soap_serialize__ns1__updateAccountInfoResponse(soap, (const struct _ns1__updateAccountInfoResponse *)ptr);
		break;
	case SOAP_TYPE__ns1__updateAccountInfoRequest:
		soap_serialize__ns1__updateAccountInfoRequest(soap, (const struct _ns1__updateAccountInfoRequest *)ptr);
		break;
	case SOAP_TYPE__ns1__getAccountInfoResponse:
		soap_serialize__ns1__getAccountInfoResponse(soap, (const struct _ns1__getAccountInfoResponse *)ptr);
		break;
	case SOAP_TYPE__ns1__getAccountInfoRequest:
		soap_serialize__ns1__getAccountInfoRequest(soap, (const struct _ns1__getAccountInfoRequest *)ptr);
		break;
	case SOAP_TYPE_ns1__ChangedNewCreativeScaleType:
		soap_serialize_ns1__ChangedNewCreativeScaleType(soap, (const struct ns1__ChangedNewCreativeScaleType *)ptr);
		break;
	case SOAP_TYPE_ns1__ChangedNewCreativeType:
		soap_serialize_ns1__ChangedNewCreativeType(soap, (const struct ns1__ChangedNewCreativeType *)ptr);
		break;
	case SOAP_TYPE_ns1__TopNkeywordsData:
		soap_serialize_ns1__TopNkeywordsData(soap, (const struct ns1__TopNkeywordsData *)ptr);
		break;
	case SOAP_TYPE_ns1__VariableColumn:
		soap_serialize_ns1__VariableColumn(soap, (const struct ns1__VariableColumn *)ptr);
		break;
	case SOAP_TYPE_ns1__ChangedItemType:
		soap_serialize_ns1__ChangedItemType(soap, (const struct ns1__ChangedItemType *)ptr);
		break;
	case SOAP_TYPE_ns1__ChangedAdgroupIdType:
		soap_serialize_ns1__ChangedAdgroupIdType(soap, (const struct ns1__ChangedAdgroupIdType *)ptr);
		break;
	case SOAP_TYPE_ns1__ChangedCampaignIdType:
		soap_serialize_ns1__ChangedCampaignIdType(soap, (const struct ns1__ChangedCampaignIdType *)ptr);
		break;
	case SOAP_TYPE_ns2__OptType:
		soap_serialize_ns2__OptType(soap, (const struct ns2__OptType *)ptr);
		break;
	case SOAP_TYPE_ns1__AccountInfoType:
		soap_serialize_ns1__AccountInfoType(soap, (const struct ns1__AccountInfoType *)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetChangedNewCreativeIdResponse:
		soap_serialize_PointerTo_ns1__GetChangedNewCreativeIdResponse(soap, (struct _ns1__GetChangedNewCreativeIdResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetChangedNewCreativeIdRequest:
		soap_serialize_PointerTo_ns1__GetChangedNewCreativeIdRequest(soap, (struct _ns1__GetChangedNewCreativeIdRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getAccountBudgetResponse:
		soap_serialize_PointerTo_ns1__getAccountBudgetResponse(soap, (struct _ns1__getAccountBudgetResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getAccountBudgetRequest:
		soap_serialize_PointerTo_ns1__getAccountBudgetRequest(soap, (struct _ns1__getAccountBudgetRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__updateAccountBudgetResponse:
		soap_serialize_PointerTo_ns1__updateAccountBudgetResponse(soap, (struct _ns1__updateAccountBudgetResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__updateAccountBudgetRequest:
		soap_serialize_PointerTo_ns1__updateAccountBudgetRequest(soap, (struct _ns1__updateAccountBudgetRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__gettopNKeywordsDataResponse:
		soap_serialize_PointerTo_ns1__gettopNKeywordsDataResponse(soap, (struct _ns1__gettopNKeywordsDataResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__gettopNKeywordsDataRequest:
		soap_serialize_PointerTo_ns1__gettopNKeywordsDataRequest(soap, (struct _ns1__gettopNKeywordsDataRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getAllChangedObjectsPathResponse:
		soap_serialize_PointerTo_ns1__getAllChangedObjectsPathResponse(soap, (struct _ns1__getAllChangedObjectsPathResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getAllChangedObjectsPathRequest:
		soap_serialize_PointerTo_ns1__getAllChangedObjectsPathRequest(soap, (struct _ns1__getAllChangedObjectsPathRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getAllChangedObjectsResponse:
		soap_serialize_PointerTo_ns1__getAllChangedObjectsResponse(soap, (struct _ns1__getAllChangedObjectsResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getAllChangedObjectsRequest:
		soap_serialize_PointerTo_ns1__getAllChangedObjectsRequest(soap, (struct _ns1__getAllChangedObjectsRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getSelectedObjectsPathResponse:
		soap_serialize_PointerTo_ns1__getSelectedObjectsPathResponse(soap, (struct _ns1__getSelectedObjectsPathResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getSelectedObjectsPathRequest:
		soap_serialize_PointerTo_ns1__getSelectedObjectsPathRequest(soap, (struct _ns1__getSelectedObjectsPathRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getAllObjectsPathResponse:
		soap_serialize_PointerTo_ns1__getAllObjectsPathResponse(soap, (struct _ns1__getAllObjectsPathResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getAllObjectsPathRequest:
		soap_serialize_PointerTo_ns1__getAllObjectsPathRequest(soap, (struct _ns1__getAllObjectsPathRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getFileStateResponse:
		soap_serialize_PointerTo_ns1__getFileStateResponse(soap, (struct _ns1__getFileStateResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getFileStateRequest:
		soap_serialize_PointerTo_ns1__getFileStateRequest(soap, (struct _ns1__getFileStateRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getSelectedObjectsResponse:
		soap_serialize_PointerTo_ns1__getSelectedObjectsResponse(soap, (struct _ns1__getSelectedObjectsResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getSelectedObjectsRequest:
		soap_serialize_PointerTo_ns1__getSelectedObjectsRequest(soap, (struct _ns1__getSelectedObjectsRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getChangedScaleResponse:
		soap_serialize_PointerTo_ns1__getChangedScaleResponse(soap, (struct _ns1__getChangedScaleResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getChangedScaleRequest:
		soap_serialize_PointerTo_ns1__getChangedScaleRequest(soap, (struct _ns1__getChangedScaleRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getAllObjectsResponse:
		soap_serialize_PointerTo_ns1__getAllObjectsResponse(soap, (struct _ns1__getAllObjectsResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getAllObjectsRequest:
		soap_serialize_PointerTo_ns1__getAllObjectsRequest(soap, (struct _ns1__getAllObjectsRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getChangedIdResponse:
		soap_serialize_PointerTo_ns1__getChangedIdResponse(soap, (struct _ns1__getChangedIdResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getChangedIdRequest:
		soap_serialize_PointerTo_ns1__getChangedIdRequest(soap, (struct _ns1__getChangedIdRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getChangedItemIdResponse:
		soap_serialize_PointerTo_ns1__getChangedItemIdResponse(soap, (struct _ns1__getChangedItemIdResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getChangedItemIdRequest:
		soap_serialize_PointerTo_ns1__getChangedItemIdRequest(soap, (struct _ns1__getChangedItemIdRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getChangedAdgroupIdResponse:
		soap_serialize_PointerTo_ns1__getChangedAdgroupIdResponse(soap, (struct _ns1__getChangedAdgroupIdResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getChangedAdgroupIdRequest:
		soap_serialize_PointerTo_ns1__getChangedAdgroupIdRequest(soap, (struct _ns1__getChangedAdgroupIdRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getChangedCampaignIdResponse:
		soap_serialize_PointerTo_ns1__getChangedCampaignIdResponse(soap, (struct _ns1__getChangedCampaignIdResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getChangedCampaignIdRequest:
		soap_serialize_PointerTo_ns1__getChangedCampaignIdRequest(soap, (struct _ns1__getChangedCampaignIdRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__updateAccountInfoResponse:
		soap_serialize_PointerTo_ns1__updateAccountInfoResponse(soap, (struct _ns1__updateAccountInfoResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__updateAccountInfoRequest:
		soap_serialize_PointerTo_ns1__updateAccountInfoRequest(soap, (struct _ns1__updateAccountInfoRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getAccountInfoResponse:
		soap_serialize_PointerTo_ns1__getAccountInfoResponse(soap, (struct _ns1__getAccountInfoResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getAccountInfoRequest:
		soap_serialize_PointerTo_ns1__getAccountInfoRequest(soap, (struct _ns1__getAccountInfoRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ResHeader:
		soap_serialize_PointerTons2__ResHeader(soap, (struct ns2__ResHeader *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__AuthHeader:
		soap_serialize_PointerTons2__AuthHeader(soap, (struct ns2__AuthHeader *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__Failure:
		soap_serialize_PointerTons2__Failure(soap, (struct ns2__Failure *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__DoubleMapItemType:
		soap_serialize_PointerTons2__DoubleMapItemType(soap, (struct ns2__DoubleMapItemType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__FloatMapItemType:
		soap_serialize_PointerTons2__FloatMapItemType(soap, (struct ns2__FloatMapItemType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__LongMapItemType:
		soap_serialize_PointerTons2__LongMapItemType(soap, (struct ns2__LongMapItemType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__IntMapItemType:
		soap_serialize_PointerTons2__IntMapItemType(soap, (struct ns2__IntMapItemType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__StringMapItemType:
		soap_serialize_PointerTons2__StringMapItemType(soap, (struct ns2__StringMapItemType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ChangedNewCreativeType:
		soap_serialize_PointerTons1__ChangedNewCreativeType(soap, (struct ns1__ChangedNewCreativeType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__TopNkeywordsData:
		soap_serialize_PointerTons1__TopNkeywordsData(soap, (struct ns1__TopNkeywordsData *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ChangedNewCreativeScaleType:
		soap_serialize_PointerTons1__ChangedNewCreativeScaleType(soap, (struct ns1__ChangedNewCreativeScaleType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__VariableColumn:
		soap_serialize_PointerTons1__VariableColumn(soap, (struct ns1__VariableColumn *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ChangedItemType:
		soap_serialize_PointerTons1__ChangedItemType(soap, (struct ns1__ChangedItemType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ChangedAdgroupIdType:
		soap_serialize_PointerTons1__ChangedAdgroupIdType(soap, (struct ns1__ChangedAdgroupIdType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ChangedCampaignIdType:
		soap_serialize_PointerTons1__ChangedCampaignIdType(soap, (struct ns1__ChangedCampaignIdType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTotime:
		soap_serialize_PointerTotime(soap, (time_t *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__boolean:
		soap_serialize_PointerToxsd__boolean(soap, (enum xsd__boolean *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__AccountInfoType:
		soap_serialize_PointerTons1__AccountInfoType(soap, (struct ns1__AccountInfoType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__OptType:
		soap_serialize_PointerTons2__OptType(soap, (struct ns2__OptType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTostring:
		soap_serialize_PointerTostring(soap, (char **const*)ptr);
		break;
	case SOAP_TYPE_PointerToint:
		soap_serialize_PointerToint(soap, (int *const*)ptr);
		break;
	case SOAP_TYPE_PointerTodouble:
		soap_serialize_PointerTodouble(soap, (double *const*)ptr);
		break;
	case SOAP_TYPE_PointerToLONG64:
		soap_serialize_PointerToLONG64(soap, (LONG64 *const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	}
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{	char *p;
	p = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_byte);
	if (soap_out_byte(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{	int *p;
	p = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_int);
	if (soap_out_int(soap, tag?tag:"int", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_LONG64(struct soap *soap, LONG64 *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_LONG64
	*a = SOAP_DEFAULT_LONG64;
#else
	*a = (LONG64)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_LONG64(struct soap *soap, const char *tag, int id, const LONG64 *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outLONG64(soap, tag, id, a, type, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_in_LONG64(struct soap *soap, const char *tag, LONG64 *a, const char *type)
{	LONG64 *p;
	p = soap_inLONG64(soap, tag, a, type, SOAP_TYPE_LONG64);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_LONG64(struct soap *soap, const LONG64 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_LONG64);
	if (soap_out_LONG64(soap, tag?tag:"long", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_get_LONG64(struct soap *soap, LONG64 *p, const char *tag, const char *type)
{
	if ((p = soap_in_LONG64(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_float(struct soap *soap, float *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_float
	*a = SOAP_DEFAULT_float;
#else
	*a = (float)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_float(struct soap *soap, const char *tag, int id, const float *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outfloat(soap, tag, id, a, type, SOAP_TYPE_float);
}

SOAP_FMAC3 float * SOAP_FMAC4 soap_in_float(struct soap *soap, const char *tag, float *a, const char *type)
{	float *p;
	p = soap_infloat(soap, tag, a, type, SOAP_TYPE_float);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_float(struct soap *soap, const float *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_float);
	if (soap_out_float(soap, tag?tag:"float", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 float * SOAP_FMAC4 soap_get_float(struct soap *soap, float *p, const char *tag, const char *type)
{
	if ((p = soap_in_float(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_double(struct soap *soap, double *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_double
	*a = SOAP_DEFAULT_double;
#else
	*a = (double)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_double(struct soap *soap, const char *tag, int id, const double *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outdouble(soap, tag, id, a, type, SOAP_TYPE_double);
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_in_double(struct soap *soap, const char *tag, double *a, const char *type)
{	double *p;
	p = soap_indouble(soap, tag, a, type, SOAP_TYPE_double);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_double(struct soap *soap, const double *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_double);
	if (soap_out_double(soap, tag?tag:"double", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_get_double(struct soap *soap, double *p, const char *tag, const char *type)
{
	if ((p = soap_in_double(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_time(struct soap *soap, time_t *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_time
	*a = SOAP_DEFAULT_time;
#else
	*a = (time_t)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_time(struct soap *soap, const char *tag, int id, const time_t *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outdateTime(soap, tag, id, a, type, SOAP_TYPE_time);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_in_time(struct soap *soap, const char *tag, time_t *a, const char *type)
{	time_t *p;
	p = soap_indateTime(soap, tag, a, type, SOAP_TYPE_time);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_time(struct soap *soap, const time_t *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_time);
	if (soap_out_time(soap, tag?tag:"dateTime", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_get_time(struct soap *soap, time_t *p, const char *tag, const char *type)
{
	if ((p = soap_in_time(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__boolean(struct soap *soap, enum xsd__boolean *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_xsd__boolean
	*a = SOAP_DEFAULT_xsd__boolean;
#else
	*a = (enum xsd__boolean)0;
#endif
}

static const struct soap_code_map soap_codes_xsd__boolean[] =
{	{ (long)xsd__boolean__false_, "false" },
	{ (long)xsd__boolean__true_, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_xsd__boolean2s(struct soap *soap, enum xsd__boolean n)
{
	(void)soap; /* appease -Wall -Werror */
return soap_code_str(soap_codes_xsd__boolean, n!=0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__boolean(struct soap *soap, const char *tag, int id, const enum xsd__boolean *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xsd__boolean), type) || soap_send(soap, soap_xsd__boolean2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2xsd__boolean(struct soap *soap, const char *s, enum xsd__boolean *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_xsd__boolean, s);
	if (map)
		*a = (enum xsd__boolean)(map->code != 0);
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (enum xsd__boolean)(n != 0);
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum xsd__boolean * SOAP_FMAC4 soap_in_xsd__boolean(struct soap *soap, const char *tag, enum xsd__boolean *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (enum xsd__boolean *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__boolean, sizeof(enum xsd__boolean), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2xsd__boolean(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum xsd__boolean *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xsd__boolean, 0, sizeof(enum xsd__boolean), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__boolean(struct soap *soap, const enum xsd__boolean *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__boolean);
	if (soap_out_xsd__boolean(soap, tag?tag:"xsd:boolean", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum xsd__boolean * SOAP_FMAC4 soap_get_xsd__boolean(struct soap *soap, enum xsd__boolean *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__boolean(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, &a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, &a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag?tag:"SOAP-ENV:Fault", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang, 1);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Reason);
	if (soap_out_SOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
	a->__type = 0;
	a->fault = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_markelement(soap, a->fault, a->__type);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag_fault = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getChangedNewCreativeId(struct soap *soap, struct __ns1__getChangedNewCreativeId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetChangedNewCreativeIdRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getChangedNewCreativeId(struct soap *soap, const struct __ns1__getChangedNewCreativeId *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetChangedNewCreativeIdRequest(soap, &a->ns1__GetChangedNewCreativeIdRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getChangedNewCreativeId(struct soap *soap, const char *tag, int id, const struct __ns1__getChangedNewCreativeId *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__GetChangedNewCreativeIdRequest(soap, "ns1:GetChangedNewCreativeIdRequest", -1, &a->ns1__GetChangedNewCreativeIdRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getChangedNewCreativeId * SOAP_FMAC4 soap_in___ns1__getChangedNewCreativeId(struct soap *soap, const char *tag, struct __ns1__getChangedNewCreativeId *a, const char *type)
{
	size_t soap_flag_ns1__GetChangedNewCreativeIdRequest = 1;
	short soap_flag;
	a = (struct __ns1__getChangedNewCreativeId *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getChangedNewCreativeId, sizeof(struct __ns1__getChangedNewCreativeId), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getChangedNewCreativeId(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetChangedNewCreativeIdRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetChangedNewCreativeIdRequest(soap, "ns1:GetChangedNewCreativeIdRequest", &a->ns1__GetChangedNewCreativeIdRequest, ""))
				{	soap_flag_ns1__GetChangedNewCreativeIdRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getChangedNewCreativeId(struct soap *soap, const struct __ns1__getChangedNewCreativeId *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getChangedNewCreativeId(soap, tag?tag:"-ns1:getChangedNewCreativeId", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getChangedNewCreativeId * SOAP_FMAC4 soap_get___ns1__getChangedNewCreativeId(struct soap *soap, struct __ns1__getChangedNewCreativeId *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getChangedNewCreativeId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getAccountBudget(struct soap *soap, struct __ns1__getAccountBudget *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getAccountBudgetRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getAccountBudget(struct soap *soap, const struct __ns1__getAccountBudget *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__getAccountBudgetRequest(soap, &a->ns1__getAccountBudgetRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getAccountBudget(struct soap *soap, const char *tag, int id, const struct __ns1__getAccountBudget *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__getAccountBudgetRequest(soap, "ns1:getAccountBudgetRequest", -1, &a->ns1__getAccountBudgetRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getAccountBudget * SOAP_FMAC4 soap_in___ns1__getAccountBudget(struct soap *soap, const char *tag, struct __ns1__getAccountBudget *a, const char *type)
{
	size_t soap_flag_ns1__getAccountBudgetRequest = 1;
	short soap_flag;
	a = (struct __ns1__getAccountBudget *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getAccountBudget, sizeof(struct __ns1__getAccountBudget), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getAccountBudget(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getAccountBudgetRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__getAccountBudgetRequest(soap, "ns1:getAccountBudgetRequest", &a->ns1__getAccountBudgetRequest, ""))
				{	soap_flag_ns1__getAccountBudgetRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getAccountBudget(struct soap *soap, const struct __ns1__getAccountBudget *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getAccountBudget(soap, tag?tag:"-ns1:getAccountBudget", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getAccountBudget * SOAP_FMAC4 soap_get___ns1__getAccountBudget(struct soap *soap, struct __ns1__getAccountBudget *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getAccountBudget(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__updateAccountBudget(struct soap *soap, struct __ns1__updateAccountBudget *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__updateAccountBudgetRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__updateAccountBudget(struct soap *soap, const struct __ns1__updateAccountBudget *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__updateAccountBudgetRequest(soap, &a->ns1__updateAccountBudgetRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__updateAccountBudget(struct soap *soap, const char *tag, int id, const struct __ns1__updateAccountBudget *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__updateAccountBudgetRequest(soap, "ns1:updateAccountBudgetRequest", -1, &a->ns1__updateAccountBudgetRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__updateAccountBudget * SOAP_FMAC4 soap_in___ns1__updateAccountBudget(struct soap *soap, const char *tag, struct __ns1__updateAccountBudget *a, const char *type)
{
	size_t soap_flag_ns1__updateAccountBudgetRequest = 1;
	short soap_flag;
	a = (struct __ns1__updateAccountBudget *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__updateAccountBudget, sizeof(struct __ns1__updateAccountBudget), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__updateAccountBudget(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__updateAccountBudgetRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__updateAccountBudgetRequest(soap, "ns1:updateAccountBudgetRequest", &a->ns1__updateAccountBudgetRequest, ""))
				{	soap_flag_ns1__updateAccountBudgetRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__updateAccountBudget(struct soap *soap, const struct __ns1__updateAccountBudget *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__updateAccountBudget(soap, tag?tag:"-ns1:updateAccountBudget", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__updateAccountBudget * SOAP_FMAC4 soap_get___ns1__updateAccountBudget(struct soap *soap, struct __ns1__updateAccountBudget *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__updateAccountBudget(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__gettopNKeywordsData(struct soap *soap, struct __ns1__gettopNKeywordsData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__gettopNKeywordsDataRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__gettopNKeywordsData(struct soap *soap, const struct __ns1__gettopNKeywordsData *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__gettopNKeywordsDataRequest(soap, &a->ns1__gettopNKeywordsDataRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__gettopNKeywordsData(struct soap *soap, const char *tag, int id, const struct __ns1__gettopNKeywordsData *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__gettopNKeywordsDataRequest(soap, "ns1:gettopNKeywordsDataRequest", -1, &a->ns1__gettopNKeywordsDataRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__gettopNKeywordsData * SOAP_FMAC4 soap_in___ns1__gettopNKeywordsData(struct soap *soap, const char *tag, struct __ns1__gettopNKeywordsData *a, const char *type)
{
	size_t soap_flag_ns1__gettopNKeywordsDataRequest = 1;
	short soap_flag;
	a = (struct __ns1__gettopNKeywordsData *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__gettopNKeywordsData, sizeof(struct __ns1__gettopNKeywordsData), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__gettopNKeywordsData(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__gettopNKeywordsDataRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__gettopNKeywordsDataRequest(soap, "ns1:gettopNKeywordsDataRequest", &a->ns1__gettopNKeywordsDataRequest, ""))
				{	soap_flag_ns1__gettopNKeywordsDataRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__gettopNKeywordsData(struct soap *soap, const struct __ns1__gettopNKeywordsData *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__gettopNKeywordsData(soap, tag?tag:"-ns1:gettopNKeywordsData", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__gettopNKeywordsData * SOAP_FMAC4 soap_get___ns1__gettopNKeywordsData(struct soap *soap, struct __ns1__gettopNKeywordsData *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__gettopNKeywordsData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getAllChangedObjectsPath(struct soap *soap, struct __ns1__getAllChangedObjectsPath *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getAllChangedObjectsPathRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getAllChangedObjectsPath(struct soap *soap, const struct __ns1__getAllChangedObjectsPath *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__getAllChangedObjectsPathRequest(soap, &a->ns1__getAllChangedObjectsPathRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getAllChangedObjectsPath(struct soap *soap, const char *tag, int id, const struct __ns1__getAllChangedObjectsPath *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__getAllChangedObjectsPathRequest(soap, "ns1:getAllChangedObjectsPathRequest", -1, &a->ns1__getAllChangedObjectsPathRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getAllChangedObjectsPath * SOAP_FMAC4 soap_in___ns1__getAllChangedObjectsPath(struct soap *soap, const char *tag, struct __ns1__getAllChangedObjectsPath *a, const char *type)
{
	size_t soap_flag_ns1__getAllChangedObjectsPathRequest = 1;
	short soap_flag;
	a = (struct __ns1__getAllChangedObjectsPath *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getAllChangedObjectsPath, sizeof(struct __ns1__getAllChangedObjectsPath), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getAllChangedObjectsPath(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getAllChangedObjectsPathRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__getAllChangedObjectsPathRequest(soap, "ns1:getAllChangedObjectsPathRequest", &a->ns1__getAllChangedObjectsPathRequest, ""))
				{	soap_flag_ns1__getAllChangedObjectsPathRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getAllChangedObjectsPath(struct soap *soap, const struct __ns1__getAllChangedObjectsPath *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getAllChangedObjectsPath(soap, tag?tag:"-ns1:getAllChangedObjectsPath", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getAllChangedObjectsPath * SOAP_FMAC4 soap_get___ns1__getAllChangedObjectsPath(struct soap *soap, struct __ns1__getAllChangedObjectsPath *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getAllChangedObjectsPath(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getAllChangedObjects(struct soap *soap, struct __ns1__getAllChangedObjects *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getAllChangedObjectsRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getAllChangedObjects(struct soap *soap, const struct __ns1__getAllChangedObjects *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__getAllChangedObjectsRequest(soap, &a->ns1__getAllChangedObjectsRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getAllChangedObjects(struct soap *soap, const char *tag, int id, const struct __ns1__getAllChangedObjects *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__getAllChangedObjectsRequest(soap, "ns1:getAllChangedObjectsRequest", -1, &a->ns1__getAllChangedObjectsRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getAllChangedObjects * SOAP_FMAC4 soap_in___ns1__getAllChangedObjects(struct soap *soap, const char *tag, struct __ns1__getAllChangedObjects *a, const char *type)
{
	size_t soap_flag_ns1__getAllChangedObjectsRequest = 1;
	short soap_flag;
	a = (struct __ns1__getAllChangedObjects *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getAllChangedObjects, sizeof(struct __ns1__getAllChangedObjects), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getAllChangedObjects(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getAllChangedObjectsRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__getAllChangedObjectsRequest(soap, "ns1:getAllChangedObjectsRequest", &a->ns1__getAllChangedObjectsRequest, ""))
				{	soap_flag_ns1__getAllChangedObjectsRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getAllChangedObjects(struct soap *soap, const struct __ns1__getAllChangedObjects *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getAllChangedObjects(soap, tag?tag:"-ns1:getAllChangedObjects", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getAllChangedObjects * SOAP_FMAC4 soap_get___ns1__getAllChangedObjects(struct soap *soap, struct __ns1__getAllChangedObjects *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getAllChangedObjects(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getSelectedObjectsPath(struct soap *soap, struct __ns1__getSelectedObjectsPath *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getSelectedObjectsPathRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getSelectedObjectsPath(struct soap *soap, const struct __ns1__getSelectedObjectsPath *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__getSelectedObjectsPathRequest(soap, &a->ns1__getSelectedObjectsPathRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getSelectedObjectsPath(struct soap *soap, const char *tag, int id, const struct __ns1__getSelectedObjectsPath *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__getSelectedObjectsPathRequest(soap, "ns1:getSelectedObjectsPathRequest", -1, &a->ns1__getSelectedObjectsPathRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getSelectedObjectsPath * SOAP_FMAC4 soap_in___ns1__getSelectedObjectsPath(struct soap *soap, const char *tag, struct __ns1__getSelectedObjectsPath *a, const char *type)
{
	size_t soap_flag_ns1__getSelectedObjectsPathRequest = 1;
	short soap_flag;
	a = (struct __ns1__getSelectedObjectsPath *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getSelectedObjectsPath, sizeof(struct __ns1__getSelectedObjectsPath), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getSelectedObjectsPath(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getSelectedObjectsPathRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__getSelectedObjectsPathRequest(soap, "ns1:getSelectedObjectsPathRequest", &a->ns1__getSelectedObjectsPathRequest, ""))
				{	soap_flag_ns1__getSelectedObjectsPathRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getSelectedObjectsPath(struct soap *soap, const struct __ns1__getSelectedObjectsPath *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getSelectedObjectsPath(soap, tag?tag:"-ns1:getSelectedObjectsPath", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getSelectedObjectsPath * SOAP_FMAC4 soap_get___ns1__getSelectedObjectsPath(struct soap *soap, struct __ns1__getSelectedObjectsPath *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getSelectedObjectsPath(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getAllObjectsPath(struct soap *soap, struct __ns1__getAllObjectsPath *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getAllObjectsPathRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getAllObjectsPath(struct soap *soap, const struct __ns1__getAllObjectsPath *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__getAllObjectsPathRequest(soap, &a->ns1__getAllObjectsPathRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getAllObjectsPath(struct soap *soap, const char *tag, int id, const struct __ns1__getAllObjectsPath *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__getAllObjectsPathRequest(soap, "ns1:getAllObjectsPathRequest", -1, &a->ns1__getAllObjectsPathRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getAllObjectsPath * SOAP_FMAC4 soap_in___ns1__getAllObjectsPath(struct soap *soap, const char *tag, struct __ns1__getAllObjectsPath *a, const char *type)
{
	size_t soap_flag_ns1__getAllObjectsPathRequest = 1;
	short soap_flag;
	a = (struct __ns1__getAllObjectsPath *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getAllObjectsPath, sizeof(struct __ns1__getAllObjectsPath), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getAllObjectsPath(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getAllObjectsPathRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__getAllObjectsPathRequest(soap, "ns1:getAllObjectsPathRequest", &a->ns1__getAllObjectsPathRequest, ""))
				{	soap_flag_ns1__getAllObjectsPathRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getAllObjectsPath(struct soap *soap, const struct __ns1__getAllObjectsPath *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getAllObjectsPath(soap, tag?tag:"-ns1:getAllObjectsPath", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getAllObjectsPath * SOAP_FMAC4 soap_get___ns1__getAllObjectsPath(struct soap *soap, struct __ns1__getAllObjectsPath *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getAllObjectsPath(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getFileState(struct soap *soap, struct __ns1__getFileState *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getFileStateRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getFileState(struct soap *soap, const struct __ns1__getFileState *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__getFileStateRequest(soap, &a->ns1__getFileStateRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getFileState(struct soap *soap, const char *tag, int id, const struct __ns1__getFileState *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__getFileStateRequest(soap, "ns1:getFileStateRequest", -1, &a->ns1__getFileStateRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getFileState * SOAP_FMAC4 soap_in___ns1__getFileState(struct soap *soap, const char *tag, struct __ns1__getFileState *a, const char *type)
{
	size_t soap_flag_ns1__getFileStateRequest = 1;
	short soap_flag;
	a = (struct __ns1__getFileState *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getFileState, sizeof(struct __ns1__getFileState), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getFileState(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getFileStateRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__getFileStateRequest(soap, "ns1:getFileStateRequest", &a->ns1__getFileStateRequest, ""))
				{	soap_flag_ns1__getFileStateRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getFileState(struct soap *soap, const struct __ns1__getFileState *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getFileState(soap, tag?tag:"-ns1:getFileState", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getFileState * SOAP_FMAC4 soap_get___ns1__getFileState(struct soap *soap, struct __ns1__getFileState *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getFileState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getSelectedObjects(struct soap *soap, struct __ns1__getSelectedObjects *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getSelectedObjectsRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getSelectedObjects(struct soap *soap, const struct __ns1__getSelectedObjects *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__getSelectedObjectsRequest(soap, &a->ns1__getSelectedObjectsRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getSelectedObjects(struct soap *soap, const char *tag, int id, const struct __ns1__getSelectedObjects *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__getSelectedObjectsRequest(soap, "ns1:getSelectedObjectsRequest", -1, &a->ns1__getSelectedObjectsRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getSelectedObjects * SOAP_FMAC4 soap_in___ns1__getSelectedObjects(struct soap *soap, const char *tag, struct __ns1__getSelectedObjects *a, const char *type)
{
	size_t soap_flag_ns1__getSelectedObjectsRequest = 1;
	short soap_flag;
	a = (struct __ns1__getSelectedObjects *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getSelectedObjects, sizeof(struct __ns1__getSelectedObjects), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getSelectedObjects(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getSelectedObjectsRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__getSelectedObjectsRequest(soap, "ns1:getSelectedObjectsRequest", &a->ns1__getSelectedObjectsRequest, ""))
				{	soap_flag_ns1__getSelectedObjectsRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getSelectedObjects(struct soap *soap, const struct __ns1__getSelectedObjects *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getSelectedObjects(soap, tag?tag:"-ns1:getSelectedObjects", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getSelectedObjects * SOAP_FMAC4 soap_get___ns1__getSelectedObjects(struct soap *soap, struct __ns1__getSelectedObjects *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getSelectedObjects(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getChangedScale(struct soap *soap, struct __ns1__getChangedScale *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getChangedScaleRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getChangedScale(struct soap *soap, const struct __ns1__getChangedScale *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__getChangedScaleRequest(soap, &a->ns1__getChangedScaleRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getChangedScale(struct soap *soap, const char *tag, int id, const struct __ns1__getChangedScale *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__getChangedScaleRequest(soap, "ns1:getChangedScaleRequest", -1, &a->ns1__getChangedScaleRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getChangedScale * SOAP_FMAC4 soap_in___ns1__getChangedScale(struct soap *soap, const char *tag, struct __ns1__getChangedScale *a, const char *type)
{
	size_t soap_flag_ns1__getChangedScaleRequest = 1;
	short soap_flag;
	a = (struct __ns1__getChangedScale *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getChangedScale, sizeof(struct __ns1__getChangedScale), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getChangedScale(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getChangedScaleRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__getChangedScaleRequest(soap, "ns1:getChangedScaleRequest", &a->ns1__getChangedScaleRequest, ""))
				{	soap_flag_ns1__getChangedScaleRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getChangedScale(struct soap *soap, const struct __ns1__getChangedScale *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getChangedScale(soap, tag?tag:"-ns1:getChangedScale", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getChangedScale * SOAP_FMAC4 soap_get___ns1__getChangedScale(struct soap *soap, struct __ns1__getChangedScale *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getChangedScale(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getAllObjects(struct soap *soap, struct __ns1__getAllObjects *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getAllObjectsRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getAllObjects(struct soap *soap, const struct __ns1__getAllObjects *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__getAllObjectsRequest(soap, &a->ns1__getAllObjectsRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getAllObjects(struct soap *soap, const char *tag, int id, const struct __ns1__getAllObjects *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__getAllObjectsRequest(soap, "ns1:getAllObjectsRequest", -1, &a->ns1__getAllObjectsRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getAllObjects * SOAP_FMAC4 soap_in___ns1__getAllObjects(struct soap *soap, const char *tag, struct __ns1__getAllObjects *a, const char *type)
{
	size_t soap_flag_ns1__getAllObjectsRequest = 1;
	short soap_flag;
	a = (struct __ns1__getAllObjects *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getAllObjects, sizeof(struct __ns1__getAllObjects), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getAllObjects(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getAllObjectsRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__getAllObjectsRequest(soap, "ns1:getAllObjectsRequest", &a->ns1__getAllObjectsRequest, ""))
				{	soap_flag_ns1__getAllObjectsRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getAllObjects(struct soap *soap, const struct __ns1__getAllObjects *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getAllObjects(soap, tag?tag:"-ns1:getAllObjects", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getAllObjects * SOAP_FMAC4 soap_get___ns1__getAllObjects(struct soap *soap, struct __ns1__getAllObjects *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getAllObjects(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getChangedId(struct soap *soap, struct __ns1__getChangedId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getChangedIdRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getChangedId(struct soap *soap, const struct __ns1__getChangedId *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__getChangedIdRequest(soap, &a->ns1__getChangedIdRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getChangedId(struct soap *soap, const char *tag, int id, const struct __ns1__getChangedId *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__getChangedIdRequest(soap, "ns1:getChangedIdRequest", -1, &a->ns1__getChangedIdRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getChangedId * SOAP_FMAC4 soap_in___ns1__getChangedId(struct soap *soap, const char *tag, struct __ns1__getChangedId *a, const char *type)
{
	size_t soap_flag_ns1__getChangedIdRequest = 1;
	short soap_flag;
	a = (struct __ns1__getChangedId *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getChangedId, sizeof(struct __ns1__getChangedId), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getChangedId(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getChangedIdRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__getChangedIdRequest(soap, "ns1:getChangedIdRequest", &a->ns1__getChangedIdRequest, ""))
				{	soap_flag_ns1__getChangedIdRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getChangedId(struct soap *soap, const struct __ns1__getChangedId *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getChangedId(soap, tag?tag:"-ns1:getChangedId", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getChangedId * SOAP_FMAC4 soap_get___ns1__getChangedId(struct soap *soap, struct __ns1__getChangedId *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getChangedId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getChangedItemId(struct soap *soap, struct __ns1__getChangedItemId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getChangedItemIdRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getChangedItemId(struct soap *soap, const struct __ns1__getChangedItemId *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__getChangedItemIdRequest(soap, &a->ns1__getChangedItemIdRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getChangedItemId(struct soap *soap, const char *tag, int id, const struct __ns1__getChangedItemId *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__getChangedItemIdRequest(soap, "ns1:getChangedItemIdRequest", -1, &a->ns1__getChangedItemIdRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getChangedItemId * SOAP_FMAC4 soap_in___ns1__getChangedItemId(struct soap *soap, const char *tag, struct __ns1__getChangedItemId *a, const char *type)
{
	size_t soap_flag_ns1__getChangedItemIdRequest = 1;
	short soap_flag;
	a = (struct __ns1__getChangedItemId *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getChangedItemId, sizeof(struct __ns1__getChangedItemId), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getChangedItemId(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getChangedItemIdRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__getChangedItemIdRequest(soap, "ns1:getChangedItemIdRequest", &a->ns1__getChangedItemIdRequest, ""))
				{	soap_flag_ns1__getChangedItemIdRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getChangedItemId(struct soap *soap, const struct __ns1__getChangedItemId *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getChangedItemId(soap, tag?tag:"-ns1:getChangedItemId", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getChangedItemId * SOAP_FMAC4 soap_get___ns1__getChangedItemId(struct soap *soap, struct __ns1__getChangedItemId *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getChangedItemId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getChangedAdgroupId(struct soap *soap, struct __ns1__getChangedAdgroupId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getChangedAdgroupIdRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getChangedAdgroupId(struct soap *soap, const struct __ns1__getChangedAdgroupId *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__getChangedAdgroupIdRequest(soap, &a->ns1__getChangedAdgroupIdRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getChangedAdgroupId(struct soap *soap, const char *tag, int id, const struct __ns1__getChangedAdgroupId *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__getChangedAdgroupIdRequest(soap, "ns1:getChangedAdgroupIdRequest", -1, &a->ns1__getChangedAdgroupIdRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getChangedAdgroupId * SOAP_FMAC4 soap_in___ns1__getChangedAdgroupId(struct soap *soap, const char *tag, struct __ns1__getChangedAdgroupId *a, const char *type)
{
	size_t soap_flag_ns1__getChangedAdgroupIdRequest = 1;
	short soap_flag;
	a = (struct __ns1__getChangedAdgroupId *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getChangedAdgroupId, sizeof(struct __ns1__getChangedAdgroupId), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getChangedAdgroupId(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getChangedAdgroupIdRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__getChangedAdgroupIdRequest(soap, "ns1:getChangedAdgroupIdRequest", &a->ns1__getChangedAdgroupIdRequest, ""))
				{	soap_flag_ns1__getChangedAdgroupIdRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getChangedAdgroupId(struct soap *soap, const struct __ns1__getChangedAdgroupId *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getChangedAdgroupId(soap, tag?tag:"-ns1:getChangedAdgroupId", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getChangedAdgroupId * SOAP_FMAC4 soap_get___ns1__getChangedAdgroupId(struct soap *soap, struct __ns1__getChangedAdgroupId *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getChangedAdgroupId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getChangedCampaignId(struct soap *soap, struct __ns1__getChangedCampaignId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getChangedCampaignIdRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getChangedCampaignId(struct soap *soap, const struct __ns1__getChangedCampaignId *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__getChangedCampaignIdRequest(soap, &a->ns1__getChangedCampaignIdRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getChangedCampaignId(struct soap *soap, const char *tag, int id, const struct __ns1__getChangedCampaignId *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__getChangedCampaignIdRequest(soap, "ns1:getChangedCampaignIdRequest", -1, &a->ns1__getChangedCampaignIdRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getChangedCampaignId * SOAP_FMAC4 soap_in___ns1__getChangedCampaignId(struct soap *soap, const char *tag, struct __ns1__getChangedCampaignId *a, const char *type)
{
	size_t soap_flag_ns1__getChangedCampaignIdRequest = 1;
	short soap_flag;
	a = (struct __ns1__getChangedCampaignId *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getChangedCampaignId, sizeof(struct __ns1__getChangedCampaignId), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getChangedCampaignId(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getChangedCampaignIdRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__getChangedCampaignIdRequest(soap, "ns1:getChangedCampaignIdRequest", &a->ns1__getChangedCampaignIdRequest, ""))
				{	soap_flag_ns1__getChangedCampaignIdRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getChangedCampaignId(struct soap *soap, const struct __ns1__getChangedCampaignId *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getChangedCampaignId(soap, tag?tag:"-ns1:getChangedCampaignId", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getChangedCampaignId * SOAP_FMAC4 soap_get___ns1__getChangedCampaignId(struct soap *soap, struct __ns1__getChangedCampaignId *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getChangedCampaignId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__updateAccountInfo(struct soap *soap, struct __ns1__updateAccountInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__updateAccountInfoRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__updateAccountInfo(struct soap *soap, const struct __ns1__updateAccountInfo *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__updateAccountInfoRequest(soap, &a->ns1__updateAccountInfoRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__updateAccountInfo(struct soap *soap, const char *tag, int id, const struct __ns1__updateAccountInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__updateAccountInfoRequest(soap, "ns1:updateAccountInfoRequest", -1, &a->ns1__updateAccountInfoRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__updateAccountInfo * SOAP_FMAC4 soap_in___ns1__updateAccountInfo(struct soap *soap, const char *tag, struct __ns1__updateAccountInfo *a, const char *type)
{
	size_t soap_flag_ns1__updateAccountInfoRequest = 1;
	short soap_flag;
	a = (struct __ns1__updateAccountInfo *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__updateAccountInfo, sizeof(struct __ns1__updateAccountInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__updateAccountInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__updateAccountInfoRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__updateAccountInfoRequest(soap, "ns1:updateAccountInfoRequest", &a->ns1__updateAccountInfoRequest, ""))
				{	soap_flag_ns1__updateAccountInfoRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__updateAccountInfo(struct soap *soap, const struct __ns1__updateAccountInfo *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__updateAccountInfo(soap, tag?tag:"-ns1:updateAccountInfo", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__updateAccountInfo * SOAP_FMAC4 soap_get___ns1__updateAccountInfo(struct soap *soap, struct __ns1__updateAccountInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__updateAccountInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getAccountInfo(struct soap *soap, struct __ns1__getAccountInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getAccountInfoRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getAccountInfo(struct soap *soap, const struct __ns1__getAccountInfo *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__getAccountInfoRequest(soap, &a->ns1__getAccountInfoRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getAccountInfo(struct soap *soap, const char *tag, int id, const struct __ns1__getAccountInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__getAccountInfoRequest(soap, "ns1:getAccountInfoRequest", -1, &a->ns1__getAccountInfoRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getAccountInfo * SOAP_FMAC4 soap_in___ns1__getAccountInfo(struct soap *soap, const char *tag, struct __ns1__getAccountInfo *a, const char *type)
{
	size_t soap_flag_ns1__getAccountInfoRequest = 1;
	short soap_flag;
	a = (struct __ns1__getAccountInfo *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getAccountInfo, sizeof(struct __ns1__getAccountInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getAccountInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getAccountInfoRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__getAccountInfoRequest(soap, "ns1:getAccountInfoRequest", &a->ns1__getAccountInfoRequest, ""))
				{	soap_flag_ns1__getAccountInfoRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getAccountInfo(struct soap *soap, const struct __ns1__getAccountInfo *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getAccountInfo(soap, tag?tag:"-ns1:getAccountInfo", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getAccountInfo * SOAP_FMAC4 soap_get___ns1__getAccountInfo(struct soap *soap, struct __ns1__getAccountInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getAccountInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__AuthHeader = NULL;
	a->ns2__ResHeader = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__AuthHeader(soap, &a->ns2__AuthHeader);
	soap_serialize_PointerTons2__ResHeader(soap, &a->ns2__ResHeader);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out_PointerTons2__AuthHeader(soap, "ns2:AuthHeader", -1, &a->ns2__AuthHeader, ""))
		return soap->error;
	if (soap_out_PointerTons2__ResHeader(soap, "ns2:ResHeader", -1, &a->ns2__ResHeader, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	size_t soap_flag_ns2__AuthHeader = 1;
	size_t soap_flag_ns2__ResHeader = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__AuthHeader && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__AuthHeader(soap, "ns2:AuthHeader", &a->ns2__AuthHeader, "ns2:AuthHeader"))
				{	soap_flag_ns2__AuthHeader--;
					continue;
				}
			if (soap_flag_ns2__ResHeader && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ResHeader(soap, "ns2:ResHeader", &a->ns2__ResHeader, "ns2:ResHeader"))
				{	soap_flag_ns2__ResHeader--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag?tag:"SOAP-ENV:Header", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__Failure(struct soap *soap, struct ns2__Failure *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->code);
	soap_default_string(soap, &a->message);
	soap_default_string(soap, &a->position);
	soap_default_string(soap, &a->content);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__Failure(struct soap *soap, const struct ns2__Failure *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->code, SOAP_TYPE_int);
	soap_serialize_string(soap, &a->message);
	soap_serialize_string(soap, &a->position);
	soap_serialize_string(soap, &a->content);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__Failure(struct soap *soap, const char *tag, int id, const struct ns2__Failure *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__Failure), type))
		return soap->error;
	if (soap_out_int(soap, "ns2:code", -1, &a->code, ""))
		return soap->error;
	if (soap_out_string(soap, "ns2:message", -1, &a->message, ""))
		return soap->error;
	if (a->position)
	{	if (soap_out_string(soap, "ns2:position", -1, &a->position, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:position"))
		return soap->error;
	if (soap_out_string(soap, "ns2:content", -1, &a->content, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__Failure * SOAP_FMAC4 soap_in_ns2__Failure(struct soap *soap, const char *tag, struct ns2__Failure *a, const char *type)
{
	size_t soap_flag_code = 1;
	size_t soap_flag_message = 1;
	size_t soap_flag_position = 1;
	size_t soap_flag_content = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__Failure *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__Failure, sizeof(struct ns2__Failure), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__Failure(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns2:code", &a->code, "xsd:int"))
				{	soap_flag_code--;
					continue;
				}
			if (soap_flag_message && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns2:message", &a->message, "xsd:string"))
				{	soap_flag_message--;
					continue;
				}
			if (soap_flag_position && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns2:position", &a->position, "xsd:string"))
				{	soap_flag_position--;
					continue;
				}
			if (soap_flag_content && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns2:content", &a->content, "xsd:string"))
				{	soap_flag_content--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__Failure *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__Failure, 0, sizeof(struct ns2__Failure), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_code > 0 || soap_flag_position > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__Failure(struct soap *soap, const struct ns2__Failure *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__Failure);
	if (soap_out_ns2__Failure(soap, tag?tag:"ns2:Failure", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__Failure * SOAP_FMAC4 soap_get_ns2__Failure(struct soap *soap, struct ns2__Failure *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__Failure(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__ResHeader(struct soap *soap, struct ns2__ResHeader *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->desc);
	a->__sizefailures = 0;
	a->failures = NULL;
	a->oprs = NULL;
	a->oprtime = NULL;
	a->quota = NULL;
	a->rquota = NULL;
	soap_default_int(soap, &a->status);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__ResHeader(struct soap *soap, const struct ns2__ResHeader *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->desc);
	if (a->failures)
	{	int i;
		for (i = 0; i < a->__sizefailures; i++)
		{
			soap_embedded(soap, a->failures + i, SOAP_TYPE_ns2__Failure);
			soap_serialize_ns2__Failure(soap, a->failures + i);
		}
	}
	soap_serialize_PointerToint(soap, &a->oprs);
	soap_serialize_PointerToint(soap, &a->oprtime);
	soap_serialize_PointerToint(soap, &a->quota);
	soap_serialize_PointerToint(soap, &a->rquota);
	soap_embedded(soap, &a->status, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ResHeader(struct soap *soap, const char *tag, int id, const struct ns2__ResHeader *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ResHeader), type))
		return soap->error;
	if (a->desc)
	{	if (soap_out_string(soap, "ns2:desc", -1, &a->desc, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:desc"))
		return soap->error;
	if (a->failures)
	{	int i;
		for (i = 0; i < a->__sizefailures; i++)
			if (soap_out_ns2__Failure(soap, "ns2:failures", -1, a->failures + i, ""))
				return soap->error;
	}
	if (soap_out_PointerToint(soap, "ns2:oprs", -1, &a->oprs, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns2:oprtime", -1, &a->oprtime, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns2:quota", -1, &a->quota, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns2:rquota", -1, &a->rquota, ""))
		return soap->error;
	if (soap_out_int(soap, "ns2:status", -1, &a->status, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__ResHeader * SOAP_FMAC4 soap_in_ns2__ResHeader(struct soap *soap, const char *tag, struct ns2__ResHeader *a, const char *type)
{
	size_t soap_flag_desc = 1;
	struct soap_blist *soap_blist_failures = NULL;
	size_t soap_flag_oprs = 1;
	size_t soap_flag_oprtime = 1;
	size_t soap_flag_quota = 1;
	size_t soap_flag_rquota = 1;
	size_t soap_flag_status = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__ResHeader *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ResHeader, sizeof(struct ns2__ResHeader), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__ResHeader(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_desc && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns2:desc", &a->desc, "xsd:string"))
				{	soap_flag_desc--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns2:failures", 1, NULL))
			{	if (a->failures == NULL)
				{	if (soap_blist_failures == NULL)
						soap_blist_failures = soap_new_block(soap);
					a->failures = (struct ns2__Failure *)soap_push_block(soap, soap_blist_failures, sizeof(struct ns2__Failure));
					if (a->failures == NULL)
						return NULL;
					soap_default_ns2__Failure(soap, a->failures);
				}
				soap_revert(soap);
				if (soap_in_ns2__Failure(soap, "ns2:failures", a->failures, "ns2:Failure"))
				{	a->__sizefailures++;
					a->failures = NULL;
					continue;
				}
			}
			if (soap_flag_oprs && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns2:oprs", &a->oprs, "xsd:int"))
				{	soap_flag_oprs--;
					continue;
				}
			if (soap_flag_oprtime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns2:oprtime", &a->oprtime, "xsd:int"))
				{	soap_flag_oprtime--;
					continue;
				}
			if (soap_flag_quota && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns2:quota", &a->quota, "xsd:int"))
				{	soap_flag_quota--;
					continue;
				}
			if (soap_flag_rquota && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns2:rquota", &a->rquota, "xsd:int"))
				{	soap_flag_rquota--;
					continue;
				}
			if (soap_flag_status && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns2:status", &a->status, "xsd:int"))
				{	soap_flag_status--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->failures)
			soap_pop_block(soap, soap_blist_failures);
		if (a->__sizefailures)
			a->failures = (struct ns2__Failure *)soap_save_block(soap, soap_blist_failures, NULL, 1);
		else
		{	a->failures = NULL;
			if (soap_blist_failures)
				soap_end_block(soap, soap_blist_failures);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__ResHeader *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ResHeader, 0, sizeof(struct ns2__ResHeader), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_desc > 0 || soap_flag_status > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__ResHeader(struct soap *soap, const struct ns2__ResHeader *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__ResHeader);
	if (soap_out_ns2__ResHeader(soap, tag?tag:"ns2:ResHeader", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__ResHeader * SOAP_FMAC4 soap_get_ns2__ResHeader(struct soap *soap, struct ns2__ResHeader *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ResHeader(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__AuthHeader(struct soap *soap, struct ns2__AuthHeader *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->username);
	soap_default_string(soap, &a->password);
	soap_default_string(soap, &a->token);
	soap_default_string(soap, &a->target);
	soap_default_string(soap, &a->accessToken);
	a->account_USCOREtype = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__AuthHeader(struct soap *soap, const struct ns2__AuthHeader *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->username);
	soap_serialize_string(soap, &a->password);
	soap_serialize_string(soap, &a->token);
	soap_serialize_string(soap, &a->target);
	soap_serialize_string(soap, &a->accessToken);
	soap_serialize_PointerToint(soap, &a->account_USCOREtype);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__AuthHeader(struct soap *soap, const char *tag, int id, const struct ns2__AuthHeader *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__AuthHeader), type))
		return soap->error;
	if (soap_out_string(soap, "ns2:username", -1, &a->username, ""))
		return soap->error;
	if (soap_out_string(soap, "ns2:password", -1, &a->password, ""))
		return soap->error;
	if (a->token)
	{	if (soap_out_string(soap, "ns2:token", -1, &a->token, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:token"))
		return soap->error;
	if (soap_out_string(soap, "ns2:target", -1, &a->target, ""))
		return soap->error;
	if (soap_out_string(soap, "ns2:accessToken", -1, &a->accessToken, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns2:account_type", -1, &a->account_USCOREtype, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__AuthHeader * SOAP_FMAC4 soap_in_ns2__AuthHeader(struct soap *soap, const char *tag, struct ns2__AuthHeader *a, const char *type)
{
	size_t soap_flag_username = 1;
	size_t soap_flag_password = 1;
	size_t soap_flag_token = 1;
	size_t soap_flag_target = 1;
	size_t soap_flag_accessToken = 1;
	size_t soap_flag_account_USCOREtype = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__AuthHeader *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__AuthHeader, sizeof(struct ns2__AuthHeader), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__AuthHeader(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_username && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns2:username", &a->username, "xsd:string"))
				{	soap_flag_username--;
					continue;
				}
			if (soap_flag_password && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns2:password", &a->password, "xsd:string"))
				{	soap_flag_password--;
					continue;
				}
			if (soap_flag_token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns2:token", &a->token, "xsd:string"))
				{	soap_flag_token--;
					continue;
				}
			if (soap_flag_target && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns2:target", &a->target, "xsd:string"))
				{	soap_flag_target--;
					continue;
				}
			if (soap_flag_accessToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns2:accessToken", &a->accessToken, "xsd:string"))
				{	soap_flag_accessToken--;
					continue;
				}
			if (soap_flag_account_USCOREtype && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns2:account_type", &a->account_USCOREtype, "xsd:int"))
				{	soap_flag_account_USCOREtype--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__AuthHeader *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__AuthHeader, 0, sizeof(struct ns2__AuthHeader), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_token > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__AuthHeader(struct soap *soap, const struct ns2__AuthHeader *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__AuthHeader);
	if (soap_out_ns2__AuthHeader(soap, tag?tag:"ns2:AuthHeader", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__AuthHeader * SOAP_FMAC4 soap_get_ns2__AuthHeader(struct soap *soap, struct ns2__AuthHeader *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__AuthHeader(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__DoubleMapItemType(struct soap *soap, struct ns2__DoubleMapItemType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->key);
	soap_default_double(soap, &a->value);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__DoubleMapItemType(struct soap *soap, const struct ns2__DoubleMapItemType *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->key);
	soap_embedded(soap, &a->value, SOAP_TYPE_double);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__DoubleMapItemType(struct soap *soap, const char *tag, int id, const struct ns2__DoubleMapItemType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__DoubleMapItemType), type))
		return soap->error;
	if (a->key)
	{	if (soap_out_string(soap, "ns2:key", -1, &a->key, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:key"))
		return soap->error;
	if (soap_out_double(soap, "ns2:value", -1, &a->value, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__DoubleMapItemType * SOAP_FMAC4 soap_in_ns2__DoubleMapItemType(struct soap *soap, const char *tag, struct ns2__DoubleMapItemType *a, const char *type)
{
	size_t soap_flag_key = 1;
	size_t soap_flag_value = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__DoubleMapItemType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__DoubleMapItemType, sizeof(struct ns2__DoubleMapItemType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__DoubleMapItemType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_key && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns2:key", &a->key, "xsd:string"))
				{	soap_flag_key--;
					continue;
				}
			if (soap_flag_value && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "ns2:value", &a->value, "xsd:double"))
				{	soap_flag_value--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__DoubleMapItemType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__DoubleMapItemType, 0, sizeof(struct ns2__DoubleMapItemType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_key > 0 || soap_flag_value > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__DoubleMapItemType(struct soap *soap, const struct ns2__DoubleMapItemType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__DoubleMapItemType);
	if (soap_out_ns2__DoubleMapItemType(soap, tag?tag:"ns2:DoubleMapItemType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__DoubleMapItemType * SOAP_FMAC4 soap_get_ns2__DoubleMapItemType(struct soap *soap, struct ns2__DoubleMapItemType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__DoubleMapItemType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__FloatMapItemType(struct soap *soap, struct ns2__FloatMapItemType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->key);
	soap_default_float(soap, &a->value);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__FloatMapItemType(struct soap *soap, const struct ns2__FloatMapItemType *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->key);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__FloatMapItemType(struct soap *soap, const char *tag, int id, const struct ns2__FloatMapItemType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__FloatMapItemType), type))
		return soap->error;
	if (a->key)
	{	if (soap_out_string(soap, "ns2:key", -1, &a->key, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:key"))
		return soap->error;
	if (soap_out_float(soap, "ns2:value", -1, &a->value, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__FloatMapItemType * SOAP_FMAC4 soap_in_ns2__FloatMapItemType(struct soap *soap, const char *tag, struct ns2__FloatMapItemType *a, const char *type)
{
	size_t soap_flag_key = 1;
	size_t soap_flag_value = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__FloatMapItemType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__FloatMapItemType, sizeof(struct ns2__FloatMapItemType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__FloatMapItemType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_key && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns2:key", &a->key, "xsd:string"))
				{	soap_flag_key--;
					continue;
				}
			if (soap_flag_value && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "ns2:value", &a->value, "xsd:float"))
				{	soap_flag_value--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__FloatMapItemType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__FloatMapItemType, 0, sizeof(struct ns2__FloatMapItemType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_key > 0 || soap_flag_value > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__FloatMapItemType(struct soap *soap, const struct ns2__FloatMapItemType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__FloatMapItemType);
	if (soap_out_ns2__FloatMapItemType(soap, tag?tag:"ns2:FloatMapItemType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__FloatMapItemType * SOAP_FMAC4 soap_get_ns2__FloatMapItemType(struct soap *soap, struct ns2__FloatMapItemType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__FloatMapItemType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__LongMapItemType(struct soap *soap, struct ns2__LongMapItemType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->key);
	soap_default_LONG64(soap, &a->value);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__LongMapItemType(struct soap *soap, const struct ns2__LongMapItemType *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->key);
	soap_embedded(soap, &a->value, SOAP_TYPE_LONG64);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__LongMapItemType(struct soap *soap, const char *tag, int id, const struct ns2__LongMapItemType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__LongMapItemType), type))
		return soap->error;
	if (a->key)
	{	if (soap_out_string(soap, "ns2:key", -1, &a->key, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:key"))
		return soap->error;
	if (soap_out_LONG64(soap, "ns2:value", -1, &a->value, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__LongMapItemType * SOAP_FMAC4 soap_in_ns2__LongMapItemType(struct soap *soap, const char *tag, struct ns2__LongMapItemType *a, const char *type)
{
	size_t soap_flag_key = 1;
	size_t soap_flag_value = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__LongMapItemType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__LongMapItemType, sizeof(struct ns2__LongMapItemType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__LongMapItemType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_key && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns2:key", &a->key, "xsd:string"))
				{	soap_flag_key--;
					continue;
				}
			if (soap_flag_value && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "ns2:value", &a->value, "xsd:long"))
				{	soap_flag_value--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__LongMapItemType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__LongMapItemType, 0, sizeof(struct ns2__LongMapItemType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_key > 0 || soap_flag_value > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__LongMapItemType(struct soap *soap, const struct ns2__LongMapItemType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__LongMapItemType);
	if (soap_out_ns2__LongMapItemType(soap, tag?tag:"ns2:LongMapItemType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__LongMapItemType * SOAP_FMAC4 soap_get_ns2__LongMapItemType(struct soap *soap, struct ns2__LongMapItemType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__LongMapItemType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__IntMapItemType(struct soap *soap, struct ns2__IntMapItemType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->key);
	soap_default_int(soap, &a->value);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__IntMapItemType(struct soap *soap, const struct ns2__IntMapItemType *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->key);
	soap_embedded(soap, &a->value, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__IntMapItemType(struct soap *soap, const char *tag, int id, const struct ns2__IntMapItemType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__IntMapItemType), type))
		return soap->error;
	if (a->key)
	{	if (soap_out_string(soap, "ns2:key", -1, &a->key, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:key"))
		return soap->error;
	if (soap_out_int(soap, "ns2:value", -1, &a->value, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__IntMapItemType * SOAP_FMAC4 soap_in_ns2__IntMapItemType(struct soap *soap, const char *tag, struct ns2__IntMapItemType *a, const char *type)
{
	size_t soap_flag_key = 1;
	size_t soap_flag_value = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__IntMapItemType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__IntMapItemType, sizeof(struct ns2__IntMapItemType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__IntMapItemType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_key && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns2:key", &a->key, "xsd:string"))
				{	soap_flag_key--;
					continue;
				}
			if (soap_flag_value && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns2:value", &a->value, "xsd:int"))
				{	soap_flag_value--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__IntMapItemType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__IntMapItemType, 0, sizeof(struct ns2__IntMapItemType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_key > 0 || soap_flag_value > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__IntMapItemType(struct soap *soap, const struct ns2__IntMapItemType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__IntMapItemType);
	if (soap_out_ns2__IntMapItemType(soap, tag?tag:"ns2:IntMapItemType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__IntMapItemType * SOAP_FMAC4 soap_get_ns2__IntMapItemType(struct soap *soap, struct ns2__IntMapItemType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__IntMapItemType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__StringMapItemType(struct soap *soap, struct ns2__StringMapItemType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->key);
	soap_default_string(soap, &a->value);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__StringMapItemType(struct soap *soap, const struct ns2__StringMapItemType *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->key);
	soap_serialize_string(soap, &a->value);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__StringMapItemType(struct soap *soap, const char *tag, int id, const struct ns2__StringMapItemType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__StringMapItemType), type))
		return soap->error;
	if (a->key)
	{	if (soap_out_string(soap, "ns2:key", -1, &a->key, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:key"))
		return soap->error;
	if (a->value)
	{	if (soap_out_string(soap, "ns2:value", -1, &a->value, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns2:value"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__StringMapItemType * SOAP_FMAC4 soap_in_ns2__StringMapItemType(struct soap *soap, const char *tag, struct ns2__StringMapItemType *a, const char *type)
{
	size_t soap_flag_key = 1;
	size_t soap_flag_value = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__StringMapItemType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__StringMapItemType, sizeof(struct ns2__StringMapItemType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__StringMapItemType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_key && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns2:key", &a->key, "xsd:string"))
				{	soap_flag_key--;
					continue;
				}
			if (soap_flag_value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns2:value", &a->value, "xsd:string"))
				{	soap_flag_value--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__StringMapItemType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__StringMapItemType, 0, sizeof(struct ns2__StringMapItemType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_key > 0 || soap_flag_value > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__StringMapItemType(struct soap *soap, const struct ns2__StringMapItemType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__StringMapItemType);
	if (soap_out_ns2__StringMapItemType(soap, tag?tag:"ns2:StringMapItemType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__StringMapItemType * SOAP_FMAC4 soap_get_ns2__StringMapItemType(struct soap *soap, struct ns2__StringMapItemType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__StringMapItemType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__GetChangedNewCreativeIdResponse(struct soap *soap, struct _ns1__GetChangedNewCreativeIdResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->endTime = NULL;
	a->__sizechangedNewCreativeIds = 0;
	a->changedNewCreativeIds = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__GetChangedNewCreativeIdResponse(struct soap *soap, const struct _ns1__GetChangedNewCreativeIdResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotime(soap, &a->endTime);
	if (a->changedNewCreativeIds)
	{	int i;
		for (i = 0; i < a->__sizechangedNewCreativeIds; i++)
		{
			soap_embedded(soap, a->changedNewCreativeIds + i, SOAP_TYPE_ns1__ChangedNewCreativeType);
			soap_serialize_ns1__ChangedNewCreativeType(soap, a->changedNewCreativeIds + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetChangedNewCreativeIdResponse(struct soap *soap, const char *tag, int id, const struct _ns1__GetChangedNewCreativeIdResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetChangedNewCreativeIdResponse), type))
		return soap->error;
	if (soap_out_PointerTotime(soap, "endTime", -1, &a->endTime, ""))
		return soap->error;
	if (a->changedNewCreativeIds)
	{	int i;
		for (i = 0; i < a->__sizechangedNewCreativeIds; i++)
			if (soap_out_ns1__ChangedNewCreativeType(soap, "changedNewCreativeIds", -1, a->changedNewCreativeIds + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__GetChangedNewCreativeIdResponse * SOAP_FMAC4 soap_in__ns1__GetChangedNewCreativeIdResponse(struct soap *soap, const char *tag, struct _ns1__GetChangedNewCreativeIdResponse *a, const char *type)
{
	size_t soap_flag_endTime = 1;
	struct soap_blist *soap_blist_changedNewCreativeIds = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__GetChangedNewCreativeIdResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetChangedNewCreativeIdResponse, sizeof(struct _ns1__GetChangedNewCreativeIdResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__GetChangedNewCreativeIdResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_endTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "endTime", &a->endTime, "xsd:dateTime"))
				{	soap_flag_endTime--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "changedNewCreativeIds", 1, NULL))
			{	if (a->changedNewCreativeIds == NULL)
				{	if (soap_blist_changedNewCreativeIds == NULL)
						soap_blist_changedNewCreativeIds = soap_new_block(soap);
					a->changedNewCreativeIds = (struct ns1__ChangedNewCreativeType *)soap_push_block(soap, soap_blist_changedNewCreativeIds, sizeof(struct ns1__ChangedNewCreativeType));
					if (a->changedNewCreativeIds == NULL)
						return NULL;
					soap_default_ns1__ChangedNewCreativeType(soap, a->changedNewCreativeIds);
				}
				soap_revert(soap);
				if (soap_in_ns1__ChangedNewCreativeType(soap, "changedNewCreativeIds", a->changedNewCreativeIds, "ns1:ChangedNewCreativeType"))
				{	a->__sizechangedNewCreativeIds++;
					a->changedNewCreativeIds = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->changedNewCreativeIds)
			soap_pop_block(soap, soap_blist_changedNewCreativeIds);
		if (a->__sizechangedNewCreativeIds)
			a->changedNewCreativeIds = (struct ns1__ChangedNewCreativeType *)soap_save_block(soap, soap_blist_changedNewCreativeIds, NULL, 1);
		else
		{	a->changedNewCreativeIds = NULL;
			if (soap_blist_changedNewCreativeIds)
				soap_end_block(soap, soap_blist_changedNewCreativeIds);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__GetChangedNewCreativeIdResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetChangedNewCreativeIdResponse, 0, sizeof(struct _ns1__GetChangedNewCreativeIdResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__GetChangedNewCreativeIdResponse(struct soap *soap, const struct _ns1__GetChangedNewCreativeIdResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__GetChangedNewCreativeIdResponse);
	if (soap_out__ns1__GetChangedNewCreativeIdResponse(soap, tag?tag:"ns1:GetChangedNewCreativeIdResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__GetChangedNewCreativeIdResponse * SOAP_FMAC4 soap_get__ns1__GetChangedNewCreativeIdResponse(struct soap *soap, struct _ns1__GetChangedNewCreativeIdResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetChangedNewCreativeIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__GetChangedNewCreativeIdRequest(struct soap *soap, struct _ns1__GetChangedNewCreativeIdRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_time(soap, &a->startTime);
	a->type = NULL;
	a->__sizeids = 0;
	a->ids = NULL;
	soap_default_int(soap, &a->newCreativeType);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__GetChangedNewCreativeIdRequest(struct soap *soap, const struct _ns1__GetChangedNewCreativeIdRequest *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->startTime, SOAP_TYPE_time);
	soap_serialize_PointerToint(soap, &a->type);
	if (a->ids)
	{	int i;
		for (i = 0; i < a->__sizeids; i++)
		{
			soap_embedded(soap, a->ids + i, SOAP_TYPE_LONG64);
		}
	}
	soap_embedded(soap, &a->newCreativeType, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetChangedNewCreativeIdRequest(struct soap *soap, const char *tag, int id, const struct _ns1__GetChangedNewCreativeIdRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetChangedNewCreativeIdRequest), type))
		return soap->error;
	if (soap_out_time(soap, "startTime", -1, &a->startTime, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "type", -1, &a->type, ""))
		return soap->error;
	if (a->ids)
	{	int i;
		for (i = 0; i < a->__sizeids; i++)
			if (soap_out_LONG64(soap, "ids", -1, a->ids + i, ""))
				return soap->error;
	}
	if (soap_out_int(soap, "newCreativeType", -1, &a->newCreativeType, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__GetChangedNewCreativeIdRequest * SOAP_FMAC4 soap_in__ns1__GetChangedNewCreativeIdRequest(struct soap *soap, const char *tag, struct _ns1__GetChangedNewCreativeIdRequest *a, const char *type)
{
	size_t soap_flag_startTime = 1;
	size_t soap_flag_type = 1;
	struct soap_blist *soap_blist_ids = NULL;
	size_t soap_flag_newCreativeType = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__GetChangedNewCreativeIdRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetChangedNewCreativeIdRequest, sizeof(struct _ns1__GetChangedNewCreativeIdRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__GetChangedNewCreativeIdRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_startTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "startTime", &a->startTime, "xsd:dateTime"))
				{	soap_flag_startTime--;
					continue;
				}
			if (soap_flag_type && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "type", &a->type, "xsd:int"))
				{	soap_flag_type--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ids", 1, NULL))
			{	if (a->ids == NULL)
				{	if (soap_blist_ids == NULL)
						soap_blist_ids = soap_new_block(soap);
					a->ids = (LONG64 *)soap_push_block(soap, soap_blist_ids, sizeof(LONG64));
					if (a->ids == NULL)
						return NULL;
					soap_default_LONG64(soap, a->ids);
				}
				soap_revert(soap);
				if (soap_in_LONG64(soap, "ids", a->ids, "xsd:long"))
				{	a->__sizeids++;
					a->ids = NULL;
					continue;
				}
			}
			if (soap_flag_newCreativeType && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "newCreativeType", &a->newCreativeType, "xsd:int"))
				{	soap_flag_newCreativeType--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ids)
			soap_pop_block(soap, soap_blist_ids);
		if (a->__sizeids)
			a->ids = (LONG64 *)soap_save_block(soap, soap_blist_ids, NULL, 1);
		else
		{	a->ids = NULL;
			if (soap_blist_ids)
				soap_end_block(soap, soap_blist_ids);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__GetChangedNewCreativeIdRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetChangedNewCreativeIdRequest, 0, sizeof(struct _ns1__GetChangedNewCreativeIdRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_startTime > 0 || soap_flag_newCreativeType > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__GetChangedNewCreativeIdRequest(struct soap *soap, const struct _ns1__GetChangedNewCreativeIdRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__GetChangedNewCreativeIdRequest);
	if (soap_out__ns1__GetChangedNewCreativeIdRequest(soap, tag?tag:"ns1:GetChangedNewCreativeIdRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__GetChangedNewCreativeIdRequest * SOAP_FMAC4 soap_get__ns1__GetChangedNewCreativeIdRequest(struct soap *soap, struct _ns1__GetChangedNewCreativeIdRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetChangedNewCreativeIdRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__getAccountBudgetResponse(struct soap *soap, struct _ns1__getAccountBudgetResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->effectiveType);
	soap_default_double(soap, &a->accountBudget);
	a->__sizeweeklyBudget = 0;
	a->weeklyBudget = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__getAccountBudgetResponse(struct soap *soap, const struct _ns1__getAccountBudgetResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->effectiveType, SOAP_TYPE_int);
	soap_embedded(soap, &a->accountBudget, SOAP_TYPE_double);
	if (a->weeklyBudget)
	{	int i;
		for (i = 0; i < a->__sizeweeklyBudget; i++)
		{
			soap_embedded(soap, a->weeklyBudget + i, SOAP_TYPE_double);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getAccountBudgetResponse(struct soap *soap, const char *tag, int id, const struct _ns1__getAccountBudgetResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getAccountBudgetResponse), type))
		return soap->error;
	if (soap_out_int(soap, "effectiveType", -1, &a->effectiveType, ""))
		return soap->error;
	if (soap_out_double(soap, "accountBudget", -1, &a->accountBudget, ""))
		return soap->error;
	if (a->weeklyBudget)
	{	int i;
		for (i = 0; i < a->__sizeweeklyBudget; i++)
			if (soap_out_double(soap, "weeklyBudget", -1, a->weeklyBudget + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__getAccountBudgetResponse * SOAP_FMAC4 soap_in__ns1__getAccountBudgetResponse(struct soap *soap, const char *tag, struct _ns1__getAccountBudgetResponse *a, const char *type)
{
	size_t soap_flag_effectiveType = 1;
	size_t soap_flag_accountBudget = 1;
	struct soap_blist *soap_blist_weeklyBudget = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__getAccountBudgetResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getAccountBudgetResponse, sizeof(struct _ns1__getAccountBudgetResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__getAccountBudgetResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_effectiveType && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "effectiveType", &a->effectiveType, "xsd:int"))
				{	soap_flag_effectiveType--;
					continue;
				}
			if (soap_flag_accountBudget && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "accountBudget", &a->accountBudget, "xsd:double"))
				{	soap_flag_accountBudget--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "weeklyBudget", 1, NULL))
			{	if (a->weeklyBudget == NULL)
				{	if (soap_blist_weeklyBudget == NULL)
						soap_blist_weeklyBudget = soap_new_block(soap);
					a->weeklyBudget = (double *)soap_push_block(soap, soap_blist_weeklyBudget, sizeof(double));
					if (a->weeklyBudget == NULL)
						return NULL;
					soap_default_double(soap, a->weeklyBudget);
				}
				soap_revert(soap);
				if (soap_in_double(soap, "weeklyBudget", a->weeklyBudget, "xsd:double"))
				{	a->__sizeweeklyBudget++;
					a->weeklyBudget = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->weeklyBudget)
			soap_pop_block(soap, soap_blist_weeklyBudget);
		if (a->__sizeweeklyBudget)
			a->weeklyBudget = (double *)soap_save_block(soap, soap_blist_weeklyBudget, NULL, 1);
		else
		{	a->weeklyBudget = NULL;
			if (soap_blist_weeklyBudget)
				soap_end_block(soap, soap_blist_weeklyBudget);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__getAccountBudgetResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getAccountBudgetResponse, 0, sizeof(struct _ns1__getAccountBudgetResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_effectiveType > 0 || soap_flag_accountBudget > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__getAccountBudgetResponse(struct soap *soap, const struct _ns1__getAccountBudgetResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__getAccountBudgetResponse);
	if (soap_out__ns1__getAccountBudgetResponse(soap, tag?tag:"ns1:getAccountBudgetResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getAccountBudgetResponse * SOAP_FMAC4 soap_get__ns1__getAccountBudgetResponse(struct soap *soap, struct _ns1__getAccountBudgetResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getAccountBudgetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__getAccountBudgetRequest(struct soap *soap, struct _ns1__getAccountBudgetRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__getAccountBudgetRequest(struct soap *soap, const struct _ns1__getAccountBudgetRequest *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getAccountBudgetRequest(struct soap *soap, const char *tag, int id, const struct _ns1__getAccountBudgetRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getAccountBudgetRequest), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__getAccountBudgetRequest * SOAP_FMAC4 soap_in__ns1__getAccountBudgetRequest(struct soap *soap, const char *tag, struct _ns1__getAccountBudgetRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__getAccountBudgetRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getAccountBudgetRequest, sizeof(struct _ns1__getAccountBudgetRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__getAccountBudgetRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__getAccountBudgetRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getAccountBudgetRequest, 0, sizeof(struct _ns1__getAccountBudgetRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__getAccountBudgetRequest(struct soap *soap, const struct _ns1__getAccountBudgetRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__getAccountBudgetRequest);
	if (soap_out__ns1__getAccountBudgetRequest(soap, tag?tag:"ns1:getAccountBudgetRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getAccountBudgetRequest * SOAP_FMAC4 soap_get__ns1__getAccountBudgetRequest(struct soap *soap, struct _ns1__getAccountBudgetRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getAccountBudgetRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__updateAccountBudgetResponse(struct soap *soap, struct _ns1__updateAccountBudgetResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->effectiveType);
	soap_default_double(soap, &a->accountBudget);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__updateAccountBudgetResponse(struct soap *soap, const struct _ns1__updateAccountBudgetResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->effectiveType, SOAP_TYPE_int);
	soap_embedded(soap, &a->accountBudget, SOAP_TYPE_double);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__updateAccountBudgetResponse(struct soap *soap, const char *tag, int id, const struct _ns1__updateAccountBudgetResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__updateAccountBudgetResponse), type))
		return soap->error;
	if (soap_out_int(soap, "effectiveType", -1, &a->effectiveType, ""))
		return soap->error;
	if (soap_out_double(soap, "accountBudget", -1, &a->accountBudget, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__updateAccountBudgetResponse * SOAP_FMAC4 soap_in__ns1__updateAccountBudgetResponse(struct soap *soap, const char *tag, struct _ns1__updateAccountBudgetResponse *a, const char *type)
{
	size_t soap_flag_effectiveType = 1;
	size_t soap_flag_accountBudget = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__updateAccountBudgetResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__updateAccountBudgetResponse, sizeof(struct _ns1__updateAccountBudgetResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__updateAccountBudgetResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_effectiveType && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "effectiveType", &a->effectiveType, "xsd:int"))
				{	soap_flag_effectiveType--;
					continue;
				}
			if (soap_flag_accountBudget && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "accountBudget", &a->accountBudget, "xsd:double"))
				{	soap_flag_accountBudget--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__updateAccountBudgetResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__updateAccountBudgetResponse, 0, sizeof(struct _ns1__updateAccountBudgetResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_effectiveType > 0 || soap_flag_accountBudget > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__updateAccountBudgetResponse(struct soap *soap, const struct _ns1__updateAccountBudgetResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__updateAccountBudgetResponse);
	if (soap_out__ns1__updateAccountBudgetResponse(soap, tag?tag:"ns1:updateAccountBudgetResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__updateAccountBudgetResponse * SOAP_FMAC4 soap_get__ns1__updateAccountBudgetResponse(struct soap *soap, struct _ns1__updateAccountBudgetResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__updateAccountBudgetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__updateAccountBudgetRequest(struct soap *soap, struct _ns1__updateAccountBudgetRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->type = NULL;
	soap_default_double(soap, &a->accountBudget);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__updateAccountBudgetRequest(struct soap *soap, const struct _ns1__updateAccountBudgetRequest *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &a->type);
	soap_embedded(soap, &a->accountBudget, SOAP_TYPE_double);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__updateAccountBudgetRequest(struct soap *soap, const char *tag, int id, const struct _ns1__updateAccountBudgetRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__updateAccountBudgetRequest), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "type", -1, &a->type, ""))
		return soap->error;
	if (soap_out_double(soap, "accountBudget", -1, &a->accountBudget, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__updateAccountBudgetRequest * SOAP_FMAC4 soap_in__ns1__updateAccountBudgetRequest(struct soap *soap, const char *tag, struct _ns1__updateAccountBudgetRequest *a, const char *type)
{
	size_t soap_flag_type = 1;
	size_t soap_flag_accountBudget = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__updateAccountBudgetRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__updateAccountBudgetRequest, sizeof(struct _ns1__updateAccountBudgetRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__updateAccountBudgetRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_type && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "type", &a->type, "xsd:int"))
				{	soap_flag_type--;
					continue;
				}
			if (soap_flag_accountBudget && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "accountBudget", &a->accountBudget, "xsd:double"))
				{	soap_flag_accountBudget--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__updateAccountBudgetRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__updateAccountBudgetRequest, 0, sizeof(struct _ns1__updateAccountBudgetRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_accountBudget > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__updateAccountBudgetRequest(struct soap *soap, const struct _ns1__updateAccountBudgetRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__updateAccountBudgetRequest);
	if (soap_out__ns1__updateAccountBudgetRequest(soap, tag?tag:"ns1:updateAccountBudgetRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__updateAccountBudgetRequest * SOAP_FMAC4 soap_get__ns1__updateAccountBudgetRequest(struct soap *soap, struct _ns1__updateAccountBudgetRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__updateAccountBudgetRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__gettopNKeywordsDataResponse(struct soap *soap, struct _ns1__gettopNKeywordsDataResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizetopNkeywordsData = 0;
	a->topNkeywordsData = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__gettopNKeywordsDataResponse(struct soap *soap, const struct _ns1__gettopNKeywordsDataResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->topNkeywordsData)
	{	int i;
		for (i = 0; i < a->__sizetopNkeywordsData; i++)
		{
			soap_embedded(soap, a->topNkeywordsData + i, SOAP_TYPE_ns1__TopNkeywordsData);
			soap_serialize_ns1__TopNkeywordsData(soap, a->topNkeywordsData + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__gettopNKeywordsDataResponse(struct soap *soap, const char *tag, int id, const struct _ns1__gettopNKeywordsDataResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__gettopNKeywordsDataResponse), type))
		return soap->error;
	if (a->topNkeywordsData)
	{	int i;
		for (i = 0; i < a->__sizetopNkeywordsData; i++)
			if (soap_out_ns1__TopNkeywordsData(soap, "topNkeywordsData", -1, a->topNkeywordsData + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__gettopNKeywordsDataResponse * SOAP_FMAC4 soap_in__ns1__gettopNKeywordsDataResponse(struct soap *soap, const char *tag, struct _ns1__gettopNKeywordsDataResponse *a, const char *type)
{
	struct soap_blist *soap_blist_topNkeywordsData = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__gettopNKeywordsDataResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__gettopNKeywordsDataResponse, sizeof(struct _ns1__gettopNKeywordsDataResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__gettopNKeywordsDataResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "topNkeywordsData", 1, NULL))
			{	if (a->topNkeywordsData == NULL)
				{	if (soap_blist_topNkeywordsData == NULL)
						soap_blist_topNkeywordsData = soap_new_block(soap);
					a->topNkeywordsData = (struct ns1__TopNkeywordsData *)soap_push_block(soap, soap_blist_topNkeywordsData, sizeof(struct ns1__TopNkeywordsData));
					if (a->topNkeywordsData == NULL)
						return NULL;
					soap_default_ns1__TopNkeywordsData(soap, a->topNkeywordsData);
				}
				soap_revert(soap);
				if (soap_in_ns1__TopNkeywordsData(soap, "topNkeywordsData", a->topNkeywordsData, "ns1:TopNkeywordsData"))
				{	a->__sizetopNkeywordsData++;
					a->topNkeywordsData = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->topNkeywordsData)
			soap_pop_block(soap, soap_blist_topNkeywordsData);
		if (a->__sizetopNkeywordsData)
			a->topNkeywordsData = (struct ns1__TopNkeywordsData *)soap_save_block(soap, soap_blist_topNkeywordsData, NULL, 1);
		else
		{	a->topNkeywordsData = NULL;
			if (soap_blist_topNkeywordsData)
				soap_end_block(soap, soap_blist_topNkeywordsData);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__gettopNKeywordsDataResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__gettopNKeywordsDataResponse, 0, sizeof(struct _ns1__gettopNKeywordsDataResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__gettopNKeywordsDataResponse(struct soap *soap, const struct _ns1__gettopNKeywordsDataResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__gettopNKeywordsDataResponse);
	if (soap_out__ns1__gettopNKeywordsDataResponse(soap, tag?tag:"ns1:gettopNKeywordsDataResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__gettopNKeywordsDataResponse * SOAP_FMAC4 soap_get__ns1__gettopNKeywordsDataResponse(struct soap *soap, struct _ns1__gettopNKeywordsDataResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__gettopNKeywordsDataResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__gettopNKeywordsDataRequest(struct soap *soap, struct _ns1__gettopNKeywordsDataRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->startRank = NULL;
	a->endRank = NULL;
	a->standardvalue = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__gettopNKeywordsDataRequest(struct soap *soap, const struct _ns1__gettopNKeywordsDataRequest *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &a->startRank);
	soap_serialize_PointerToint(soap, &a->endRank);
	soap_serialize_PointerToint(soap, &a->standardvalue);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__gettopNKeywordsDataRequest(struct soap *soap, const char *tag, int id, const struct _ns1__gettopNKeywordsDataRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__gettopNKeywordsDataRequest), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "startRank", -1, &a->startRank, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "endRank", -1, &a->endRank, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "standardvalue", -1, &a->standardvalue, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__gettopNKeywordsDataRequest * SOAP_FMAC4 soap_in__ns1__gettopNKeywordsDataRequest(struct soap *soap, const char *tag, struct _ns1__gettopNKeywordsDataRequest *a, const char *type)
{
	size_t soap_flag_startRank = 1;
	size_t soap_flag_endRank = 1;
	size_t soap_flag_standardvalue = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__gettopNKeywordsDataRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__gettopNKeywordsDataRequest, sizeof(struct _ns1__gettopNKeywordsDataRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__gettopNKeywordsDataRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_startRank && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "startRank", &a->startRank, "xsd:int"))
				{	soap_flag_startRank--;
					continue;
				}
			if (soap_flag_endRank && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "endRank", &a->endRank, "xsd:int"))
				{	soap_flag_endRank--;
					continue;
				}
			if (soap_flag_standardvalue && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "standardvalue", &a->standardvalue, "xsd:int"))
				{	soap_flag_standardvalue--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__gettopNKeywordsDataRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__gettopNKeywordsDataRequest, 0, sizeof(struct _ns1__gettopNKeywordsDataRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__gettopNKeywordsDataRequest(struct soap *soap, const struct _ns1__gettopNKeywordsDataRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__gettopNKeywordsDataRequest);
	if (soap_out__ns1__gettopNKeywordsDataRequest(soap, tag?tag:"ns1:gettopNKeywordsDataRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__gettopNKeywordsDataRequest * SOAP_FMAC4 soap_get__ns1__gettopNKeywordsDataRequest(struct soap *soap, struct _ns1__gettopNKeywordsDataRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__gettopNKeywordsDataRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__getAllChangedObjectsPathResponse(struct soap *soap, struct _ns1__getAllChangedObjectsPathResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->changedCampaignFilePath);
	soap_default_string(soap, &a->changedCampaignFileMd5);
	soap_default_string(soap, &a->changedAdgroupFilePath);
	soap_default_string(soap, &a->changedAdgroupFileMd5);
	soap_default_string(soap, &a->changedKeywordFilePath);
	soap_default_string(soap, &a->changedKeywordFileMd5);
	soap_default_string(soap, &a->changedCreativeFilePath);
	soap_default_string(soap, &a->changedCreativeFileMd5);
	a->__sizechangedNewCreativeFilePaths = 0;
	a->changedNewCreativeFilePaths = NULL;
	a->__sizechangedNewCreativeFileMd5s = 0;
	a->changedNewCreativeFileMd5s = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__getAllChangedObjectsPathResponse(struct soap *soap, const struct _ns1__getAllChangedObjectsPathResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->changedCampaignFilePath);
	soap_serialize_string(soap, &a->changedCampaignFileMd5);
	soap_serialize_string(soap, &a->changedAdgroupFilePath);
	soap_serialize_string(soap, &a->changedAdgroupFileMd5);
	soap_serialize_string(soap, &a->changedKeywordFilePath);
	soap_serialize_string(soap, &a->changedKeywordFileMd5);
	soap_serialize_string(soap, &a->changedCreativeFilePath);
	soap_serialize_string(soap, &a->changedCreativeFileMd5);
	if (a->changedNewCreativeFilePaths)
	{	int i;
		for (i = 0; i < a->__sizechangedNewCreativeFilePaths; i++)
		{
			soap_serialize_string(soap, a->changedNewCreativeFilePaths + i);
		}
	}
	if (a->changedNewCreativeFileMd5s)
	{	int i;
		for (i = 0; i < a->__sizechangedNewCreativeFileMd5s; i++)
		{
			soap_serialize_string(soap, a->changedNewCreativeFileMd5s + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getAllChangedObjectsPathResponse(struct soap *soap, const char *tag, int id, const struct _ns1__getAllChangedObjectsPathResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getAllChangedObjectsPathResponse), type))
		return soap->error;
	if (soap_out_string(soap, "changedCampaignFilePath", -1, &a->changedCampaignFilePath, ""))
		return soap->error;
	if (soap_out_string(soap, "changedCampaignFileMd5", -1, &a->changedCampaignFileMd5, ""))
		return soap->error;
	if (soap_out_string(soap, "changedAdgroupFilePath", -1, &a->changedAdgroupFilePath, ""))
		return soap->error;
	if (soap_out_string(soap, "changedAdgroupFileMd5", -1, &a->changedAdgroupFileMd5, ""))
		return soap->error;
	if (soap_out_string(soap, "changedKeywordFilePath", -1, &a->changedKeywordFilePath, ""))
		return soap->error;
	if (soap_out_string(soap, "changedKeywordFileMd5", -1, &a->changedKeywordFileMd5, ""))
		return soap->error;
	if (soap_out_string(soap, "changedCreativeFilePath", -1, &a->changedCreativeFilePath, ""))
		return soap->error;
	if (soap_out_string(soap, "changedCreativeFileMd5", -1, &a->changedCreativeFileMd5, ""))
		return soap->error;
	if (a->changedNewCreativeFilePaths)
	{	int i;
		for (i = 0; i < a->__sizechangedNewCreativeFilePaths; i++)
			if (soap_out_string(soap, "changedNewCreativeFilePaths", -1, a->changedNewCreativeFilePaths + i, ""))
				return soap->error;
	}
	if (a->changedNewCreativeFileMd5s)
	{	int i;
		for (i = 0; i < a->__sizechangedNewCreativeFileMd5s; i++)
			if (soap_out_string(soap, "changedNewCreativeFileMd5s", -1, a->changedNewCreativeFileMd5s + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__getAllChangedObjectsPathResponse * SOAP_FMAC4 soap_in__ns1__getAllChangedObjectsPathResponse(struct soap *soap, const char *tag, struct _ns1__getAllChangedObjectsPathResponse *a, const char *type)
{
	size_t soap_flag_changedCampaignFilePath = 1;
	size_t soap_flag_changedCampaignFileMd5 = 1;
	size_t soap_flag_changedAdgroupFilePath = 1;
	size_t soap_flag_changedAdgroupFileMd5 = 1;
	size_t soap_flag_changedKeywordFilePath = 1;
	size_t soap_flag_changedKeywordFileMd5 = 1;
	size_t soap_flag_changedCreativeFilePath = 1;
	size_t soap_flag_changedCreativeFileMd5 = 1;
	struct soap_blist *soap_blist_changedNewCreativeFilePaths = NULL;
	struct soap_blist *soap_blist_changedNewCreativeFileMd5s = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__getAllChangedObjectsPathResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getAllChangedObjectsPathResponse, sizeof(struct _ns1__getAllChangedObjectsPathResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__getAllChangedObjectsPathResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_changedCampaignFilePath && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "changedCampaignFilePath", &a->changedCampaignFilePath, "xsd:string"))
				{	soap_flag_changedCampaignFilePath--;
					continue;
				}
			if (soap_flag_changedCampaignFileMd5 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "changedCampaignFileMd5", &a->changedCampaignFileMd5, "xsd:string"))
				{	soap_flag_changedCampaignFileMd5--;
					continue;
				}
			if (soap_flag_changedAdgroupFilePath && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "changedAdgroupFilePath", &a->changedAdgroupFilePath, "xsd:string"))
				{	soap_flag_changedAdgroupFilePath--;
					continue;
				}
			if (soap_flag_changedAdgroupFileMd5 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "changedAdgroupFileMd5", &a->changedAdgroupFileMd5, "xsd:string"))
				{	soap_flag_changedAdgroupFileMd5--;
					continue;
				}
			if (soap_flag_changedKeywordFilePath && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "changedKeywordFilePath", &a->changedKeywordFilePath, "xsd:string"))
				{	soap_flag_changedKeywordFilePath--;
					continue;
				}
			if (soap_flag_changedKeywordFileMd5 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "changedKeywordFileMd5", &a->changedKeywordFileMd5, "xsd:string"))
				{	soap_flag_changedKeywordFileMd5--;
					continue;
				}
			if (soap_flag_changedCreativeFilePath && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "changedCreativeFilePath", &a->changedCreativeFilePath, "xsd:string"))
				{	soap_flag_changedCreativeFilePath--;
					continue;
				}
			if (soap_flag_changedCreativeFileMd5 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "changedCreativeFileMd5", &a->changedCreativeFileMd5, "xsd:string"))
				{	soap_flag_changedCreativeFileMd5--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "changedNewCreativeFilePaths", 1, NULL))
			{	if (a->changedNewCreativeFilePaths == NULL)
				{	if (soap_blist_changedNewCreativeFilePaths == NULL)
						soap_blist_changedNewCreativeFilePaths = soap_new_block(soap);
					a->changedNewCreativeFilePaths = (char **)soap_push_block(soap, soap_blist_changedNewCreativeFilePaths, sizeof(char *));
					if (a->changedNewCreativeFilePaths == NULL)
						return NULL;
					*a->changedNewCreativeFilePaths = NULL;
				}
				soap_revert(soap);
				if (soap_in_string(soap, "changedNewCreativeFilePaths", a->changedNewCreativeFilePaths, "xsd:string"))
				{	a->__sizechangedNewCreativeFilePaths++;
					a->changedNewCreativeFilePaths = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "changedNewCreativeFileMd5s", 1, NULL))
			{	if (a->changedNewCreativeFileMd5s == NULL)
				{	if (soap_blist_changedNewCreativeFileMd5s == NULL)
						soap_blist_changedNewCreativeFileMd5s = soap_new_block(soap);
					a->changedNewCreativeFileMd5s = (char **)soap_push_block(soap, soap_blist_changedNewCreativeFileMd5s, sizeof(char *));
					if (a->changedNewCreativeFileMd5s == NULL)
						return NULL;
					*a->changedNewCreativeFileMd5s = NULL;
				}
				soap_revert(soap);
				if (soap_in_string(soap, "changedNewCreativeFileMd5s", a->changedNewCreativeFileMd5s, "xsd:string"))
				{	a->__sizechangedNewCreativeFileMd5s++;
					a->changedNewCreativeFileMd5s = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->changedNewCreativeFilePaths)
			soap_pop_block(soap, soap_blist_changedNewCreativeFilePaths);
		if (a->__sizechangedNewCreativeFilePaths)
			a->changedNewCreativeFilePaths = (char **)soap_save_block(soap, soap_blist_changedNewCreativeFilePaths, NULL, 1);
		else
		{	a->changedNewCreativeFilePaths = NULL;
			if (soap_blist_changedNewCreativeFilePaths)
				soap_end_block(soap, soap_blist_changedNewCreativeFilePaths);
		}
		if (a->changedNewCreativeFileMd5s)
			soap_pop_block(soap, soap_blist_changedNewCreativeFileMd5s);
		if (a->__sizechangedNewCreativeFileMd5s)
			a->changedNewCreativeFileMd5s = (char **)soap_save_block(soap, soap_blist_changedNewCreativeFileMd5s, NULL, 1);
		else
		{	a->changedNewCreativeFileMd5s = NULL;
			if (soap_blist_changedNewCreativeFileMd5s)
				soap_end_block(soap, soap_blist_changedNewCreativeFileMd5s);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__getAllChangedObjectsPathResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getAllChangedObjectsPathResponse, 0, sizeof(struct _ns1__getAllChangedObjectsPathResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__getAllChangedObjectsPathResponse(struct soap *soap, const struct _ns1__getAllChangedObjectsPathResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__getAllChangedObjectsPathResponse);
	if (soap_out__ns1__getAllChangedObjectsPathResponse(soap, tag?tag:"ns1:getAllChangedObjectsPathResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getAllChangedObjectsPathResponse * SOAP_FMAC4 soap_get__ns1__getAllChangedObjectsPathResponse(struct soap *soap, struct _ns1__getAllChangedObjectsPathResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getAllChangedObjectsPathResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__getAllChangedObjectsPathRequest(struct soap *soap, struct _ns1__getAllChangedObjectsPathRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->fileId);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__getAllChangedObjectsPathRequest(struct soap *soap, const struct _ns1__getAllChangedObjectsPathRequest *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->fileId);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getAllChangedObjectsPathRequest(struct soap *soap, const char *tag, int id, const struct _ns1__getAllChangedObjectsPathRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getAllChangedObjectsPathRequest), type))
		return soap->error;
	if (a->fileId)
	{	if (soap_out_string(soap, "fileId", -1, &a->fileId, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "fileId"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__getAllChangedObjectsPathRequest * SOAP_FMAC4 soap_in__ns1__getAllChangedObjectsPathRequest(struct soap *soap, const char *tag, struct _ns1__getAllChangedObjectsPathRequest *a, const char *type)
{
	size_t soap_flag_fileId = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__getAllChangedObjectsPathRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getAllChangedObjectsPathRequest, sizeof(struct _ns1__getAllChangedObjectsPathRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__getAllChangedObjectsPathRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fileId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "fileId", &a->fileId, "xsd:string"))
				{	soap_flag_fileId--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__getAllChangedObjectsPathRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getAllChangedObjectsPathRequest, 0, sizeof(struct _ns1__getAllChangedObjectsPathRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_fileId > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__getAllChangedObjectsPathRequest(struct soap *soap, const struct _ns1__getAllChangedObjectsPathRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__getAllChangedObjectsPathRequest);
	if (soap_out__ns1__getAllChangedObjectsPathRequest(soap, tag?tag:"ns1:getAllChangedObjectsPathRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getAllChangedObjectsPathRequest * SOAP_FMAC4 soap_get__ns1__getAllChangedObjectsPathRequest(struct soap *soap, struct _ns1__getAllChangedObjectsPathRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getAllChangedObjectsPathRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__getAllChangedObjectsResponse(struct soap *soap, struct _ns1__getAllChangedObjectsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->fileId);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__getAllChangedObjectsResponse(struct soap *soap, const struct _ns1__getAllChangedObjectsResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->fileId);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getAllChangedObjectsResponse(struct soap *soap, const char *tag, int id, const struct _ns1__getAllChangedObjectsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getAllChangedObjectsResponse), type))
		return soap->error;
	if (soap_out_string(soap, "fileId", -1, &a->fileId, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__getAllChangedObjectsResponse * SOAP_FMAC4 soap_in__ns1__getAllChangedObjectsResponse(struct soap *soap, const char *tag, struct _ns1__getAllChangedObjectsResponse *a, const char *type)
{
	size_t soap_flag_fileId = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__getAllChangedObjectsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getAllChangedObjectsResponse, sizeof(struct _ns1__getAllChangedObjectsResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__getAllChangedObjectsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fileId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "fileId", &a->fileId, "xsd:string"))
				{	soap_flag_fileId--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__getAllChangedObjectsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getAllChangedObjectsResponse, 0, sizeof(struct _ns1__getAllChangedObjectsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__getAllChangedObjectsResponse(struct soap *soap, const struct _ns1__getAllChangedObjectsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__getAllChangedObjectsResponse);
	if (soap_out__ns1__getAllChangedObjectsResponse(soap, tag?tag:"ns1:getAllChangedObjectsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getAllChangedObjectsResponse * SOAP_FMAC4 soap_get__ns1__getAllChangedObjectsResponse(struct soap *soap, struct _ns1__getAllChangedObjectsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getAllChangedObjectsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__getAllChangedObjectsRequest(struct soap *soap, struct _ns1__getAllChangedObjectsRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_time(soap, &a->startTime);
	a->__sizecampaignIds = 0;
	a->campaignIds = NULL;
	a->changedCampaignFile = NULL;
	a->changedAdgroupFile = NULL;
	a->changedKeywordFile = NULL;
	a->changedCreativeFile = NULL;
	a->includeTemp = NULL;
	a->format = NULL;
	a->__sizevariableColumns = 0;
	a->variableColumns = NULL;
	a->changedNewCreativeFiles = NULL;
	a->includeTempChangedNewCreatives = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__getAllChangedObjectsRequest(struct soap *soap, const struct _ns1__getAllChangedObjectsRequest *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->startTime, SOAP_TYPE_time);
	if (a->campaignIds)
	{	int i;
		for (i = 0; i < a->__sizecampaignIds; i++)
		{
			soap_embedded(soap, a->campaignIds + i, SOAP_TYPE_LONG64);
		}
	}
	soap_serialize_PointerToxsd__boolean(soap, &a->changedCampaignFile);
	soap_serialize_PointerToxsd__boolean(soap, &a->changedAdgroupFile);
	soap_serialize_PointerToxsd__boolean(soap, &a->changedKeywordFile);
	soap_serialize_PointerToxsd__boolean(soap, &a->changedCreativeFile);
	soap_serialize_PointerToxsd__boolean(soap, &a->includeTemp);
	soap_serialize_PointerToint(soap, &a->format);
	if (a->variableColumns)
	{	int i;
		for (i = 0; i < a->__sizevariableColumns; i++)
		{
			soap_embedded(soap, a->variableColumns + i, SOAP_TYPE_ns1__VariableColumn);
			soap_serialize_ns1__VariableColumn(soap, a->variableColumns + i);
		}
	}
	soap_serialize_PointerToint(soap, &a->changedNewCreativeFiles);
	soap_serialize_PointerToint(soap, &a->includeTempChangedNewCreatives);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getAllChangedObjectsRequest(struct soap *soap, const char *tag, int id, const struct _ns1__getAllChangedObjectsRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getAllChangedObjectsRequest), type))
		return soap->error;
	if (soap_out_time(soap, "startTime", -1, &a->startTime, ""))
		return soap->error;
	if (a->campaignIds)
	{	int i;
		for (i = 0; i < a->__sizecampaignIds; i++)
			if (soap_out_LONG64(soap, "campaignIds", -1, a->campaignIds + i, ""))
				return soap->error;
	}
	if (soap_out_PointerToxsd__boolean(soap, "changedCampaignFile", -1, &a->changedCampaignFile, ""))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "changedAdgroupFile", -1, &a->changedAdgroupFile, ""))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "changedKeywordFile", -1, &a->changedKeywordFile, ""))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "changedCreativeFile", -1, &a->changedCreativeFile, ""))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "includeTemp", -1, &a->includeTemp, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "format", -1, &a->format, ""))
		return soap->error;
	if (a->variableColumns)
	{	int i;
		for (i = 0; i < a->__sizevariableColumns; i++)
			if (soap_out_ns1__VariableColumn(soap, "variableColumns", -1, a->variableColumns + i, ""))
				return soap->error;
	}
	if (soap_out_PointerToint(soap, "changedNewCreativeFiles", -1, &a->changedNewCreativeFiles, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "includeTempChangedNewCreatives", -1, &a->includeTempChangedNewCreatives, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__getAllChangedObjectsRequest * SOAP_FMAC4 soap_in__ns1__getAllChangedObjectsRequest(struct soap *soap, const char *tag, struct _ns1__getAllChangedObjectsRequest *a, const char *type)
{
	size_t soap_flag_startTime = 1;
	struct soap_blist *soap_blist_campaignIds = NULL;
	size_t soap_flag_changedCampaignFile = 1;
	size_t soap_flag_changedAdgroupFile = 1;
	size_t soap_flag_changedKeywordFile = 1;
	size_t soap_flag_changedCreativeFile = 1;
	size_t soap_flag_includeTemp = 1;
	size_t soap_flag_format = 1;
	struct soap_blist *soap_blist_variableColumns = NULL;
	size_t soap_flag_changedNewCreativeFiles = 1;
	size_t soap_flag_includeTempChangedNewCreatives = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__getAllChangedObjectsRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getAllChangedObjectsRequest, sizeof(struct _ns1__getAllChangedObjectsRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__getAllChangedObjectsRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_startTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "startTime", &a->startTime, "xsd:dateTime"))
				{	soap_flag_startTime--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "campaignIds", 1, NULL))
			{	if (a->campaignIds == NULL)
				{	if (soap_blist_campaignIds == NULL)
						soap_blist_campaignIds = soap_new_block(soap);
					a->campaignIds = (LONG64 *)soap_push_block(soap, soap_blist_campaignIds, sizeof(LONG64));
					if (a->campaignIds == NULL)
						return NULL;
					soap_default_LONG64(soap, a->campaignIds);
				}
				soap_revert(soap);
				if (soap_in_LONG64(soap, "campaignIds", a->campaignIds, "xsd:long"))
				{	a->__sizecampaignIds++;
					a->campaignIds = NULL;
					continue;
				}
			}
			if (soap_flag_changedCampaignFile && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "changedCampaignFile", &a->changedCampaignFile, "xsd:boolean"))
				{	soap_flag_changedCampaignFile--;
					continue;
				}
			if (soap_flag_changedAdgroupFile && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "changedAdgroupFile", &a->changedAdgroupFile, "xsd:boolean"))
				{	soap_flag_changedAdgroupFile--;
					continue;
				}
			if (soap_flag_changedKeywordFile && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "changedKeywordFile", &a->changedKeywordFile, "xsd:boolean"))
				{	soap_flag_changedKeywordFile--;
					continue;
				}
			if (soap_flag_changedCreativeFile && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "changedCreativeFile", &a->changedCreativeFile, "xsd:boolean"))
				{	soap_flag_changedCreativeFile--;
					continue;
				}
			if (soap_flag_includeTemp && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "includeTemp", &a->includeTemp, "xsd:boolean"))
				{	soap_flag_includeTemp--;
					continue;
				}
			if (soap_flag_format && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "format", &a->format, "xsd:int"))
				{	soap_flag_format--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "variableColumns", 1, NULL))
			{	if (a->variableColumns == NULL)
				{	if (soap_blist_variableColumns == NULL)
						soap_blist_variableColumns = soap_new_block(soap);
					a->variableColumns = (struct ns1__VariableColumn *)soap_push_block(soap, soap_blist_variableColumns, sizeof(struct ns1__VariableColumn));
					if (a->variableColumns == NULL)
						return NULL;
					soap_default_ns1__VariableColumn(soap, a->variableColumns);
				}
				soap_revert(soap);
				if (soap_in_ns1__VariableColumn(soap, "variableColumns", a->variableColumns, "ns1:VariableColumn"))
				{	a->__sizevariableColumns++;
					a->variableColumns = NULL;
					continue;
				}
			}
			if (soap_flag_changedNewCreativeFiles && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "changedNewCreativeFiles", &a->changedNewCreativeFiles, "xsd:int"))
				{	soap_flag_changedNewCreativeFiles--;
					continue;
				}
			if (soap_flag_includeTempChangedNewCreatives && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "includeTempChangedNewCreatives", &a->includeTempChangedNewCreatives, "xsd:int"))
				{	soap_flag_includeTempChangedNewCreatives--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->campaignIds)
			soap_pop_block(soap, soap_blist_campaignIds);
		if (a->__sizecampaignIds)
			a->campaignIds = (LONG64 *)soap_save_block(soap, soap_blist_campaignIds, NULL, 1);
		else
		{	a->campaignIds = NULL;
			if (soap_blist_campaignIds)
				soap_end_block(soap, soap_blist_campaignIds);
		}
		if (a->variableColumns)
			soap_pop_block(soap, soap_blist_variableColumns);
		if (a->__sizevariableColumns)
			a->variableColumns = (struct ns1__VariableColumn *)soap_save_block(soap, soap_blist_variableColumns, NULL, 1);
		else
		{	a->variableColumns = NULL;
			if (soap_blist_variableColumns)
				soap_end_block(soap, soap_blist_variableColumns);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__getAllChangedObjectsRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getAllChangedObjectsRequest, 0, sizeof(struct _ns1__getAllChangedObjectsRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_startTime > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__getAllChangedObjectsRequest(struct soap *soap, const struct _ns1__getAllChangedObjectsRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__getAllChangedObjectsRequest);
	if (soap_out__ns1__getAllChangedObjectsRequest(soap, tag?tag:"ns1:getAllChangedObjectsRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getAllChangedObjectsRequest * SOAP_FMAC4 soap_get__ns1__getAllChangedObjectsRequest(struct soap *soap, struct _ns1__getAllChangedObjectsRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getAllChangedObjectsRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__getSelectedObjectsPathResponse(struct soap *soap, struct _ns1__getSelectedObjectsPathResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->campaignSelectedFilePath);
	soap_default_string(soap, &a->campaignSelectedFileMd5);
	soap_default_string(soap, &a->adgroupSelectedFilePath);
	soap_default_string(soap, &a->adgroupSelectedFileMd5);
	soap_default_string(soap, &a->keywordSelectedFilePath);
	soap_default_string(soap, &a->keywordSelectedFileMd5);
	soap_default_string(soap, &a->creativeSelectedFilePath);
	soap_default_string(soap, &a->creativeSelectedFileMd5);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__getSelectedObjectsPathResponse(struct soap *soap, const struct _ns1__getSelectedObjectsPathResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->campaignSelectedFilePath);
	soap_serialize_string(soap, &a->campaignSelectedFileMd5);
	soap_serialize_string(soap, &a->adgroupSelectedFilePath);
	soap_serialize_string(soap, &a->adgroupSelectedFileMd5);
	soap_serialize_string(soap, &a->keywordSelectedFilePath);
	soap_serialize_string(soap, &a->keywordSelectedFileMd5);
	soap_serialize_string(soap, &a->creativeSelectedFilePath);
	soap_serialize_string(soap, &a->creativeSelectedFileMd5);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getSelectedObjectsPathResponse(struct soap *soap, const char *tag, int id, const struct _ns1__getSelectedObjectsPathResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getSelectedObjectsPathResponse), type))
		return soap->error;
	if (soap_out_string(soap, "campaignSelectedFilePath", -1, &a->campaignSelectedFilePath, ""))
		return soap->error;
	if (soap_out_string(soap, "campaignSelectedFileMd5", -1, &a->campaignSelectedFileMd5, ""))
		return soap->error;
	if (soap_out_string(soap, "adgroupSelectedFilePath", -1, &a->adgroupSelectedFilePath, ""))
		return soap->error;
	if (soap_out_string(soap, "adgroupSelectedFileMd5", -1, &a->adgroupSelectedFileMd5, ""))
		return soap->error;
	if (soap_out_string(soap, "keywordSelectedFilePath", -1, &a->keywordSelectedFilePath, ""))
		return soap->error;
	if (soap_out_string(soap, "keywordSelectedFileMd5", -1, &a->keywordSelectedFileMd5, ""))
		return soap->error;
	if (soap_out_string(soap, "creativeSelectedFilePath", -1, &a->creativeSelectedFilePath, ""))
		return soap->error;
	if (soap_out_string(soap, "creativeSelectedFileMd5", -1, &a->creativeSelectedFileMd5, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__getSelectedObjectsPathResponse * SOAP_FMAC4 soap_in__ns1__getSelectedObjectsPathResponse(struct soap *soap, const char *tag, struct _ns1__getSelectedObjectsPathResponse *a, const char *type)
{
	size_t soap_flag_campaignSelectedFilePath = 1;
	size_t soap_flag_campaignSelectedFileMd5 = 1;
	size_t soap_flag_adgroupSelectedFilePath = 1;
	size_t soap_flag_adgroupSelectedFileMd5 = 1;
	size_t soap_flag_keywordSelectedFilePath = 1;
	size_t soap_flag_keywordSelectedFileMd5 = 1;
	size_t soap_flag_creativeSelectedFilePath = 1;
	size_t soap_flag_creativeSelectedFileMd5 = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__getSelectedObjectsPathResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getSelectedObjectsPathResponse, sizeof(struct _ns1__getSelectedObjectsPathResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__getSelectedObjectsPathResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_campaignSelectedFilePath && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "campaignSelectedFilePath", &a->campaignSelectedFilePath, "xsd:string"))
				{	soap_flag_campaignSelectedFilePath--;
					continue;
				}
			if (soap_flag_campaignSelectedFileMd5 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "campaignSelectedFileMd5", &a->campaignSelectedFileMd5, "xsd:string"))
				{	soap_flag_campaignSelectedFileMd5--;
					continue;
				}
			if (soap_flag_adgroupSelectedFilePath && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "adgroupSelectedFilePath", &a->adgroupSelectedFilePath, "xsd:string"))
				{	soap_flag_adgroupSelectedFilePath--;
					continue;
				}
			if (soap_flag_adgroupSelectedFileMd5 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "adgroupSelectedFileMd5", &a->adgroupSelectedFileMd5, "xsd:string"))
				{	soap_flag_adgroupSelectedFileMd5--;
					continue;
				}
			if (soap_flag_keywordSelectedFilePath && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "keywordSelectedFilePath", &a->keywordSelectedFilePath, "xsd:string"))
				{	soap_flag_keywordSelectedFilePath--;
					continue;
				}
			if (soap_flag_keywordSelectedFileMd5 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "keywordSelectedFileMd5", &a->keywordSelectedFileMd5, "xsd:string"))
				{	soap_flag_keywordSelectedFileMd5--;
					continue;
				}
			if (soap_flag_creativeSelectedFilePath && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "creativeSelectedFilePath", &a->creativeSelectedFilePath, "xsd:string"))
				{	soap_flag_creativeSelectedFilePath--;
					continue;
				}
			if (soap_flag_creativeSelectedFileMd5 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "creativeSelectedFileMd5", &a->creativeSelectedFileMd5, "xsd:string"))
				{	soap_flag_creativeSelectedFileMd5--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__getSelectedObjectsPathResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getSelectedObjectsPathResponse, 0, sizeof(struct _ns1__getSelectedObjectsPathResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__getSelectedObjectsPathResponse(struct soap *soap, const struct _ns1__getSelectedObjectsPathResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__getSelectedObjectsPathResponse);
	if (soap_out__ns1__getSelectedObjectsPathResponse(soap, tag?tag:"ns1:getSelectedObjectsPathResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getSelectedObjectsPathResponse * SOAP_FMAC4 soap_get__ns1__getSelectedObjectsPathResponse(struct soap *soap, struct _ns1__getSelectedObjectsPathResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getSelectedObjectsPathResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__getSelectedObjectsPathRequest(struct soap *soap, struct _ns1__getSelectedObjectsPathRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->fileId);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__getSelectedObjectsPathRequest(struct soap *soap, const struct _ns1__getSelectedObjectsPathRequest *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->fileId);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getSelectedObjectsPathRequest(struct soap *soap, const char *tag, int id, const struct _ns1__getSelectedObjectsPathRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getSelectedObjectsPathRequest), type))
		return soap->error;
	if (a->fileId)
	{	if (soap_out_string(soap, "fileId", -1, &a->fileId, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "fileId"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__getSelectedObjectsPathRequest * SOAP_FMAC4 soap_in__ns1__getSelectedObjectsPathRequest(struct soap *soap, const char *tag, struct _ns1__getSelectedObjectsPathRequest *a, const char *type)
{
	size_t soap_flag_fileId = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__getSelectedObjectsPathRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getSelectedObjectsPathRequest, sizeof(struct _ns1__getSelectedObjectsPathRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__getSelectedObjectsPathRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fileId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "fileId", &a->fileId, "xsd:string"))
				{	soap_flag_fileId--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__getSelectedObjectsPathRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getSelectedObjectsPathRequest, 0, sizeof(struct _ns1__getSelectedObjectsPathRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_fileId > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__getSelectedObjectsPathRequest(struct soap *soap, const struct _ns1__getSelectedObjectsPathRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__getSelectedObjectsPathRequest);
	if (soap_out__ns1__getSelectedObjectsPathRequest(soap, tag?tag:"ns1:getSelectedObjectsPathRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getSelectedObjectsPathRequest * SOAP_FMAC4 soap_get__ns1__getSelectedObjectsPathRequest(struct soap *soap, struct _ns1__getSelectedObjectsPathRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getSelectedObjectsPathRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__getAllObjectsPathResponse(struct soap *soap, struct _ns1__getAllObjectsPathResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->accountFilePath);
	soap_default_string(soap, &a->accountFileMd5);
	soap_default_string(soap, &a->campaignFilePath);
	soap_default_string(soap, &a->campaignFileMd5);
	soap_default_string(soap, &a->adgroupFilePath);
	soap_default_string(soap, &a->adgroupFileMd5);
	soap_default_string(soap, &a->keywordFilePath);
	soap_default_string(soap, &a->keywordFileMd5);
	soap_default_string(soap, &a->creativeFilePath);
	soap_default_string(soap, &a->creativeFileMd5);
	a->__sizenewCreativeFilePaths = 0;
	a->newCreativeFilePaths = NULL;
	a->__sizenewCreativeFileMd5s = 0;
	a->newCreativeFileMd5s = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__getAllObjectsPathResponse(struct soap *soap, const struct _ns1__getAllObjectsPathResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->accountFilePath);
	soap_serialize_string(soap, &a->accountFileMd5);
	soap_serialize_string(soap, &a->campaignFilePath);
	soap_serialize_string(soap, &a->campaignFileMd5);
	soap_serialize_string(soap, &a->adgroupFilePath);
	soap_serialize_string(soap, &a->adgroupFileMd5);
	soap_serialize_string(soap, &a->keywordFilePath);
	soap_serialize_string(soap, &a->keywordFileMd5);
	soap_serialize_string(soap, &a->creativeFilePath);
	soap_serialize_string(soap, &a->creativeFileMd5);
	if (a->newCreativeFilePaths)
	{	int i;
		for (i = 0; i < a->__sizenewCreativeFilePaths; i++)
		{
			soap_serialize_string(soap, a->newCreativeFilePaths + i);
		}
	}
	if (a->newCreativeFileMd5s)
	{	int i;
		for (i = 0; i < a->__sizenewCreativeFileMd5s; i++)
		{
			soap_serialize_string(soap, a->newCreativeFileMd5s + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getAllObjectsPathResponse(struct soap *soap, const char *tag, int id, const struct _ns1__getAllObjectsPathResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getAllObjectsPathResponse), type))
		return soap->error;
	if (soap_out_string(soap, "accountFilePath", -1, &a->accountFilePath, ""))
		return soap->error;
	if (soap_out_string(soap, "accountFileMd5", -1, &a->accountFileMd5, ""))
		return soap->error;
	if (soap_out_string(soap, "campaignFilePath", -1, &a->campaignFilePath, ""))
		return soap->error;
	if (soap_out_string(soap, "campaignFileMd5", -1, &a->campaignFileMd5, ""))
		return soap->error;
	if (soap_out_string(soap, "adgroupFilePath", -1, &a->adgroupFilePath, ""))
		return soap->error;
	if (soap_out_string(soap, "adgroupFileMd5", -1, &a->adgroupFileMd5, ""))
		return soap->error;
	if (soap_out_string(soap, "keywordFilePath", -1, &a->keywordFilePath, ""))
		return soap->error;
	if (soap_out_string(soap, "keywordFileMd5", -1, &a->keywordFileMd5, ""))
		return soap->error;
	if (soap_out_string(soap, "creativeFilePath", -1, &a->creativeFilePath, ""))
		return soap->error;
	if (soap_out_string(soap, "creativeFileMd5", -1, &a->creativeFileMd5, ""))
		return soap->error;
	if (a->newCreativeFilePaths)
	{	int i;
		for (i = 0; i < a->__sizenewCreativeFilePaths; i++)
			if (soap_out_string(soap, "newCreativeFilePaths", -1, a->newCreativeFilePaths + i, ""))
				return soap->error;
	}
	if (a->newCreativeFileMd5s)
	{	int i;
		for (i = 0; i < a->__sizenewCreativeFileMd5s; i++)
			if (soap_out_string(soap, "newCreativeFileMd5s", -1, a->newCreativeFileMd5s + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__getAllObjectsPathResponse * SOAP_FMAC4 soap_in__ns1__getAllObjectsPathResponse(struct soap *soap, const char *tag, struct _ns1__getAllObjectsPathResponse *a, const char *type)
{
	size_t soap_flag_accountFilePath = 1;
	size_t soap_flag_accountFileMd5 = 1;
	size_t soap_flag_campaignFilePath = 1;
	size_t soap_flag_campaignFileMd5 = 1;
	size_t soap_flag_adgroupFilePath = 1;
	size_t soap_flag_adgroupFileMd5 = 1;
	size_t soap_flag_keywordFilePath = 1;
	size_t soap_flag_keywordFileMd5 = 1;
	size_t soap_flag_creativeFilePath = 1;
	size_t soap_flag_creativeFileMd5 = 1;
	struct soap_blist *soap_blist_newCreativeFilePaths = NULL;
	struct soap_blist *soap_blist_newCreativeFileMd5s = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__getAllObjectsPathResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getAllObjectsPathResponse, sizeof(struct _ns1__getAllObjectsPathResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__getAllObjectsPathResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_accountFilePath && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "accountFilePath", &a->accountFilePath, "xsd:string"))
				{	soap_flag_accountFilePath--;
					continue;
				}
			if (soap_flag_accountFileMd5 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "accountFileMd5", &a->accountFileMd5, "xsd:string"))
				{	soap_flag_accountFileMd5--;
					continue;
				}
			if (soap_flag_campaignFilePath && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "campaignFilePath", &a->campaignFilePath, "xsd:string"))
				{	soap_flag_campaignFilePath--;
					continue;
				}
			if (soap_flag_campaignFileMd5 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "campaignFileMd5", &a->campaignFileMd5, "xsd:string"))
				{	soap_flag_campaignFileMd5--;
					continue;
				}
			if (soap_flag_adgroupFilePath && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "adgroupFilePath", &a->adgroupFilePath, "xsd:string"))
				{	soap_flag_adgroupFilePath--;
					continue;
				}
			if (soap_flag_adgroupFileMd5 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "adgroupFileMd5", &a->adgroupFileMd5, "xsd:string"))
				{	soap_flag_adgroupFileMd5--;
					continue;
				}
			if (soap_flag_keywordFilePath && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "keywordFilePath", &a->keywordFilePath, "xsd:string"))
				{	soap_flag_keywordFilePath--;
					continue;
				}
			if (soap_flag_keywordFileMd5 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "keywordFileMd5", &a->keywordFileMd5, "xsd:string"))
				{	soap_flag_keywordFileMd5--;
					continue;
				}
			if (soap_flag_creativeFilePath && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "creativeFilePath", &a->creativeFilePath, "xsd:string"))
				{	soap_flag_creativeFilePath--;
					continue;
				}
			if (soap_flag_creativeFileMd5 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "creativeFileMd5", &a->creativeFileMd5, "xsd:string"))
				{	soap_flag_creativeFileMd5--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "newCreativeFilePaths", 1, NULL))
			{	if (a->newCreativeFilePaths == NULL)
				{	if (soap_blist_newCreativeFilePaths == NULL)
						soap_blist_newCreativeFilePaths = soap_new_block(soap);
					a->newCreativeFilePaths = (char **)soap_push_block(soap, soap_blist_newCreativeFilePaths, sizeof(char *));
					if (a->newCreativeFilePaths == NULL)
						return NULL;
					*a->newCreativeFilePaths = NULL;
				}
				soap_revert(soap);
				if (soap_in_string(soap, "newCreativeFilePaths", a->newCreativeFilePaths, "xsd:string"))
				{	a->__sizenewCreativeFilePaths++;
					a->newCreativeFilePaths = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "newCreativeFileMd5s", 1, NULL))
			{	if (a->newCreativeFileMd5s == NULL)
				{	if (soap_blist_newCreativeFileMd5s == NULL)
						soap_blist_newCreativeFileMd5s = soap_new_block(soap);
					a->newCreativeFileMd5s = (char **)soap_push_block(soap, soap_blist_newCreativeFileMd5s, sizeof(char *));
					if (a->newCreativeFileMd5s == NULL)
						return NULL;
					*a->newCreativeFileMd5s = NULL;
				}
				soap_revert(soap);
				if (soap_in_string(soap, "newCreativeFileMd5s", a->newCreativeFileMd5s, "xsd:string"))
				{	a->__sizenewCreativeFileMd5s++;
					a->newCreativeFileMd5s = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->newCreativeFilePaths)
			soap_pop_block(soap, soap_blist_newCreativeFilePaths);
		if (a->__sizenewCreativeFilePaths)
			a->newCreativeFilePaths = (char **)soap_save_block(soap, soap_blist_newCreativeFilePaths, NULL, 1);
		else
		{	a->newCreativeFilePaths = NULL;
			if (soap_blist_newCreativeFilePaths)
				soap_end_block(soap, soap_blist_newCreativeFilePaths);
		}
		if (a->newCreativeFileMd5s)
			soap_pop_block(soap, soap_blist_newCreativeFileMd5s);
		if (a->__sizenewCreativeFileMd5s)
			a->newCreativeFileMd5s = (char **)soap_save_block(soap, soap_blist_newCreativeFileMd5s, NULL, 1);
		else
		{	a->newCreativeFileMd5s = NULL;
			if (soap_blist_newCreativeFileMd5s)
				soap_end_block(soap, soap_blist_newCreativeFileMd5s);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__getAllObjectsPathResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getAllObjectsPathResponse, 0, sizeof(struct _ns1__getAllObjectsPathResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__getAllObjectsPathResponse(struct soap *soap, const struct _ns1__getAllObjectsPathResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__getAllObjectsPathResponse);
	if (soap_out__ns1__getAllObjectsPathResponse(soap, tag?tag:"ns1:getAllObjectsPathResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getAllObjectsPathResponse * SOAP_FMAC4 soap_get__ns1__getAllObjectsPathResponse(struct soap *soap, struct _ns1__getAllObjectsPathResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getAllObjectsPathResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__getAllObjectsPathRequest(struct soap *soap, struct _ns1__getAllObjectsPathRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->fileId);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__getAllObjectsPathRequest(struct soap *soap, const struct _ns1__getAllObjectsPathRequest *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->fileId);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getAllObjectsPathRequest(struct soap *soap, const char *tag, int id, const struct _ns1__getAllObjectsPathRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getAllObjectsPathRequest), type))
		return soap->error;
	if (a->fileId)
	{	if (soap_out_string(soap, "fileId", -1, &a->fileId, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "fileId"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__getAllObjectsPathRequest * SOAP_FMAC4 soap_in__ns1__getAllObjectsPathRequest(struct soap *soap, const char *tag, struct _ns1__getAllObjectsPathRequest *a, const char *type)
{
	size_t soap_flag_fileId = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__getAllObjectsPathRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getAllObjectsPathRequest, sizeof(struct _ns1__getAllObjectsPathRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__getAllObjectsPathRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fileId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "fileId", &a->fileId, "xsd:string"))
				{	soap_flag_fileId--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__getAllObjectsPathRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getAllObjectsPathRequest, 0, sizeof(struct _ns1__getAllObjectsPathRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_fileId > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__getAllObjectsPathRequest(struct soap *soap, const struct _ns1__getAllObjectsPathRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__getAllObjectsPathRequest);
	if (soap_out__ns1__getAllObjectsPathRequest(soap, tag?tag:"ns1:getAllObjectsPathRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getAllObjectsPathRequest * SOAP_FMAC4 soap_get__ns1__getAllObjectsPathRequest(struct soap *soap, struct _ns1__getAllObjectsPathRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getAllObjectsPathRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__getFileStateResponse(struct soap *soap, struct _ns1__getFileStateResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->isGenerated = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__getFileStateResponse(struct soap *soap, const struct _ns1__getFileStateResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &a->isGenerated);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getFileStateResponse(struct soap *soap, const char *tag, int id, const struct _ns1__getFileStateResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getFileStateResponse), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "isGenerated", -1, &a->isGenerated, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__getFileStateResponse * SOAP_FMAC4 soap_in__ns1__getFileStateResponse(struct soap *soap, const char *tag, struct _ns1__getFileStateResponse *a, const char *type)
{
	size_t soap_flag_isGenerated = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__getFileStateResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getFileStateResponse, sizeof(struct _ns1__getFileStateResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__getFileStateResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_isGenerated && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "isGenerated", &a->isGenerated, "xsd:int"))
				{	soap_flag_isGenerated--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__getFileStateResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getFileStateResponse, 0, sizeof(struct _ns1__getFileStateResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__getFileStateResponse(struct soap *soap, const struct _ns1__getFileStateResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__getFileStateResponse);
	if (soap_out__ns1__getFileStateResponse(soap, tag?tag:"ns1:getFileStateResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getFileStateResponse * SOAP_FMAC4 soap_get__ns1__getFileStateResponse(struct soap *soap, struct _ns1__getFileStateResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getFileStateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__getFileStateRequest(struct soap *soap, struct _ns1__getFileStateRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->fileId);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__getFileStateRequest(struct soap *soap, const struct _ns1__getFileStateRequest *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->fileId);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getFileStateRequest(struct soap *soap, const char *tag, int id, const struct _ns1__getFileStateRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getFileStateRequest), type))
		return soap->error;
	if (a->fileId)
	{	if (soap_out_string(soap, "fileId", -1, &a->fileId, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "fileId"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__getFileStateRequest * SOAP_FMAC4 soap_in__ns1__getFileStateRequest(struct soap *soap, const char *tag, struct _ns1__getFileStateRequest *a, const char *type)
{
	size_t soap_flag_fileId = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__getFileStateRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getFileStateRequest, sizeof(struct _ns1__getFileStateRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__getFileStateRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fileId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "fileId", &a->fileId, "xsd:string"))
				{	soap_flag_fileId--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__getFileStateRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getFileStateRequest, 0, sizeof(struct _ns1__getFileStateRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_fileId > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__getFileStateRequest(struct soap *soap, const struct _ns1__getFileStateRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__getFileStateRequest);
	if (soap_out__ns1__getFileStateRequest(soap, tag?tag:"ns1:getFileStateRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getFileStateRequest * SOAP_FMAC4 soap_get__ns1__getFileStateRequest(struct soap *soap, struct _ns1__getFileStateRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getFileStateRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__getSelectedObjectsResponse(struct soap *soap, struct _ns1__getSelectedObjectsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->fileId);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__getSelectedObjectsResponse(struct soap *soap, const struct _ns1__getSelectedObjectsResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->fileId);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getSelectedObjectsResponse(struct soap *soap, const char *tag, int id, const struct _ns1__getSelectedObjectsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getSelectedObjectsResponse), type))
		return soap->error;
	if (soap_out_string(soap, "fileId", -1, &a->fileId, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__getSelectedObjectsResponse * SOAP_FMAC4 soap_in__ns1__getSelectedObjectsResponse(struct soap *soap, const char *tag, struct _ns1__getSelectedObjectsResponse *a, const char *type)
{
	size_t soap_flag_fileId = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__getSelectedObjectsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getSelectedObjectsResponse, sizeof(struct _ns1__getSelectedObjectsResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__getSelectedObjectsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fileId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "fileId", &a->fileId, "xsd:string"))
				{	soap_flag_fileId--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__getSelectedObjectsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getSelectedObjectsResponse, 0, sizeof(struct _ns1__getSelectedObjectsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__getSelectedObjectsResponse(struct soap *soap, const struct _ns1__getSelectedObjectsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__getSelectedObjectsResponse);
	if (soap_out__ns1__getSelectedObjectsResponse(soap, tag?tag:"ns1:getSelectedObjectsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getSelectedObjectsResponse * SOAP_FMAC4 soap_get__ns1__getSelectedObjectsResponse(struct soap *soap, struct _ns1__getSelectedObjectsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getSelectedObjectsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__getSelectedObjectsRequest(struct soap *soap, struct _ns1__getSelectedObjectsRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizecampaignIds = 0;
	a->campaignIds = NULL;
	a->__sizecampaignSelectedColumn = 0;
	a->campaignSelectedColumn = NULL;
	a->__sizeadgroupSelectedColumn = 0;
	a->adgroupSelectedColumn = NULL;
	a->__sizekeywordSelectedColumn = 0;
	a->keywordSelectedColumn = NULL;
	a->__sizecreativeSelectedColumn = 0;
	a->creativeSelectedColumn = NULL;
	a->__sizeselectedRow = 0;
	a->selectedRow = NULL;
	a->format = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__getSelectedObjectsRequest(struct soap *soap, const struct _ns1__getSelectedObjectsRequest *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->campaignIds)
	{	int i;
		for (i = 0; i < a->__sizecampaignIds; i++)
		{
			soap_embedded(soap, a->campaignIds + i, SOAP_TYPE_LONG64);
		}
	}
	if (a->campaignSelectedColumn)
	{	int i;
		for (i = 0; i < a->__sizecampaignSelectedColumn; i++)
		{
			soap_serialize_string(soap, a->campaignSelectedColumn + i);
		}
	}
	if (a->adgroupSelectedColumn)
	{	int i;
		for (i = 0; i < a->__sizeadgroupSelectedColumn; i++)
		{
			soap_serialize_string(soap, a->adgroupSelectedColumn + i);
		}
	}
	if (a->keywordSelectedColumn)
	{	int i;
		for (i = 0; i < a->__sizekeywordSelectedColumn; i++)
		{
			soap_serialize_string(soap, a->keywordSelectedColumn + i);
		}
	}
	if (a->creativeSelectedColumn)
	{	int i;
		for (i = 0; i < a->__sizecreativeSelectedColumn; i++)
		{
			soap_serialize_string(soap, a->creativeSelectedColumn + i);
		}
	}
	if (a->selectedRow)
	{	int i;
		for (i = 0; i < a->__sizeselectedRow; i++)
		{
			soap_embedded(soap, a->selectedRow + i, SOAP_TYPE_ns1__VariableColumn);
			soap_serialize_ns1__VariableColumn(soap, a->selectedRow + i);
		}
	}
	soap_serialize_PointerToint(soap, &a->format);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getSelectedObjectsRequest(struct soap *soap, const char *tag, int id, const struct _ns1__getSelectedObjectsRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getSelectedObjectsRequest), type))
		return soap->error;
	if (a->campaignIds)
	{	int i;
		for (i = 0; i < a->__sizecampaignIds; i++)
			if (soap_out_LONG64(soap, "campaignIds", -1, a->campaignIds + i, ""))
				return soap->error;
	}
	if (a->campaignSelectedColumn)
	{	int i;
		for (i = 0; i < a->__sizecampaignSelectedColumn; i++)
			if (soap_out_string(soap, "campaignSelectedColumn", -1, a->campaignSelectedColumn + i, ""))
				return soap->error;
	}
	if (a->adgroupSelectedColumn)
	{	int i;
		for (i = 0; i < a->__sizeadgroupSelectedColumn; i++)
			if (soap_out_string(soap, "adgroupSelectedColumn", -1, a->adgroupSelectedColumn + i, ""))
				return soap->error;
	}
	if (a->keywordSelectedColumn)
	{	int i;
		for (i = 0; i < a->__sizekeywordSelectedColumn; i++)
			if (soap_out_string(soap, "keywordSelectedColumn", -1, a->keywordSelectedColumn + i, ""))
				return soap->error;
	}
	if (a->creativeSelectedColumn)
	{	int i;
		for (i = 0; i < a->__sizecreativeSelectedColumn; i++)
			if (soap_out_string(soap, "creativeSelectedColumn", -1, a->creativeSelectedColumn + i, ""))
				return soap->error;
	}
	if (a->selectedRow)
	{	int i;
		for (i = 0; i < a->__sizeselectedRow; i++)
			if (soap_out_ns1__VariableColumn(soap, "selectedRow", -1, a->selectedRow + i, ""))
				return soap->error;
	}
	if (soap_out_PointerToint(soap, "format", -1, &a->format, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__getSelectedObjectsRequest * SOAP_FMAC4 soap_in__ns1__getSelectedObjectsRequest(struct soap *soap, const char *tag, struct _ns1__getSelectedObjectsRequest *a, const char *type)
{
	struct soap_blist *soap_blist_campaignIds = NULL;
	struct soap_blist *soap_blist_campaignSelectedColumn = NULL;
	struct soap_blist *soap_blist_adgroupSelectedColumn = NULL;
	struct soap_blist *soap_blist_keywordSelectedColumn = NULL;
	struct soap_blist *soap_blist_creativeSelectedColumn = NULL;
	struct soap_blist *soap_blist_selectedRow = NULL;
	size_t soap_flag_format = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__getSelectedObjectsRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getSelectedObjectsRequest, sizeof(struct _ns1__getSelectedObjectsRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__getSelectedObjectsRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "campaignIds", 1, NULL))
			{	if (a->campaignIds == NULL)
				{	if (soap_blist_campaignIds == NULL)
						soap_blist_campaignIds = soap_new_block(soap);
					a->campaignIds = (LONG64 *)soap_push_block(soap, soap_blist_campaignIds, sizeof(LONG64));
					if (a->campaignIds == NULL)
						return NULL;
					soap_default_LONG64(soap, a->campaignIds);
				}
				soap_revert(soap);
				if (soap_in_LONG64(soap, "campaignIds", a->campaignIds, "xsd:long"))
				{	a->__sizecampaignIds++;
					a->campaignIds = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "campaignSelectedColumn", 1, NULL))
			{	if (a->campaignSelectedColumn == NULL)
				{	if (soap_blist_campaignSelectedColumn == NULL)
						soap_blist_campaignSelectedColumn = soap_new_block(soap);
					a->campaignSelectedColumn = (char **)soap_push_block(soap, soap_blist_campaignSelectedColumn, sizeof(char *));
					if (a->campaignSelectedColumn == NULL)
						return NULL;
					*a->campaignSelectedColumn = NULL;
				}
				soap_revert(soap);
				if (soap_in_string(soap, "campaignSelectedColumn", a->campaignSelectedColumn, "xsd:string"))
				{	a->__sizecampaignSelectedColumn++;
					a->campaignSelectedColumn = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "adgroupSelectedColumn", 1, NULL))
			{	if (a->adgroupSelectedColumn == NULL)
				{	if (soap_blist_adgroupSelectedColumn == NULL)
						soap_blist_adgroupSelectedColumn = soap_new_block(soap);
					a->adgroupSelectedColumn = (char **)soap_push_block(soap, soap_blist_adgroupSelectedColumn, sizeof(char *));
					if (a->adgroupSelectedColumn == NULL)
						return NULL;
					*a->adgroupSelectedColumn = NULL;
				}
				soap_revert(soap);
				if (soap_in_string(soap, "adgroupSelectedColumn", a->adgroupSelectedColumn, "xsd:string"))
				{	a->__sizeadgroupSelectedColumn++;
					a->adgroupSelectedColumn = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "keywordSelectedColumn", 1, NULL))
			{	if (a->keywordSelectedColumn == NULL)
				{	if (soap_blist_keywordSelectedColumn == NULL)
						soap_blist_keywordSelectedColumn = soap_new_block(soap);
					a->keywordSelectedColumn = (char **)soap_push_block(soap, soap_blist_keywordSelectedColumn, sizeof(char *));
					if (a->keywordSelectedColumn == NULL)
						return NULL;
					*a->keywordSelectedColumn = NULL;
				}
				soap_revert(soap);
				if (soap_in_string(soap, "keywordSelectedColumn", a->keywordSelectedColumn, "xsd:string"))
				{	a->__sizekeywordSelectedColumn++;
					a->keywordSelectedColumn = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "creativeSelectedColumn", 1, NULL))
			{	if (a->creativeSelectedColumn == NULL)
				{	if (soap_blist_creativeSelectedColumn == NULL)
						soap_blist_creativeSelectedColumn = soap_new_block(soap);
					a->creativeSelectedColumn = (char **)soap_push_block(soap, soap_blist_creativeSelectedColumn, sizeof(char *));
					if (a->creativeSelectedColumn == NULL)
						return NULL;
					*a->creativeSelectedColumn = NULL;
				}
				soap_revert(soap);
				if (soap_in_string(soap, "creativeSelectedColumn", a->creativeSelectedColumn, "xsd:string"))
				{	a->__sizecreativeSelectedColumn++;
					a->creativeSelectedColumn = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "selectedRow", 1, NULL))
			{	if (a->selectedRow == NULL)
				{	if (soap_blist_selectedRow == NULL)
						soap_blist_selectedRow = soap_new_block(soap);
					a->selectedRow = (struct ns1__VariableColumn *)soap_push_block(soap, soap_blist_selectedRow, sizeof(struct ns1__VariableColumn));
					if (a->selectedRow == NULL)
						return NULL;
					soap_default_ns1__VariableColumn(soap, a->selectedRow);
				}
				soap_revert(soap);
				if (soap_in_ns1__VariableColumn(soap, "selectedRow", a->selectedRow, "ns1:VariableColumn"))
				{	a->__sizeselectedRow++;
					a->selectedRow = NULL;
					continue;
				}
			}
			if (soap_flag_format && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "format", &a->format, "xsd:int"))
				{	soap_flag_format--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->campaignIds)
			soap_pop_block(soap, soap_blist_campaignIds);
		if (a->__sizecampaignIds)
			a->campaignIds = (LONG64 *)soap_save_block(soap, soap_blist_campaignIds, NULL, 1);
		else
		{	a->campaignIds = NULL;
			if (soap_blist_campaignIds)
				soap_end_block(soap, soap_blist_campaignIds);
		}
		if (a->campaignSelectedColumn)
			soap_pop_block(soap, soap_blist_campaignSelectedColumn);
		if (a->__sizecampaignSelectedColumn)
			a->campaignSelectedColumn = (char **)soap_save_block(soap, soap_blist_campaignSelectedColumn, NULL, 1);
		else
		{	a->campaignSelectedColumn = NULL;
			if (soap_blist_campaignSelectedColumn)
				soap_end_block(soap, soap_blist_campaignSelectedColumn);
		}
		if (a->adgroupSelectedColumn)
			soap_pop_block(soap, soap_blist_adgroupSelectedColumn);
		if (a->__sizeadgroupSelectedColumn)
			a->adgroupSelectedColumn = (char **)soap_save_block(soap, soap_blist_adgroupSelectedColumn, NULL, 1);
		else
		{	a->adgroupSelectedColumn = NULL;
			if (soap_blist_adgroupSelectedColumn)
				soap_end_block(soap, soap_blist_adgroupSelectedColumn);
		}
		if (a->keywordSelectedColumn)
			soap_pop_block(soap, soap_blist_keywordSelectedColumn);
		if (a->__sizekeywordSelectedColumn)
			a->keywordSelectedColumn = (char **)soap_save_block(soap, soap_blist_keywordSelectedColumn, NULL, 1);
		else
		{	a->keywordSelectedColumn = NULL;
			if (soap_blist_keywordSelectedColumn)
				soap_end_block(soap, soap_blist_keywordSelectedColumn);
		}
		if (a->creativeSelectedColumn)
			soap_pop_block(soap, soap_blist_creativeSelectedColumn);
		if (a->__sizecreativeSelectedColumn)
			a->creativeSelectedColumn = (char **)soap_save_block(soap, soap_blist_creativeSelectedColumn, NULL, 1);
		else
		{	a->creativeSelectedColumn = NULL;
			if (soap_blist_creativeSelectedColumn)
				soap_end_block(soap, soap_blist_creativeSelectedColumn);
		}
		if (a->selectedRow)
			soap_pop_block(soap, soap_blist_selectedRow);
		if (a->__sizeselectedRow)
			a->selectedRow = (struct ns1__VariableColumn *)soap_save_block(soap, soap_blist_selectedRow, NULL, 1);
		else
		{	a->selectedRow = NULL;
			if (soap_blist_selectedRow)
				soap_end_block(soap, soap_blist_selectedRow);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__getSelectedObjectsRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getSelectedObjectsRequest, 0, sizeof(struct _ns1__getSelectedObjectsRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__getSelectedObjectsRequest(struct soap *soap, const struct _ns1__getSelectedObjectsRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__getSelectedObjectsRequest);
	if (soap_out__ns1__getSelectedObjectsRequest(soap, tag?tag:"ns1:getSelectedObjectsRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getSelectedObjectsRequest * SOAP_FMAC4 soap_get__ns1__getSelectedObjectsRequest(struct soap *soap, struct _ns1__getSelectedObjectsRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getSelectedObjectsRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__getChangedScaleResponse(struct soap *soap, struct _ns1__getChangedScaleResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizechangedCampaignScale = 0;
	a->changedCampaignScale = NULL;
	a->__sizechangedAdgroupScale = 0;
	a->changedAdgroupScale = NULL;
	a->__sizechangedKeywordScale = 0;
	a->changedKeywordScale = NULL;
	a->__sizechangedCreativeScale = 0;
	a->changedCreativeScale = NULL;
	a->__sizechangedNewCreativeScales = 0;
	a->changedNewCreativeScales = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__getChangedScaleResponse(struct soap *soap, const struct _ns1__getChangedScaleResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->changedCampaignScale)
	{	int i;
		for (i = 0; i < a->__sizechangedCampaignScale; i++)
		{
			soap_embedded(soap, a->changedCampaignScale + i, SOAP_TYPE_LONG64);
		}
	}
	if (a->changedAdgroupScale)
	{	int i;
		for (i = 0; i < a->__sizechangedAdgroupScale; i++)
		{
			soap_embedded(soap, a->changedAdgroupScale + i, SOAP_TYPE_LONG64);
		}
	}
	if (a->changedKeywordScale)
	{	int i;
		for (i = 0; i < a->__sizechangedKeywordScale; i++)
		{
			soap_embedded(soap, a->changedKeywordScale + i, SOAP_TYPE_LONG64);
		}
	}
	if (a->changedCreativeScale)
	{	int i;
		for (i = 0; i < a->__sizechangedCreativeScale; i++)
		{
			soap_embedded(soap, a->changedCreativeScale + i, SOAP_TYPE_LONG64);
		}
	}
	if (a->changedNewCreativeScales)
	{	int i;
		for (i = 0; i < a->__sizechangedNewCreativeScales; i++)
		{
			soap_embedded(soap, a->changedNewCreativeScales + i, SOAP_TYPE_ns1__ChangedNewCreativeScaleType);
			soap_serialize_ns1__ChangedNewCreativeScaleType(soap, a->changedNewCreativeScales + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getChangedScaleResponse(struct soap *soap, const char *tag, int id, const struct _ns1__getChangedScaleResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getChangedScaleResponse), type))
		return soap->error;
	if (a->changedCampaignScale)
	{	int i;
		for (i = 0; i < a->__sizechangedCampaignScale; i++)
			if (soap_out_LONG64(soap, "changedCampaignScale", -1, a->changedCampaignScale + i, ""))
				return soap->error;
	}
	if (a->changedAdgroupScale)
	{	int i;
		for (i = 0; i < a->__sizechangedAdgroupScale; i++)
			if (soap_out_LONG64(soap, "changedAdgroupScale", -1, a->changedAdgroupScale + i, ""))
				return soap->error;
	}
	if (a->changedKeywordScale)
	{	int i;
		for (i = 0; i < a->__sizechangedKeywordScale; i++)
			if (soap_out_LONG64(soap, "changedKeywordScale", -1, a->changedKeywordScale + i, ""))
				return soap->error;
	}
	if (a->changedCreativeScale)
	{	int i;
		for (i = 0; i < a->__sizechangedCreativeScale; i++)
			if (soap_out_LONG64(soap, "changedCreativeScale", -1, a->changedCreativeScale + i, ""))
				return soap->error;
	}
	if (a->changedNewCreativeScales)
	{	int i;
		for (i = 0; i < a->__sizechangedNewCreativeScales; i++)
			if (soap_out_ns1__ChangedNewCreativeScaleType(soap, "changedNewCreativeScales", -1, a->changedNewCreativeScales + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__getChangedScaleResponse * SOAP_FMAC4 soap_in__ns1__getChangedScaleResponse(struct soap *soap, const char *tag, struct _ns1__getChangedScaleResponse *a, const char *type)
{
	struct soap_blist *soap_blist_changedCampaignScale = NULL;
	struct soap_blist *soap_blist_changedAdgroupScale = NULL;
	struct soap_blist *soap_blist_changedKeywordScale = NULL;
	struct soap_blist *soap_blist_changedCreativeScale = NULL;
	struct soap_blist *soap_blist_changedNewCreativeScales = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__getChangedScaleResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getChangedScaleResponse, sizeof(struct _ns1__getChangedScaleResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__getChangedScaleResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "changedCampaignScale", 1, NULL))
			{	if (a->changedCampaignScale == NULL)
				{	if (soap_blist_changedCampaignScale == NULL)
						soap_blist_changedCampaignScale = soap_new_block(soap);
					a->changedCampaignScale = (LONG64 *)soap_push_block(soap, soap_blist_changedCampaignScale, sizeof(LONG64));
					if (a->changedCampaignScale == NULL)
						return NULL;
					soap_default_LONG64(soap, a->changedCampaignScale);
				}
				soap_revert(soap);
				if (soap_in_LONG64(soap, "changedCampaignScale", a->changedCampaignScale, "xsd:long"))
				{	a->__sizechangedCampaignScale++;
					a->changedCampaignScale = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "changedAdgroupScale", 1, NULL))
			{	if (a->changedAdgroupScale == NULL)
				{	if (soap_blist_changedAdgroupScale == NULL)
						soap_blist_changedAdgroupScale = soap_new_block(soap);
					a->changedAdgroupScale = (LONG64 *)soap_push_block(soap, soap_blist_changedAdgroupScale, sizeof(LONG64));
					if (a->changedAdgroupScale == NULL)
						return NULL;
					soap_default_LONG64(soap, a->changedAdgroupScale);
				}
				soap_revert(soap);
				if (soap_in_LONG64(soap, "changedAdgroupScale", a->changedAdgroupScale, "xsd:long"))
				{	a->__sizechangedAdgroupScale++;
					a->changedAdgroupScale = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "changedKeywordScale", 1, NULL))
			{	if (a->changedKeywordScale == NULL)
				{	if (soap_blist_changedKeywordScale == NULL)
						soap_blist_changedKeywordScale = soap_new_block(soap);
					a->changedKeywordScale = (LONG64 *)soap_push_block(soap, soap_blist_changedKeywordScale, sizeof(LONG64));
					if (a->changedKeywordScale == NULL)
						return NULL;
					soap_default_LONG64(soap, a->changedKeywordScale);
				}
				soap_revert(soap);
				if (soap_in_LONG64(soap, "changedKeywordScale", a->changedKeywordScale, "xsd:long"))
				{	a->__sizechangedKeywordScale++;
					a->changedKeywordScale = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "changedCreativeScale", 1, NULL))
			{	if (a->changedCreativeScale == NULL)
				{	if (soap_blist_changedCreativeScale == NULL)
						soap_blist_changedCreativeScale = soap_new_block(soap);
					a->changedCreativeScale = (LONG64 *)soap_push_block(soap, soap_blist_changedCreativeScale, sizeof(LONG64));
					if (a->changedCreativeScale == NULL)
						return NULL;
					soap_default_LONG64(soap, a->changedCreativeScale);
				}
				soap_revert(soap);
				if (soap_in_LONG64(soap, "changedCreativeScale", a->changedCreativeScale, "xsd:long"))
				{	a->__sizechangedCreativeScale++;
					a->changedCreativeScale = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "changedNewCreativeScales", 1, NULL))
			{	if (a->changedNewCreativeScales == NULL)
				{	if (soap_blist_changedNewCreativeScales == NULL)
						soap_blist_changedNewCreativeScales = soap_new_block(soap);
					a->changedNewCreativeScales = (struct ns1__ChangedNewCreativeScaleType *)soap_push_block(soap, soap_blist_changedNewCreativeScales, sizeof(struct ns1__ChangedNewCreativeScaleType));
					if (a->changedNewCreativeScales == NULL)
						return NULL;
					soap_default_ns1__ChangedNewCreativeScaleType(soap, a->changedNewCreativeScales);
				}
				soap_revert(soap);
				if (soap_in_ns1__ChangedNewCreativeScaleType(soap, "changedNewCreativeScales", a->changedNewCreativeScales, "ns1:ChangedNewCreativeScaleType"))
				{	a->__sizechangedNewCreativeScales++;
					a->changedNewCreativeScales = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->changedCampaignScale)
			soap_pop_block(soap, soap_blist_changedCampaignScale);
		if (a->__sizechangedCampaignScale)
			a->changedCampaignScale = (LONG64 *)soap_save_block(soap, soap_blist_changedCampaignScale, NULL, 1);
		else
		{	a->changedCampaignScale = NULL;
			if (soap_blist_changedCampaignScale)
				soap_end_block(soap, soap_blist_changedCampaignScale);
		}
		if (a->changedAdgroupScale)
			soap_pop_block(soap, soap_blist_changedAdgroupScale);
		if (a->__sizechangedAdgroupScale)
			a->changedAdgroupScale = (LONG64 *)soap_save_block(soap, soap_blist_changedAdgroupScale, NULL, 1);
		else
		{	a->changedAdgroupScale = NULL;
			if (soap_blist_changedAdgroupScale)
				soap_end_block(soap, soap_blist_changedAdgroupScale);
		}
		if (a->changedKeywordScale)
			soap_pop_block(soap, soap_blist_changedKeywordScale);
		if (a->__sizechangedKeywordScale)
			a->changedKeywordScale = (LONG64 *)soap_save_block(soap, soap_blist_changedKeywordScale, NULL, 1);
		else
		{	a->changedKeywordScale = NULL;
			if (soap_blist_changedKeywordScale)
				soap_end_block(soap, soap_blist_changedKeywordScale);
		}
		if (a->changedCreativeScale)
			soap_pop_block(soap, soap_blist_changedCreativeScale);
		if (a->__sizechangedCreativeScale)
			a->changedCreativeScale = (LONG64 *)soap_save_block(soap, soap_blist_changedCreativeScale, NULL, 1);
		else
		{	a->changedCreativeScale = NULL;
			if (soap_blist_changedCreativeScale)
				soap_end_block(soap, soap_blist_changedCreativeScale);
		}
		if (a->changedNewCreativeScales)
			soap_pop_block(soap, soap_blist_changedNewCreativeScales);
		if (a->__sizechangedNewCreativeScales)
			a->changedNewCreativeScales = (struct ns1__ChangedNewCreativeScaleType *)soap_save_block(soap, soap_blist_changedNewCreativeScales, NULL, 1);
		else
		{	a->changedNewCreativeScales = NULL;
			if (soap_blist_changedNewCreativeScales)
				soap_end_block(soap, soap_blist_changedNewCreativeScales);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__getChangedScaleResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getChangedScaleResponse, 0, sizeof(struct _ns1__getChangedScaleResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__getChangedScaleResponse(struct soap *soap, const struct _ns1__getChangedScaleResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__getChangedScaleResponse);
	if (soap_out__ns1__getChangedScaleResponse(soap, tag?tag:"ns1:getChangedScaleResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getChangedScaleResponse * SOAP_FMAC4 soap_get__ns1__getChangedScaleResponse(struct soap *soap, struct _ns1__getChangedScaleResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getChangedScaleResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__getChangedScaleRequest(struct soap *soap, struct _ns1__getChangedScaleRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_time(soap, &a->startTime);
	a->__sizecampaignIds = 0;
	a->campaignIds = NULL;
	a->changedCampaignScale = NULL;
	a->changedAdgroupScale = NULL;
	a->changedKeywordScale = NULL;
	a->changedCreativeScale = NULL;
	a->changedNewCreativeScales = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__getChangedScaleRequest(struct soap *soap, const struct _ns1__getChangedScaleRequest *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->startTime, SOAP_TYPE_time);
	if (a->campaignIds)
	{	int i;
		for (i = 0; i < a->__sizecampaignIds; i++)
		{
			soap_embedded(soap, a->campaignIds + i, SOAP_TYPE_LONG64);
		}
	}
	soap_serialize_PointerToxsd__boolean(soap, &a->changedCampaignScale);
	soap_serialize_PointerToxsd__boolean(soap, &a->changedAdgroupScale);
	soap_serialize_PointerToxsd__boolean(soap, &a->changedKeywordScale);
	soap_serialize_PointerToxsd__boolean(soap, &a->changedCreativeScale);
	soap_serialize_PointerToint(soap, &a->changedNewCreativeScales);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getChangedScaleRequest(struct soap *soap, const char *tag, int id, const struct _ns1__getChangedScaleRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getChangedScaleRequest), type))
		return soap->error;
	if (soap_out_time(soap, "startTime", -1, &a->startTime, ""))
		return soap->error;
	if (a->campaignIds)
	{	int i;
		for (i = 0; i < a->__sizecampaignIds; i++)
			if (soap_out_LONG64(soap, "campaignIds", -1, a->campaignIds + i, ""))
				return soap->error;
	}
	if (soap_out_PointerToxsd__boolean(soap, "changedCampaignScale", -1, &a->changedCampaignScale, ""))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "changedAdgroupScale", -1, &a->changedAdgroupScale, ""))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "changedKeywordScale", -1, &a->changedKeywordScale, ""))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "changedCreativeScale", -1, &a->changedCreativeScale, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "changedNewCreativeScales", -1, &a->changedNewCreativeScales, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__getChangedScaleRequest * SOAP_FMAC4 soap_in__ns1__getChangedScaleRequest(struct soap *soap, const char *tag, struct _ns1__getChangedScaleRequest *a, const char *type)
{
	size_t soap_flag_startTime = 1;
	struct soap_blist *soap_blist_campaignIds = NULL;
	size_t soap_flag_changedCampaignScale = 1;
	size_t soap_flag_changedAdgroupScale = 1;
	size_t soap_flag_changedKeywordScale = 1;
	size_t soap_flag_changedCreativeScale = 1;
	size_t soap_flag_changedNewCreativeScales = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__getChangedScaleRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getChangedScaleRequest, sizeof(struct _ns1__getChangedScaleRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__getChangedScaleRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_startTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "startTime", &a->startTime, "xsd:dateTime"))
				{	soap_flag_startTime--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "campaignIds", 1, NULL))
			{	if (a->campaignIds == NULL)
				{	if (soap_blist_campaignIds == NULL)
						soap_blist_campaignIds = soap_new_block(soap);
					a->campaignIds = (LONG64 *)soap_push_block(soap, soap_blist_campaignIds, sizeof(LONG64));
					if (a->campaignIds == NULL)
						return NULL;
					soap_default_LONG64(soap, a->campaignIds);
				}
				soap_revert(soap);
				if (soap_in_LONG64(soap, "campaignIds", a->campaignIds, "xsd:long"))
				{	a->__sizecampaignIds++;
					a->campaignIds = NULL;
					continue;
				}
			}
			if (soap_flag_changedCampaignScale && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "changedCampaignScale", &a->changedCampaignScale, "xsd:boolean"))
				{	soap_flag_changedCampaignScale--;
					continue;
				}
			if (soap_flag_changedAdgroupScale && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "changedAdgroupScale", &a->changedAdgroupScale, "xsd:boolean"))
				{	soap_flag_changedAdgroupScale--;
					continue;
				}
			if (soap_flag_changedKeywordScale && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "changedKeywordScale", &a->changedKeywordScale, "xsd:boolean"))
				{	soap_flag_changedKeywordScale--;
					continue;
				}
			if (soap_flag_changedCreativeScale && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "changedCreativeScale", &a->changedCreativeScale, "xsd:boolean"))
				{	soap_flag_changedCreativeScale--;
					continue;
				}
			if (soap_flag_changedNewCreativeScales && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "changedNewCreativeScales", &a->changedNewCreativeScales, "xsd:int"))
				{	soap_flag_changedNewCreativeScales--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->campaignIds)
			soap_pop_block(soap, soap_blist_campaignIds);
		if (a->__sizecampaignIds)
			a->campaignIds = (LONG64 *)soap_save_block(soap, soap_blist_campaignIds, NULL, 1);
		else
		{	a->campaignIds = NULL;
			if (soap_blist_campaignIds)
				soap_end_block(soap, soap_blist_campaignIds);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__getChangedScaleRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getChangedScaleRequest, 0, sizeof(struct _ns1__getChangedScaleRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_startTime > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__getChangedScaleRequest(struct soap *soap, const struct _ns1__getChangedScaleRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__getChangedScaleRequest);
	if (soap_out__ns1__getChangedScaleRequest(soap, tag?tag:"ns1:getChangedScaleRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getChangedScaleRequest * SOAP_FMAC4 soap_get__ns1__getChangedScaleRequest(struct soap *soap, struct _ns1__getChangedScaleRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getChangedScaleRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__getAllObjectsResponse(struct soap *soap, struct _ns1__getAllObjectsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->fileId);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__getAllObjectsResponse(struct soap *soap, const struct _ns1__getAllObjectsResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->fileId);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getAllObjectsResponse(struct soap *soap, const char *tag, int id, const struct _ns1__getAllObjectsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getAllObjectsResponse), type))
		return soap->error;
	if (soap_out_string(soap, "fileId", -1, &a->fileId, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__getAllObjectsResponse * SOAP_FMAC4 soap_in__ns1__getAllObjectsResponse(struct soap *soap, const char *tag, struct _ns1__getAllObjectsResponse *a, const char *type)
{
	size_t soap_flag_fileId = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__getAllObjectsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getAllObjectsResponse, sizeof(struct _ns1__getAllObjectsResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__getAllObjectsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fileId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "fileId", &a->fileId, "xsd:string"))
				{	soap_flag_fileId--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__getAllObjectsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getAllObjectsResponse, 0, sizeof(struct _ns1__getAllObjectsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__getAllObjectsResponse(struct soap *soap, const struct _ns1__getAllObjectsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__getAllObjectsResponse);
	if (soap_out__ns1__getAllObjectsResponse(soap, tag?tag:"ns1:getAllObjectsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getAllObjectsResponse * SOAP_FMAC4 soap_get__ns1__getAllObjectsResponse(struct soap *soap, struct _ns1__getAllObjectsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getAllObjectsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__getAllObjectsRequest(struct soap *soap, struct _ns1__getAllObjectsRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizecampaignIds = 0;
	a->campaignIds = NULL;
	a->includeQuality = NULL;
	a->includeTemp = NULL;
	a->format = NULL;
	a->__sizevariableColumns = 0;
	a->variableColumns = NULL;
	a->newCreativeFiles = NULL;
	a->includeTempNewCreatives = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__getAllObjectsRequest(struct soap *soap, const struct _ns1__getAllObjectsRequest *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->campaignIds)
	{	int i;
		for (i = 0; i < a->__sizecampaignIds; i++)
		{
			soap_embedded(soap, a->campaignIds + i, SOAP_TYPE_LONG64);
		}
	}
	soap_serialize_PointerToxsd__boolean(soap, &a->includeQuality);
	soap_serialize_PointerToxsd__boolean(soap, &a->includeTemp);
	soap_serialize_PointerToint(soap, &a->format);
	if (a->variableColumns)
	{	int i;
		for (i = 0; i < a->__sizevariableColumns; i++)
		{
			soap_embedded(soap, a->variableColumns + i, SOAP_TYPE_ns1__VariableColumn);
			soap_serialize_ns1__VariableColumn(soap, a->variableColumns + i);
		}
	}
	soap_serialize_PointerToint(soap, &a->newCreativeFiles);
	soap_serialize_PointerToint(soap, &a->includeTempNewCreatives);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getAllObjectsRequest(struct soap *soap, const char *tag, int id, const struct _ns1__getAllObjectsRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getAllObjectsRequest), type))
		return soap->error;
	if (a->campaignIds)
	{	int i;
		for (i = 0; i < a->__sizecampaignIds; i++)
			if (soap_out_LONG64(soap, "campaignIds", -1, a->campaignIds + i, ""))
				return soap->error;
	}
	if (soap_out_PointerToxsd__boolean(soap, "includeQuality", -1, &a->includeQuality, ""))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "includeTemp", -1, &a->includeTemp, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "format", -1, &a->format, ""))
		return soap->error;
	if (a->variableColumns)
	{	int i;
		for (i = 0; i < a->__sizevariableColumns; i++)
			if (soap_out_ns1__VariableColumn(soap, "variableColumns", -1, a->variableColumns + i, ""))
				return soap->error;
	}
	if (soap_out_PointerToint(soap, "newCreativeFiles", -1, &a->newCreativeFiles, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "includeTempNewCreatives", -1, &a->includeTempNewCreatives, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__getAllObjectsRequest * SOAP_FMAC4 soap_in__ns1__getAllObjectsRequest(struct soap *soap, const char *tag, struct _ns1__getAllObjectsRequest *a, const char *type)
{
	struct soap_blist *soap_blist_campaignIds = NULL;
	size_t soap_flag_includeQuality = 1;
	size_t soap_flag_includeTemp = 1;
	size_t soap_flag_format = 1;
	struct soap_blist *soap_blist_variableColumns = NULL;
	size_t soap_flag_newCreativeFiles = 1;
	size_t soap_flag_includeTempNewCreatives = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__getAllObjectsRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getAllObjectsRequest, sizeof(struct _ns1__getAllObjectsRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__getAllObjectsRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "campaignIds", 1, NULL))
			{	if (a->campaignIds == NULL)
				{	if (soap_blist_campaignIds == NULL)
						soap_blist_campaignIds = soap_new_block(soap);
					a->campaignIds = (LONG64 *)soap_push_block(soap, soap_blist_campaignIds, sizeof(LONG64));
					if (a->campaignIds == NULL)
						return NULL;
					soap_default_LONG64(soap, a->campaignIds);
				}
				soap_revert(soap);
				if (soap_in_LONG64(soap, "campaignIds", a->campaignIds, "xsd:long"))
				{	a->__sizecampaignIds++;
					a->campaignIds = NULL;
					continue;
				}
			}
			if (soap_flag_includeQuality && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "includeQuality", &a->includeQuality, "xsd:boolean"))
				{	soap_flag_includeQuality--;
					continue;
				}
			if (soap_flag_includeTemp && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "includeTemp", &a->includeTemp, "xsd:boolean"))
				{	soap_flag_includeTemp--;
					continue;
				}
			if (soap_flag_format && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "format", &a->format, "xsd:int"))
				{	soap_flag_format--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "variableColumns", 1, NULL))
			{	if (a->variableColumns == NULL)
				{	if (soap_blist_variableColumns == NULL)
						soap_blist_variableColumns = soap_new_block(soap);
					a->variableColumns = (struct ns1__VariableColumn *)soap_push_block(soap, soap_blist_variableColumns, sizeof(struct ns1__VariableColumn));
					if (a->variableColumns == NULL)
						return NULL;
					soap_default_ns1__VariableColumn(soap, a->variableColumns);
				}
				soap_revert(soap);
				if (soap_in_ns1__VariableColumn(soap, "variableColumns", a->variableColumns, "ns1:VariableColumn"))
				{	a->__sizevariableColumns++;
					a->variableColumns = NULL;
					continue;
				}
			}
			if (soap_flag_newCreativeFiles && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "newCreativeFiles", &a->newCreativeFiles, "xsd:int"))
				{	soap_flag_newCreativeFiles--;
					continue;
				}
			if (soap_flag_includeTempNewCreatives && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "includeTempNewCreatives", &a->includeTempNewCreatives, "xsd:int"))
				{	soap_flag_includeTempNewCreatives--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->campaignIds)
			soap_pop_block(soap, soap_blist_campaignIds);
		if (a->__sizecampaignIds)
			a->campaignIds = (LONG64 *)soap_save_block(soap, soap_blist_campaignIds, NULL, 1);
		else
		{	a->campaignIds = NULL;
			if (soap_blist_campaignIds)
				soap_end_block(soap, soap_blist_campaignIds);
		}
		if (a->variableColumns)
			soap_pop_block(soap, soap_blist_variableColumns);
		if (a->__sizevariableColumns)
			a->variableColumns = (struct ns1__VariableColumn *)soap_save_block(soap, soap_blist_variableColumns, NULL, 1);
		else
		{	a->variableColumns = NULL;
			if (soap_blist_variableColumns)
				soap_end_block(soap, soap_blist_variableColumns);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__getAllObjectsRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getAllObjectsRequest, 0, sizeof(struct _ns1__getAllObjectsRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__getAllObjectsRequest(struct soap *soap, const struct _ns1__getAllObjectsRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__getAllObjectsRequest);
	if (soap_out__ns1__getAllObjectsRequest(soap, tag?tag:"ns1:getAllObjectsRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getAllObjectsRequest * SOAP_FMAC4 soap_get__ns1__getAllObjectsRequest(struct soap *soap, struct _ns1__getAllObjectsRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getAllObjectsRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__getChangedIdResponse(struct soap *soap, struct _ns1__getChangedIdResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->endTime = NULL;
	a->__sizechangedCampaignIds = 0;
	a->changedCampaignIds = NULL;
	a->__sizechangedAdgroupIds = 0;
	a->changedAdgroupIds = NULL;
	a->__sizechangedKeywordIds = 0;
	a->changedKeywordIds = NULL;
	a->__sizechangedCreativeIds = 0;
	a->changedCreativeIds = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__getChangedIdResponse(struct soap *soap, const struct _ns1__getChangedIdResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotime(soap, &a->endTime);
	if (a->changedCampaignIds)
	{	int i;
		for (i = 0; i < a->__sizechangedCampaignIds; i++)
		{
			soap_embedded(soap, a->changedCampaignIds + i, SOAP_TYPE_ns1__ChangedCampaignIdType);
			soap_serialize_ns1__ChangedCampaignIdType(soap, a->changedCampaignIds + i);
		}
	}
	if (a->changedAdgroupIds)
	{	int i;
		for (i = 0; i < a->__sizechangedAdgroupIds; i++)
		{
			soap_embedded(soap, a->changedAdgroupIds + i, SOAP_TYPE_ns1__ChangedAdgroupIdType);
			soap_serialize_ns1__ChangedAdgroupIdType(soap, a->changedAdgroupIds + i);
		}
	}
	if (a->changedKeywordIds)
	{	int i;
		for (i = 0; i < a->__sizechangedKeywordIds; i++)
		{
			soap_embedded(soap, a->changedKeywordIds + i, SOAP_TYPE_ns1__ChangedItemType);
			soap_serialize_ns1__ChangedItemType(soap, a->changedKeywordIds + i);
		}
	}
	if (a->changedCreativeIds)
	{	int i;
		for (i = 0; i < a->__sizechangedCreativeIds; i++)
		{
			soap_embedded(soap, a->changedCreativeIds + i, SOAP_TYPE_ns1__ChangedItemType);
			soap_serialize_ns1__ChangedItemType(soap, a->changedCreativeIds + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getChangedIdResponse(struct soap *soap, const char *tag, int id, const struct _ns1__getChangedIdResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getChangedIdResponse), type))
		return soap->error;
	if (soap_out_PointerTotime(soap, "endTime", -1, &a->endTime, ""))
		return soap->error;
	if (a->changedCampaignIds)
	{	int i;
		for (i = 0; i < a->__sizechangedCampaignIds; i++)
			if (soap_out_ns1__ChangedCampaignIdType(soap, "changedCampaignIds", -1, a->changedCampaignIds + i, ""))
				return soap->error;
	}
	if (a->changedAdgroupIds)
	{	int i;
		for (i = 0; i < a->__sizechangedAdgroupIds; i++)
			if (soap_out_ns1__ChangedAdgroupIdType(soap, "changedAdgroupIds", -1, a->changedAdgroupIds + i, ""))
				return soap->error;
	}
	if (a->changedKeywordIds)
	{	int i;
		for (i = 0; i < a->__sizechangedKeywordIds; i++)
			if (soap_out_ns1__ChangedItemType(soap, "changedKeywordIds", -1, a->changedKeywordIds + i, ""))
				return soap->error;
	}
	if (a->changedCreativeIds)
	{	int i;
		for (i = 0; i < a->__sizechangedCreativeIds; i++)
			if (soap_out_ns1__ChangedItemType(soap, "changedCreativeIds", -1, a->changedCreativeIds + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__getChangedIdResponse * SOAP_FMAC4 soap_in__ns1__getChangedIdResponse(struct soap *soap, const char *tag, struct _ns1__getChangedIdResponse *a, const char *type)
{
	size_t soap_flag_endTime = 1;
	struct soap_blist *soap_blist_changedCampaignIds = NULL;
	struct soap_blist *soap_blist_changedAdgroupIds = NULL;
	struct soap_blist *soap_blist_changedKeywordIds = NULL;
	struct soap_blist *soap_blist_changedCreativeIds = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__getChangedIdResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getChangedIdResponse, sizeof(struct _ns1__getChangedIdResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__getChangedIdResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_endTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "endTime", &a->endTime, "xsd:dateTime"))
				{	soap_flag_endTime--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "changedCampaignIds", 1, NULL))
			{	if (a->changedCampaignIds == NULL)
				{	if (soap_blist_changedCampaignIds == NULL)
						soap_blist_changedCampaignIds = soap_new_block(soap);
					a->changedCampaignIds = (struct ns1__ChangedCampaignIdType *)soap_push_block(soap, soap_blist_changedCampaignIds, sizeof(struct ns1__ChangedCampaignIdType));
					if (a->changedCampaignIds == NULL)
						return NULL;
					soap_default_ns1__ChangedCampaignIdType(soap, a->changedCampaignIds);
				}
				soap_revert(soap);
				if (soap_in_ns1__ChangedCampaignIdType(soap, "changedCampaignIds", a->changedCampaignIds, "ns1:ChangedCampaignIdType"))
				{	a->__sizechangedCampaignIds++;
					a->changedCampaignIds = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "changedAdgroupIds", 1, NULL))
			{	if (a->changedAdgroupIds == NULL)
				{	if (soap_blist_changedAdgroupIds == NULL)
						soap_blist_changedAdgroupIds = soap_new_block(soap);
					a->changedAdgroupIds = (struct ns1__ChangedAdgroupIdType *)soap_push_block(soap, soap_blist_changedAdgroupIds, sizeof(struct ns1__ChangedAdgroupIdType));
					if (a->changedAdgroupIds == NULL)
						return NULL;
					soap_default_ns1__ChangedAdgroupIdType(soap, a->changedAdgroupIds);
				}
				soap_revert(soap);
				if (soap_in_ns1__ChangedAdgroupIdType(soap, "changedAdgroupIds", a->changedAdgroupIds, "ns1:ChangedAdgroupIdType"))
				{	a->__sizechangedAdgroupIds++;
					a->changedAdgroupIds = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "changedKeywordIds", 1, NULL))
			{	if (a->changedKeywordIds == NULL)
				{	if (soap_blist_changedKeywordIds == NULL)
						soap_blist_changedKeywordIds = soap_new_block(soap);
					a->changedKeywordIds = (struct ns1__ChangedItemType *)soap_push_block(soap, soap_blist_changedKeywordIds, sizeof(struct ns1__ChangedItemType));
					if (a->changedKeywordIds == NULL)
						return NULL;
					soap_default_ns1__ChangedItemType(soap, a->changedKeywordIds);
				}
				soap_revert(soap);
				if (soap_in_ns1__ChangedItemType(soap, "changedKeywordIds", a->changedKeywordIds, "ns1:ChangedItemType"))
				{	a->__sizechangedKeywordIds++;
					a->changedKeywordIds = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "changedCreativeIds", 1, NULL))
			{	if (a->changedCreativeIds == NULL)
				{	if (soap_blist_changedCreativeIds == NULL)
						soap_blist_changedCreativeIds = soap_new_block(soap);
					a->changedCreativeIds = (struct ns1__ChangedItemType *)soap_push_block(soap, soap_blist_changedCreativeIds, sizeof(struct ns1__ChangedItemType));
					if (a->changedCreativeIds == NULL)
						return NULL;
					soap_default_ns1__ChangedItemType(soap, a->changedCreativeIds);
				}
				soap_revert(soap);
				if (soap_in_ns1__ChangedItemType(soap, "changedCreativeIds", a->changedCreativeIds, "ns1:ChangedItemType"))
				{	a->__sizechangedCreativeIds++;
					a->changedCreativeIds = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->changedCampaignIds)
			soap_pop_block(soap, soap_blist_changedCampaignIds);
		if (a->__sizechangedCampaignIds)
			a->changedCampaignIds = (struct ns1__ChangedCampaignIdType *)soap_save_block(soap, soap_blist_changedCampaignIds, NULL, 1);
		else
		{	a->changedCampaignIds = NULL;
			if (soap_blist_changedCampaignIds)
				soap_end_block(soap, soap_blist_changedCampaignIds);
		}
		if (a->changedAdgroupIds)
			soap_pop_block(soap, soap_blist_changedAdgroupIds);
		if (a->__sizechangedAdgroupIds)
			a->changedAdgroupIds = (struct ns1__ChangedAdgroupIdType *)soap_save_block(soap, soap_blist_changedAdgroupIds, NULL, 1);
		else
		{	a->changedAdgroupIds = NULL;
			if (soap_blist_changedAdgroupIds)
				soap_end_block(soap, soap_blist_changedAdgroupIds);
		}
		if (a->changedKeywordIds)
			soap_pop_block(soap, soap_blist_changedKeywordIds);
		if (a->__sizechangedKeywordIds)
			a->changedKeywordIds = (struct ns1__ChangedItemType *)soap_save_block(soap, soap_blist_changedKeywordIds, NULL, 1);
		else
		{	a->changedKeywordIds = NULL;
			if (soap_blist_changedKeywordIds)
				soap_end_block(soap, soap_blist_changedKeywordIds);
		}
		if (a->changedCreativeIds)
			soap_pop_block(soap, soap_blist_changedCreativeIds);
		if (a->__sizechangedCreativeIds)
			a->changedCreativeIds = (struct ns1__ChangedItemType *)soap_save_block(soap, soap_blist_changedCreativeIds, NULL, 1);
		else
		{	a->changedCreativeIds = NULL;
			if (soap_blist_changedCreativeIds)
				soap_end_block(soap, soap_blist_changedCreativeIds);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__getChangedIdResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getChangedIdResponse, 0, sizeof(struct _ns1__getChangedIdResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__getChangedIdResponse(struct soap *soap, const struct _ns1__getChangedIdResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__getChangedIdResponse);
	if (soap_out__ns1__getChangedIdResponse(soap, tag?tag:"ns1:getChangedIdResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getChangedIdResponse * SOAP_FMAC4 soap_get__ns1__getChangedIdResponse(struct soap *soap, struct _ns1__getChangedIdResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getChangedIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__getChangedIdRequest(struct soap *soap, struct _ns1__getChangedIdRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_time(soap, &a->startTime);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__getChangedIdRequest(struct soap *soap, const struct _ns1__getChangedIdRequest *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->startTime, SOAP_TYPE_time);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getChangedIdRequest(struct soap *soap, const char *tag, int id, const struct _ns1__getChangedIdRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getChangedIdRequest), type))
		return soap->error;
	if (soap_out_time(soap, "startTime", -1, &a->startTime, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__getChangedIdRequest * SOAP_FMAC4 soap_in__ns1__getChangedIdRequest(struct soap *soap, const char *tag, struct _ns1__getChangedIdRequest *a, const char *type)
{
	size_t soap_flag_startTime = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__getChangedIdRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getChangedIdRequest, sizeof(struct _ns1__getChangedIdRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__getChangedIdRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_startTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "startTime", &a->startTime, "xsd:dateTime"))
				{	soap_flag_startTime--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__getChangedIdRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getChangedIdRequest, 0, sizeof(struct _ns1__getChangedIdRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_startTime > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__getChangedIdRequest(struct soap *soap, const struct _ns1__getChangedIdRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__getChangedIdRequest);
	if (soap_out__ns1__getChangedIdRequest(soap, tag?tag:"ns1:getChangedIdRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getChangedIdRequest * SOAP_FMAC4 soap_get__ns1__getChangedIdRequest(struct soap *soap, struct _ns1__getChangedIdRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getChangedIdRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__getChangedItemIdResponse(struct soap *soap, struct _ns1__getChangedItemIdResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->endTime = NULL;
	a->__sizechangedKeywordIds = 0;
	a->changedKeywordIds = NULL;
	a->__sizechangedCreativeIds = 0;
	a->changedCreativeIds = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__getChangedItemIdResponse(struct soap *soap, const struct _ns1__getChangedItemIdResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotime(soap, &a->endTime);
	if (a->changedKeywordIds)
	{	int i;
		for (i = 0; i < a->__sizechangedKeywordIds; i++)
		{
			soap_embedded(soap, a->changedKeywordIds + i, SOAP_TYPE_ns1__ChangedItemType);
			soap_serialize_ns1__ChangedItemType(soap, a->changedKeywordIds + i);
		}
	}
	if (a->changedCreativeIds)
	{	int i;
		for (i = 0; i < a->__sizechangedCreativeIds; i++)
		{
			soap_embedded(soap, a->changedCreativeIds + i, SOAP_TYPE_ns1__ChangedItemType);
			soap_serialize_ns1__ChangedItemType(soap, a->changedCreativeIds + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getChangedItemIdResponse(struct soap *soap, const char *tag, int id, const struct _ns1__getChangedItemIdResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getChangedItemIdResponse), type))
		return soap->error;
	if (soap_out_PointerTotime(soap, "endTime", -1, &a->endTime, ""))
		return soap->error;
	if (a->changedKeywordIds)
	{	int i;
		for (i = 0; i < a->__sizechangedKeywordIds; i++)
			if (soap_out_ns1__ChangedItemType(soap, "changedKeywordIds", -1, a->changedKeywordIds + i, ""))
				return soap->error;
	}
	if (a->changedCreativeIds)
	{	int i;
		for (i = 0; i < a->__sizechangedCreativeIds; i++)
			if (soap_out_ns1__ChangedItemType(soap, "changedCreativeIds", -1, a->changedCreativeIds + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__getChangedItemIdResponse * SOAP_FMAC4 soap_in__ns1__getChangedItemIdResponse(struct soap *soap, const char *tag, struct _ns1__getChangedItemIdResponse *a, const char *type)
{
	size_t soap_flag_endTime = 1;
	struct soap_blist *soap_blist_changedKeywordIds = NULL;
	struct soap_blist *soap_blist_changedCreativeIds = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__getChangedItemIdResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getChangedItemIdResponse, sizeof(struct _ns1__getChangedItemIdResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__getChangedItemIdResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_endTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "endTime", &a->endTime, "xsd:dateTime"))
				{	soap_flag_endTime--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "changedKeywordIds", 1, NULL))
			{	if (a->changedKeywordIds == NULL)
				{	if (soap_blist_changedKeywordIds == NULL)
						soap_blist_changedKeywordIds = soap_new_block(soap);
					a->changedKeywordIds = (struct ns1__ChangedItemType *)soap_push_block(soap, soap_blist_changedKeywordIds, sizeof(struct ns1__ChangedItemType));
					if (a->changedKeywordIds == NULL)
						return NULL;
					soap_default_ns1__ChangedItemType(soap, a->changedKeywordIds);
				}
				soap_revert(soap);
				if (soap_in_ns1__ChangedItemType(soap, "changedKeywordIds", a->changedKeywordIds, "ns1:ChangedItemType"))
				{	a->__sizechangedKeywordIds++;
					a->changedKeywordIds = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "changedCreativeIds", 1, NULL))
			{	if (a->changedCreativeIds == NULL)
				{	if (soap_blist_changedCreativeIds == NULL)
						soap_blist_changedCreativeIds = soap_new_block(soap);
					a->changedCreativeIds = (struct ns1__ChangedItemType *)soap_push_block(soap, soap_blist_changedCreativeIds, sizeof(struct ns1__ChangedItemType));
					if (a->changedCreativeIds == NULL)
						return NULL;
					soap_default_ns1__ChangedItemType(soap, a->changedCreativeIds);
				}
				soap_revert(soap);
				if (soap_in_ns1__ChangedItemType(soap, "changedCreativeIds", a->changedCreativeIds, "ns1:ChangedItemType"))
				{	a->__sizechangedCreativeIds++;
					a->changedCreativeIds = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->changedKeywordIds)
			soap_pop_block(soap, soap_blist_changedKeywordIds);
		if (a->__sizechangedKeywordIds)
			a->changedKeywordIds = (struct ns1__ChangedItemType *)soap_save_block(soap, soap_blist_changedKeywordIds, NULL, 1);
		else
		{	a->changedKeywordIds = NULL;
			if (soap_blist_changedKeywordIds)
				soap_end_block(soap, soap_blist_changedKeywordIds);
		}
		if (a->changedCreativeIds)
			soap_pop_block(soap, soap_blist_changedCreativeIds);
		if (a->__sizechangedCreativeIds)
			a->changedCreativeIds = (struct ns1__ChangedItemType *)soap_save_block(soap, soap_blist_changedCreativeIds, NULL, 1);
		else
		{	a->changedCreativeIds = NULL;
			if (soap_blist_changedCreativeIds)
				soap_end_block(soap, soap_blist_changedCreativeIds);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__getChangedItemIdResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getChangedItemIdResponse, 0, sizeof(struct _ns1__getChangedItemIdResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__getChangedItemIdResponse(struct soap *soap, const struct _ns1__getChangedItemIdResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__getChangedItemIdResponse);
	if (soap_out__ns1__getChangedItemIdResponse(soap, tag?tag:"ns1:getChangedItemIdResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getChangedItemIdResponse * SOAP_FMAC4 soap_get__ns1__getChangedItemIdResponse(struct soap *soap, struct _ns1__getChangedItemIdResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getChangedItemIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__getChangedItemIdRequest(struct soap *soap, struct _ns1__getChangedItemIdRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_time(soap, &a->startTime);
	soap_default_int(soap, &a->type);
	a->__sizeids = 0;
	a->ids = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__getChangedItemIdRequest(struct soap *soap, const struct _ns1__getChangedItemIdRequest *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->startTime, SOAP_TYPE_time);
	soap_embedded(soap, &a->type, SOAP_TYPE_int);
	if (a->ids)
	{	int i;
		for (i = 0; i < a->__sizeids; i++)
		{
			soap_embedded(soap, a->ids + i, SOAP_TYPE_LONG64);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getChangedItemIdRequest(struct soap *soap, const char *tag, int id, const struct _ns1__getChangedItemIdRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getChangedItemIdRequest), type))
		return soap->error;
	if (soap_out_time(soap, "startTime", -1, &a->startTime, ""))
		return soap->error;
	if (soap_out_int(soap, "type", -1, &a->type, ""))
		return soap->error;
	if (a->ids)
	{	int i;
		for (i = 0; i < a->__sizeids; i++)
			if (soap_out_LONG64(soap, "ids", -1, a->ids + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__getChangedItemIdRequest * SOAP_FMAC4 soap_in__ns1__getChangedItemIdRequest(struct soap *soap, const char *tag, struct _ns1__getChangedItemIdRequest *a, const char *type)
{
	size_t soap_flag_startTime = 1;
	size_t soap_flag_type = 1;
	struct soap_blist *soap_blist_ids = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__getChangedItemIdRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getChangedItemIdRequest, sizeof(struct _ns1__getChangedItemIdRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__getChangedItemIdRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_startTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "startTime", &a->startTime, "xsd:dateTime"))
				{	soap_flag_startTime--;
					continue;
				}
			if (soap_flag_type && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "type", &a->type, "xsd:int"))
				{	soap_flag_type--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ids", 1, NULL))
			{	if (a->ids == NULL)
				{	if (soap_blist_ids == NULL)
						soap_blist_ids = soap_new_block(soap);
					a->ids = (LONG64 *)soap_push_block(soap, soap_blist_ids, sizeof(LONG64));
					if (a->ids == NULL)
						return NULL;
					soap_default_LONG64(soap, a->ids);
				}
				soap_revert(soap);
				if (soap_in_LONG64(soap, "ids", a->ids, "xsd:long"))
				{	a->__sizeids++;
					a->ids = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ids)
			soap_pop_block(soap, soap_blist_ids);
		if (a->__sizeids)
			a->ids = (LONG64 *)soap_save_block(soap, soap_blist_ids, NULL, 1);
		else
		{	a->ids = NULL;
			if (soap_blist_ids)
				soap_end_block(soap, soap_blist_ids);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__getChangedItemIdRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getChangedItemIdRequest, 0, sizeof(struct _ns1__getChangedItemIdRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_startTime > 0 || soap_flag_type > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__getChangedItemIdRequest(struct soap *soap, const struct _ns1__getChangedItemIdRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__getChangedItemIdRequest);
	if (soap_out__ns1__getChangedItemIdRequest(soap, tag?tag:"ns1:getChangedItemIdRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getChangedItemIdRequest * SOAP_FMAC4 soap_get__ns1__getChangedItemIdRequest(struct soap *soap, struct _ns1__getChangedItemIdRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getChangedItemIdRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__getChangedAdgroupIdResponse(struct soap *soap, struct _ns1__getChangedAdgroupIdResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->endTime = NULL;
	a->__sizechangedAdgroupIds = 0;
	a->changedAdgroupIds = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__getChangedAdgroupIdResponse(struct soap *soap, const struct _ns1__getChangedAdgroupIdResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotime(soap, &a->endTime);
	if (a->changedAdgroupIds)
	{	int i;
		for (i = 0; i < a->__sizechangedAdgroupIds; i++)
		{
			soap_embedded(soap, a->changedAdgroupIds + i, SOAP_TYPE_ns1__ChangedAdgroupIdType);
			soap_serialize_ns1__ChangedAdgroupIdType(soap, a->changedAdgroupIds + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getChangedAdgroupIdResponse(struct soap *soap, const char *tag, int id, const struct _ns1__getChangedAdgroupIdResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getChangedAdgroupIdResponse), type))
		return soap->error;
	if (soap_out_PointerTotime(soap, "endTime", -1, &a->endTime, ""))
		return soap->error;
	if (a->changedAdgroupIds)
	{	int i;
		for (i = 0; i < a->__sizechangedAdgroupIds; i++)
			if (soap_out_ns1__ChangedAdgroupIdType(soap, "changedAdgroupIds", -1, a->changedAdgroupIds + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__getChangedAdgroupIdResponse * SOAP_FMAC4 soap_in__ns1__getChangedAdgroupIdResponse(struct soap *soap, const char *tag, struct _ns1__getChangedAdgroupIdResponse *a, const char *type)
{
	size_t soap_flag_endTime = 1;
	struct soap_blist *soap_blist_changedAdgroupIds = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__getChangedAdgroupIdResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getChangedAdgroupIdResponse, sizeof(struct _ns1__getChangedAdgroupIdResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__getChangedAdgroupIdResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_endTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "endTime", &a->endTime, "xsd:dateTime"))
				{	soap_flag_endTime--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "changedAdgroupIds", 1, NULL))
			{	if (a->changedAdgroupIds == NULL)
				{	if (soap_blist_changedAdgroupIds == NULL)
						soap_blist_changedAdgroupIds = soap_new_block(soap);
					a->changedAdgroupIds = (struct ns1__ChangedAdgroupIdType *)soap_push_block(soap, soap_blist_changedAdgroupIds, sizeof(struct ns1__ChangedAdgroupIdType));
					if (a->changedAdgroupIds == NULL)
						return NULL;
					soap_default_ns1__ChangedAdgroupIdType(soap, a->changedAdgroupIds);
				}
				soap_revert(soap);
				if (soap_in_ns1__ChangedAdgroupIdType(soap, "changedAdgroupIds", a->changedAdgroupIds, "ns1:ChangedAdgroupIdType"))
				{	a->__sizechangedAdgroupIds++;
					a->changedAdgroupIds = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->changedAdgroupIds)
			soap_pop_block(soap, soap_blist_changedAdgroupIds);
		if (a->__sizechangedAdgroupIds)
			a->changedAdgroupIds = (struct ns1__ChangedAdgroupIdType *)soap_save_block(soap, soap_blist_changedAdgroupIds, NULL, 1);
		else
		{	a->changedAdgroupIds = NULL;
			if (soap_blist_changedAdgroupIds)
				soap_end_block(soap, soap_blist_changedAdgroupIds);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__getChangedAdgroupIdResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getChangedAdgroupIdResponse, 0, sizeof(struct _ns1__getChangedAdgroupIdResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__getChangedAdgroupIdResponse(struct soap *soap, const struct _ns1__getChangedAdgroupIdResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__getChangedAdgroupIdResponse);
	if (soap_out__ns1__getChangedAdgroupIdResponse(soap, tag?tag:"ns1:getChangedAdgroupIdResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getChangedAdgroupIdResponse * SOAP_FMAC4 soap_get__ns1__getChangedAdgroupIdResponse(struct soap *soap, struct _ns1__getChangedAdgroupIdResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getChangedAdgroupIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__getChangedAdgroupIdRequest(struct soap *soap, struct _ns1__getChangedAdgroupIdRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_time(soap, &a->startTime);
	a->__sizecampaignIds = 0;
	a->campaignIds = NULL;
	a->adgroupLevel = NULL;
	a->itemLevel = NULL;
	a->newCreativeLevel = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__getChangedAdgroupIdRequest(struct soap *soap, const struct _ns1__getChangedAdgroupIdRequest *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->startTime, SOAP_TYPE_time);
	if (a->campaignIds)
	{	int i;
		for (i = 0; i < a->__sizecampaignIds; i++)
		{
			soap_embedded(soap, a->campaignIds + i, SOAP_TYPE_LONG64);
		}
	}
	soap_serialize_PointerToxsd__boolean(soap, &a->adgroupLevel);
	soap_serialize_PointerToxsd__boolean(soap, &a->itemLevel);
	soap_serialize_PointerToint(soap, &a->newCreativeLevel);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getChangedAdgroupIdRequest(struct soap *soap, const char *tag, int id, const struct _ns1__getChangedAdgroupIdRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getChangedAdgroupIdRequest), type))
		return soap->error;
	if (soap_out_time(soap, "startTime", -1, &a->startTime, ""))
		return soap->error;
	if (a->campaignIds)
	{	int i;
		for (i = 0; i < a->__sizecampaignIds; i++)
			if (soap_out_LONG64(soap, "campaignIds", -1, a->campaignIds + i, ""))
				return soap->error;
	}
	if (soap_out_PointerToxsd__boolean(soap, "adgroupLevel", -1, &a->adgroupLevel, ""))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "itemLevel", -1, &a->itemLevel, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "newCreativeLevel", -1, &a->newCreativeLevel, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__getChangedAdgroupIdRequest * SOAP_FMAC4 soap_in__ns1__getChangedAdgroupIdRequest(struct soap *soap, const char *tag, struct _ns1__getChangedAdgroupIdRequest *a, const char *type)
{
	size_t soap_flag_startTime = 1;
	struct soap_blist *soap_blist_campaignIds = NULL;
	size_t soap_flag_adgroupLevel = 1;
	size_t soap_flag_itemLevel = 1;
	size_t soap_flag_newCreativeLevel = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__getChangedAdgroupIdRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getChangedAdgroupIdRequest, sizeof(struct _ns1__getChangedAdgroupIdRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__getChangedAdgroupIdRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_startTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "startTime", &a->startTime, "xsd:dateTime"))
				{	soap_flag_startTime--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "campaignIds", 1, NULL))
			{	if (a->campaignIds == NULL)
				{	if (soap_blist_campaignIds == NULL)
						soap_blist_campaignIds = soap_new_block(soap);
					a->campaignIds = (LONG64 *)soap_push_block(soap, soap_blist_campaignIds, sizeof(LONG64));
					if (a->campaignIds == NULL)
						return NULL;
					soap_default_LONG64(soap, a->campaignIds);
				}
				soap_revert(soap);
				if (soap_in_LONG64(soap, "campaignIds", a->campaignIds, "xsd:long"))
				{	a->__sizecampaignIds++;
					a->campaignIds = NULL;
					continue;
				}
			}
			if (soap_flag_adgroupLevel && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "adgroupLevel", &a->adgroupLevel, "xsd:boolean"))
				{	soap_flag_adgroupLevel--;
					continue;
				}
			if (soap_flag_itemLevel && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "itemLevel", &a->itemLevel, "xsd:boolean"))
				{	soap_flag_itemLevel--;
					continue;
				}
			if (soap_flag_newCreativeLevel && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "newCreativeLevel", &a->newCreativeLevel, "xsd:int"))
				{	soap_flag_newCreativeLevel--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->campaignIds)
			soap_pop_block(soap, soap_blist_campaignIds);
		if (a->__sizecampaignIds)
			a->campaignIds = (LONG64 *)soap_save_block(soap, soap_blist_campaignIds, NULL, 1);
		else
		{	a->campaignIds = NULL;
			if (soap_blist_campaignIds)
				soap_end_block(soap, soap_blist_campaignIds);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__getChangedAdgroupIdRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getChangedAdgroupIdRequest, 0, sizeof(struct _ns1__getChangedAdgroupIdRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_startTime > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__getChangedAdgroupIdRequest(struct soap *soap, const struct _ns1__getChangedAdgroupIdRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__getChangedAdgroupIdRequest);
	if (soap_out__ns1__getChangedAdgroupIdRequest(soap, tag?tag:"ns1:getChangedAdgroupIdRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getChangedAdgroupIdRequest * SOAP_FMAC4 soap_get__ns1__getChangedAdgroupIdRequest(struct soap *soap, struct _ns1__getChangedAdgroupIdRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getChangedAdgroupIdRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__getChangedCampaignIdResponse(struct soap *soap, struct _ns1__getChangedCampaignIdResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->endTime = NULL;
	a->__sizechangedCampaignIds = 0;
	a->changedCampaignIds = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__getChangedCampaignIdResponse(struct soap *soap, const struct _ns1__getChangedCampaignIdResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotime(soap, &a->endTime);
	if (a->changedCampaignIds)
	{	int i;
		for (i = 0; i < a->__sizechangedCampaignIds; i++)
		{
			soap_embedded(soap, a->changedCampaignIds + i, SOAP_TYPE_ns1__ChangedCampaignIdType);
			soap_serialize_ns1__ChangedCampaignIdType(soap, a->changedCampaignIds + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getChangedCampaignIdResponse(struct soap *soap, const char *tag, int id, const struct _ns1__getChangedCampaignIdResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getChangedCampaignIdResponse), type))
		return soap->error;
	if (soap_out_PointerTotime(soap, "endTime", -1, &a->endTime, ""))
		return soap->error;
	if (a->changedCampaignIds)
	{	int i;
		for (i = 0; i < a->__sizechangedCampaignIds; i++)
			if (soap_out_ns1__ChangedCampaignIdType(soap, "changedCampaignIds", -1, a->changedCampaignIds + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__getChangedCampaignIdResponse * SOAP_FMAC4 soap_in__ns1__getChangedCampaignIdResponse(struct soap *soap, const char *tag, struct _ns1__getChangedCampaignIdResponse *a, const char *type)
{
	size_t soap_flag_endTime = 1;
	struct soap_blist *soap_blist_changedCampaignIds = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__getChangedCampaignIdResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getChangedCampaignIdResponse, sizeof(struct _ns1__getChangedCampaignIdResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__getChangedCampaignIdResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_endTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "endTime", &a->endTime, "xsd:dateTime"))
				{	soap_flag_endTime--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "changedCampaignIds", 1, NULL))
			{	if (a->changedCampaignIds == NULL)
				{	if (soap_blist_changedCampaignIds == NULL)
						soap_blist_changedCampaignIds = soap_new_block(soap);
					a->changedCampaignIds = (struct ns1__ChangedCampaignIdType *)soap_push_block(soap, soap_blist_changedCampaignIds, sizeof(struct ns1__ChangedCampaignIdType));
					if (a->changedCampaignIds == NULL)
						return NULL;
					soap_default_ns1__ChangedCampaignIdType(soap, a->changedCampaignIds);
				}
				soap_revert(soap);
				if (soap_in_ns1__ChangedCampaignIdType(soap, "changedCampaignIds", a->changedCampaignIds, "ns1:ChangedCampaignIdType"))
				{	a->__sizechangedCampaignIds++;
					a->changedCampaignIds = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->changedCampaignIds)
			soap_pop_block(soap, soap_blist_changedCampaignIds);
		if (a->__sizechangedCampaignIds)
			a->changedCampaignIds = (struct ns1__ChangedCampaignIdType *)soap_save_block(soap, soap_blist_changedCampaignIds, NULL, 1);
		else
		{	a->changedCampaignIds = NULL;
			if (soap_blist_changedCampaignIds)
				soap_end_block(soap, soap_blist_changedCampaignIds);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__getChangedCampaignIdResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getChangedCampaignIdResponse, 0, sizeof(struct _ns1__getChangedCampaignIdResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__getChangedCampaignIdResponse(struct soap *soap, const struct _ns1__getChangedCampaignIdResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__getChangedCampaignIdResponse);
	if (soap_out__ns1__getChangedCampaignIdResponse(soap, tag?tag:"ns1:getChangedCampaignIdResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getChangedCampaignIdResponse * SOAP_FMAC4 soap_get__ns1__getChangedCampaignIdResponse(struct soap *soap, struct _ns1__getChangedCampaignIdResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getChangedCampaignIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__getChangedCampaignIdRequest(struct soap *soap, struct _ns1__getChangedCampaignIdRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_time(soap, &a->startTime);
	a->campaignLevel = NULL;
	a->adgroupLevel = NULL;
	a->itemLevel = NULL;
	a->newCreativeLevel = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__getChangedCampaignIdRequest(struct soap *soap, const struct _ns1__getChangedCampaignIdRequest *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->startTime, SOAP_TYPE_time);
	soap_serialize_PointerToxsd__boolean(soap, &a->campaignLevel);
	soap_serialize_PointerToxsd__boolean(soap, &a->adgroupLevel);
	soap_serialize_PointerToxsd__boolean(soap, &a->itemLevel);
	soap_serialize_PointerToint(soap, &a->newCreativeLevel);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getChangedCampaignIdRequest(struct soap *soap, const char *tag, int id, const struct _ns1__getChangedCampaignIdRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getChangedCampaignIdRequest), type))
		return soap->error;
	if (soap_out_time(soap, "startTime", -1, &a->startTime, ""))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "campaignLevel", -1, &a->campaignLevel, ""))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "adgroupLevel", -1, &a->adgroupLevel, ""))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "itemLevel", -1, &a->itemLevel, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "newCreativeLevel", -1, &a->newCreativeLevel, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__getChangedCampaignIdRequest * SOAP_FMAC4 soap_in__ns1__getChangedCampaignIdRequest(struct soap *soap, const char *tag, struct _ns1__getChangedCampaignIdRequest *a, const char *type)
{
	size_t soap_flag_startTime = 1;
	size_t soap_flag_campaignLevel = 1;
	size_t soap_flag_adgroupLevel = 1;
	size_t soap_flag_itemLevel = 1;
	size_t soap_flag_newCreativeLevel = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__getChangedCampaignIdRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getChangedCampaignIdRequest, sizeof(struct _ns1__getChangedCampaignIdRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__getChangedCampaignIdRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_startTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "startTime", &a->startTime, "xsd:dateTime"))
				{	soap_flag_startTime--;
					continue;
				}
			if (soap_flag_campaignLevel && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "campaignLevel", &a->campaignLevel, "xsd:boolean"))
				{	soap_flag_campaignLevel--;
					continue;
				}
			if (soap_flag_adgroupLevel && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "adgroupLevel", &a->adgroupLevel, "xsd:boolean"))
				{	soap_flag_adgroupLevel--;
					continue;
				}
			if (soap_flag_itemLevel && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "itemLevel", &a->itemLevel, "xsd:boolean"))
				{	soap_flag_itemLevel--;
					continue;
				}
			if (soap_flag_newCreativeLevel && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "newCreativeLevel", &a->newCreativeLevel, "xsd:int"))
				{	soap_flag_newCreativeLevel--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__getChangedCampaignIdRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getChangedCampaignIdRequest, 0, sizeof(struct _ns1__getChangedCampaignIdRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_startTime > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__getChangedCampaignIdRequest(struct soap *soap, const struct _ns1__getChangedCampaignIdRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__getChangedCampaignIdRequest);
	if (soap_out__ns1__getChangedCampaignIdRequest(soap, tag?tag:"ns1:getChangedCampaignIdRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getChangedCampaignIdRequest * SOAP_FMAC4 soap_get__ns1__getChangedCampaignIdRequest(struct soap *soap, struct _ns1__getChangedCampaignIdRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getChangedCampaignIdRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__updateAccountInfoResponse(struct soap *soap, struct _ns1__updateAccountInfoResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->accountInfoType = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__updateAccountInfoResponse(struct soap *soap, const struct _ns1__updateAccountInfoResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__AccountInfoType(soap, &a->accountInfoType);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__updateAccountInfoResponse(struct soap *soap, const char *tag, int id, const struct _ns1__updateAccountInfoResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__updateAccountInfoResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__AccountInfoType(soap, "accountInfoType", -1, &a->accountInfoType, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__updateAccountInfoResponse * SOAP_FMAC4 soap_in__ns1__updateAccountInfoResponse(struct soap *soap, const char *tag, struct _ns1__updateAccountInfoResponse *a, const char *type)
{
	size_t soap_flag_accountInfoType = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__updateAccountInfoResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__updateAccountInfoResponse, sizeof(struct _ns1__updateAccountInfoResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__updateAccountInfoResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_accountInfoType && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__AccountInfoType(soap, "accountInfoType", &a->accountInfoType, "ns1:AccountInfoType"))
				{	soap_flag_accountInfoType--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__updateAccountInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__updateAccountInfoResponse, 0, sizeof(struct _ns1__updateAccountInfoResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__updateAccountInfoResponse(struct soap *soap, const struct _ns1__updateAccountInfoResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__updateAccountInfoResponse);
	if (soap_out__ns1__updateAccountInfoResponse(soap, tag?tag:"ns1:updateAccountInfoResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__updateAccountInfoResponse * SOAP_FMAC4 soap_get__ns1__updateAccountInfoResponse(struct soap *soap, struct _ns1__updateAccountInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__updateAccountInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__updateAccountInfoRequest(struct soap *soap, struct _ns1__updateAccountInfoRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->accountInfoType = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__updateAccountInfoRequest(struct soap *soap, const struct _ns1__updateAccountInfoRequest *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__AccountInfoType(soap, &a->accountInfoType);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__updateAccountInfoRequest(struct soap *soap, const char *tag, int id, const struct _ns1__updateAccountInfoRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__updateAccountInfoRequest), type))
		return soap->error;
	if (a->accountInfoType)
	{	if (soap_out_PointerTons1__AccountInfoType(soap, "accountInfoType", -1, &a->accountInfoType, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "accountInfoType"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__updateAccountInfoRequest * SOAP_FMAC4 soap_in__ns1__updateAccountInfoRequest(struct soap *soap, const char *tag, struct _ns1__updateAccountInfoRequest *a, const char *type)
{
	size_t soap_flag_accountInfoType = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__updateAccountInfoRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__updateAccountInfoRequest, sizeof(struct _ns1__updateAccountInfoRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__updateAccountInfoRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_accountInfoType && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__AccountInfoType(soap, "accountInfoType", &a->accountInfoType, "ns1:AccountInfoType"))
				{	soap_flag_accountInfoType--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__updateAccountInfoRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__updateAccountInfoRequest, 0, sizeof(struct _ns1__updateAccountInfoRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_accountInfoType > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__updateAccountInfoRequest(struct soap *soap, const struct _ns1__updateAccountInfoRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__updateAccountInfoRequest);
	if (soap_out__ns1__updateAccountInfoRequest(soap, tag?tag:"ns1:updateAccountInfoRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__updateAccountInfoRequest * SOAP_FMAC4 soap_get__ns1__updateAccountInfoRequest(struct soap *soap, struct _ns1__updateAccountInfoRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__updateAccountInfoRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__getAccountInfoResponse(struct soap *soap, struct _ns1__getAccountInfoResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->accountInfoType = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__getAccountInfoResponse(struct soap *soap, const struct _ns1__getAccountInfoResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__AccountInfoType(soap, &a->accountInfoType);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getAccountInfoResponse(struct soap *soap, const char *tag, int id, const struct _ns1__getAccountInfoResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getAccountInfoResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__AccountInfoType(soap, "accountInfoType", -1, &a->accountInfoType, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__getAccountInfoResponse * SOAP_FMAC4 soap_in__ns1__getAccountInfoResponse(struct soap *soap, const char *tag, struct _ns1__getAccountInfoResponse *a, const char *type)
{
	size_t soap_flag_accountInfoType = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__getAccountInfoResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getAccountInfoResponse, sizeof(struct _ns1__getAccountInfoResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__getAccountInfoResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_accountInfoType && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__AccountInfoType(soap, "accountInfoType", &a->accountInfoType, "ns1:AccountInfoType"))
				{	soap_flag_accountInfoType--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__getAccountInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getAccountInfoResponse, 0, sizeof(struct _ns1__getAccountInfoResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__getAccountInfoResponse(struct soap *soap, const struct _ns1__getAccountInfoResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__getAccountInfoResponse);
	if (soap_out__ns1__getAccountInfoResponse(soap, tag?tag:"ns1:getAccountInfoResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getAccountInfoResponse * SOAP_FMAC4 soap_get__ns1__getAccountInfoResponse(struct soap *soap, struct _ns1__getAccountInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getAccountInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__getAccountInfoRequest(struct soap *soap, struct _ns1__getAccountInfoRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->type);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__getAccountInfoRequest(struct soap *soap, const struct _ns1__getAccountInfoRequest *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->type, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getAccountInfoRequest(struct soap *soap, const char *tag, int id, const struct _ns1__getAccountInfoRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getAccountInfoRequest), type))
		return soap->error;
	if (soap_out_int(soap, "type", -1, &a->type, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__getAccountInfoRequest * SOAP_FMAC4 soap_in__ns1__getAccountInfoRequest(struct soap *soap, const char *tag, struct _ns1__getAccountInfoRequest *a, const char *type)
{
	size_t soap_flag_type = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__getAccountInfoRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getAccountInfoRequest, sizeof(struct _ns1__getAccountInfoRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__getAccountInfoRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_type && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "type", &a->type, "xsd:int"))
				{	soap_flag_type--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__getAccountInfoRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getAccountInfoRequest, 0, sizeof(struct _ns1__getAccountInfoRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_type > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__getAccountInfoRequest(struct soap *soap, const struct _ns1__getAccountInfoRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__getAccountInfoRequest);
	if (soap_out__ns1__getAccountInfoRequest(soap, tag?tag:"ns1:getAccountInfoRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getAccountInfoRequest * SOAP_FMAC4 soap_get__ns1__getAccountInfoRequest(struct soap *soap, struct _ns1__getAccountInfoRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getAccountInfoRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__ChangedNewCreativeScaleType(struct soap *soap, struct ns1__ChangedNewCreativeScaleType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizechangedNewCreativeScale = 0;
	a->changedNewCreativeScale = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__ChangedNewCreativeScaleType(struct soap *soap, const struct ns1__ChangedNewCreativeScaleType *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->changedNewCreativeScale)
	{	int i;
		for (i = 0; i < a->__sizechangedNewCreativeScale; i++)
		{
			soap_embedded(soap, a->changedNewCreativeScale + i, SOAP_TYPE_LONG64);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ChangedNewCreativeScaleType(struct soap *soap, const char *tag, int id, const struct ns1__ChangedNewCreativeScaleType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ChangedNewCreativeScaleType), type))
		return soap->error;
	if (a->changedNewCreativeScale)
	{	int i;
		for (i = 0; i < a->__sizechangedNewCreativeScale; i++)
			if (soap_out_LONG64(soap, "changedNewCreativeScale", -1, a->changedNewCreativeScale + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__ChangedNewCreativeScaleType * SOAP_FMAC4 soap_in_ns1__ChangedNewCreativeScaleType(struct soap *soap, const char *tag, struct ns1__ChangedNewCreativeScaleType *a, const char *type)
{
	struct soap_blist *soap_blist_changedNewCreativeScale = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__ChangedNewCreativeScaleType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ChangedNewCreativeScaleType, sizeof(struct ns1__ChangedNewCreativeScaleType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__ChangedNewCreativeScaleType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "changedNewCreativeScale", 1, NULL))
			{	if (a->changedNewCreativeScale == NULL)
				{	if (soap_blist_changedNewCreativeScale == NULL)
						soap_blist_changedNewCreativeScale = soap_new_block(soap);
					a->changedNewCreativeScale = (LONG64 *)soap_push_block(soap, soap_blist_changedNewCreativeScale, sizeof(LONG64));
					if (a->changedNewCreativeScale == NULL)
						return NULL;
					soap_default_LONG64(soap, a->changedNewCreativeScale);
				}
				soap_revert(soap);
				if (soap_in_LONG64(soap, "changedNewCreativeScale", a->changedNewCreativeScale, "xsd:long"))
				{	a->__sizechangedNewCreativeScale++;
					a->changedNewCreativeScale = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->changedNewCreativeScale)
			soap_pop_block(soap, soap_blist_changedNewCreativeScale);
		if (a->__sizechangedNewCreativeScale)
			a->changedNewCreativeScale = (LONG64 *)soap_save_block(soap, soap_blist_changedNewCreativeScale, NULL, 1);
		else
		{	a->changedNewCreativeScale = NULL;
			if (soap_blist_changedNewCreativeScale)
				soap_end_block(soap, soap_blist_changedNewCreativeScale);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__ChangedNewCreativeScaleType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ChangedNewCreativeScaleType, 0, sizeof(struct ns1__ChangedNewCreativeScaleType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__ChangedNewCreativeScaleType(struct soap *soap, const struct ns1__ChangedNewCreativeScaleType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__ChangedNewCreativeScaleType);
	if (soap_out_ns1__ChangedNewCreativeScaleType(soap, tag?tag:"ns1:ChangedNewCreativeScaleType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__ChangedNewCreativeScaleType * SOAP_FMAC4 soap_get_ns1__ChangedNewCreativeScaleType(struct soap *soap, struct ns1__ChangedNewCreativeScaleType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ChangedNewCreativeScaleType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__ChangedNewCreativeType(struct soap *soap, struct ns1__ChangedNewCreativeType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->operator_ = NULL;
	a->id = NULL;
	a->adgroupId = NULL;
	a->campaignId = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__ChangedNewCreativeType(struct soap *soap, const struct ns1__ChangedNewCreativeType *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &a->operator_);
	soap_serialize_PointerToLONG64(soap, &a->id);
	soap_serialize_PointerToLONG64(soap, &a->adgroupId);
	soap_serialize_PointerToLONG64(soap, &a->campaignId);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ChangedNewCreativeType(struct soap *soap, const char *tag, int id, const struct ns1__ChangedNewCreativeType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ChangedNewCreativeType), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "operator", -1, &a->operator_, ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "id", -1, &a->id, ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "adgroupId", -1, &a->adgroupId, ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "campaignId", -1, &a->campaignId, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__ChangedNewCreativeType * SOAP_FMAC4 soap_in_ns1__ChangedNewCreativeType(struct soap *soap, const char *tag, struct ns1__ChangedNewCreativeType *a, const char *type)
{
	size_t soap_flag_operator_ = 1;
	size_t soap_flag_id = 1;
	size_t soap_flag_adgroupId = 1;
	size_t soap_flag_campaignId = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__ChangedNewCreativeType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ChangedNewCreativeType, sizeof(struct ns1__ChangedNewCreativeType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__ChangedNewCreativeType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_operator_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "operator", &a->operator_, "xsd:int"))
				{	soap_flag_operator_--;
					continue;
				}
			if (soap_flag_id && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "id", &a->id, "xsd:long"))
				{	soap_flag_id--;
					continue;
				}
			if (soap_flag_adgroupId && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "adgroupId", &a->adgroupId, "xsd:long"))
				{	soap_flag_adgroupId--;
					continue;
				}
			if (soap_flag_campaignId && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "campaignId", &a->campaignId, "xsd:long"))
				{	soap_flag_campaignId--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__ChangedNewCreativeType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ChangedNewCreativeType, 0, sizeof(struct ns1__ChangedNewCreativeType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__ChangedNewCreativeType(struct soap *soap, const struct ns1__ChangedNewCreativeType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__ChangedNewCreativeType);
	if (soap_out_ns1__ChangedNewCreativeType(soap, tag?tag:"ns1:ChangedNewCreativeType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__ChangedNewCreativeType * SOAP_FMAC4 soap_get_ns1__ChangedNewCreativeType(struct soap *soap, struct ns1__ChangedNewCreativeType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ChangedNewCreativeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__TopNkeywordsData(struct soap *soap, struct ns1__TopNkeywordsData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->keywordId);
	soap_default_float(soap, &a->keywordCost);
	soap_default_float(soap, &a->keywordACP);
	soap_default_float(soap, &a->keywordClick);
	soap_default_string(soap, &a->keyword);
	a->isdel = NULL;
	a->status = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__TopNkeywordsData(struct soap *soap, const struct ns1__TopNkeywordsData *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->keywordId, SOAP_TYPE_LONG64);
	soap_serialize_string(soap, &a->keyword);
	soap_serialize_PointerToint(soap, &a->isdel);
	soap_serialize_PointerToint(soap, &a->status);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__TopNkeywordsData(struct soap *soap, const char *tag, int id, const struct ns1__TopNkeywordsData *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__TopNkeywordsData), type))
		return soap->error;
	if (soap_out_LONG64(soap, "keywordId", -1, &a->keywordId, ""))
		return soap->error;
	if (soap_out_float(soap, "keywordCost", -1, &a->keywordCost, ""))
		return soap->error;
	if (soap_out_float(soap, "keywordACP", -1, &a->keywordACP, ""))
		return soap->error;
	if (soap_out_float(soap, "keywordClick", -1, &a->keywordClick, ""))
		return soap->error;
	if (soap_out_string(soap, "keyword", -1, &a->keyword, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "isdel", -1, &a->isdel, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "status", -1, &a->status, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__TopNkeywordsData * SOAP_FMAC4 soap_in_ns1__TopNkeywordsData(struct soap *soap, const char *tag, struct ns1__TopNkeywordsData *a, const char *type)
{
	size_t soap_flag_keywordId = 1;
	size_t soap_flag_keywordCost = 1;
	size_t soap_flag_keywordACP = 1;
	size_t soap_flag_keywordClick = 1;
	size_t soap_flag_keyword = 1;
	size_t soap_flag_isdel = 1;
	size_t soap_flag_status = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__TopNkeywordsData *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__TopNkeywordsData, sizeof(struct ns1__TopNkeywordsData), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__TopNkeywordsData(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_keywordId && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "keywordId", &a->keywordId, "xsd:long"))
				{	soap_flag_keywordId--;
					continue;
				}
			if (soap_flag_keywordCost && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "keywordCost", &a->keywordCost, "xsd:float"))
				{	soap_flag_keywordCost--;
					continue;
				}
			if (soap_flag_keywordACP && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "keywordACP", &a->keywordACP, "xsd:float"))
				{	soap_flag_keywordACP--;
					continue;
				}
			if (soap_flag_keywordClick && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "keywordClick", &a->keywordClick, "xsd:float"))
				{	soap_flag_keywordClick--;
					continue;
				}
			if (soap_flag_keyword && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "keyword", &a->keyword, "xsd:string"))
				{	soap_flag_keyword--;
					continue;
				}
			if (soap_flag_isdel && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "isdel", &a->isdel, "xsd:int"))
				{	soap_flag_isdel--;
					continue;
				}
			if (soap_flag_status && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "status", &a->status, "xsd:int"))
				{	soap_flag_status--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__TopNkeywordsData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__TopNkeywordsData, 0, sizeof(struct ns1__TopNkeywordsData), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_keywordId > 0 || soap_flag_keywordCost > 0 || soap_flag_keywordACP > 0 || soap_flag_keywordClick > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__TopNkeywordsData(struct soap *soap, const struct ns1__TopNkeywordsData *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__TopNkeywordsData);
	if (soap_out_ns1__TopNkeywordsData(soap, tag?tag:"ns1:TopNkeywordsData", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__TopNkeywordsData * SOAP_FMAC4 soap_get_ns1__TopNkeywordsData(struct soap *soap, struct ns1__TopNkeywordsData *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__TopNkeywordsData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__VariableColumn(struct soap *soap, struct ns1__VariableColumn *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->key);
	soap_default_string(soap, &a->value);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__VariableColumn(struct soap *soap, const struct ns1__VariableColumn *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->key);
	soap_serialize_string(soap, &a->value);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__VariableColumn(struct soap *soap, const char *tag, int id, const struct ns1__VariableColumn *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__VariableColumn), type))
		return soap->error;
	if (a->key)
	{	if (soap_out_string(soap, "key", -1, &a->key, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "key"))
		return soap->error;
	if (a->value)
	{	if (soap_out_string(soap, "value", -1, &a->value, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "value"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__VariableColumn * SOAP_FMAC4 soap_in_ns1__VariableColumn(struct soap *soap, const char *tag, struct ns1__VariableColumn *a, const char *type)
{
	size_t soap_flag_key = 1;
	size_t soap_flag_value = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__VariableColumn *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__VariableColumn, sizeof(struct ns1__VariableColumn), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__VariableColumn(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_key && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "key", &a->key, "xsd:string"))
				{	soap_flag_key--;
					continue;
				}
			if (soap_flag_value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "value", &a->value, "xsd:string"))
				{	soap_flag_value--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__VariableColumn *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__VariableColumn, 0, sizeof(struct ns1__VariableColumn), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_key > 0 || soap_flag_value > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__VariableColumn(struct soap *soap, const struct ns1__VariableColumn *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__VariableColumn);
	if (soap_out_ns1__VariableColumn(soap, tag?tag:"ns1:VariableColumn", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__VariableColumn * SOAP_FMAC4 soap_get_ns1__VariableColumn(struct soap *soap, struct ns1__VariableColumn *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__VariableColumn(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__ChangedItemType(struct soap *soap, struct ns1__ChangedItemType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->operator_);
	soap_default_LONG64(soap, &a->id);
	soap_default_LONG64(soap, &a->adgroupId);
	soap_default_LONG64(soap, &a->campaignId);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__ChangedItemType(struct soap *soap, const struct ns1__ChangedItemType *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->operator_, SOAP_TYPE_int);
	soap_embedded(soap, &a->id, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->adgroupId, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->campaignId, SOAP_TYPE_LONG64);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ChangedItemType(struct soap *soap, const char *tag, int id, const struct ns1__ChangedItemType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ChangedItemType), type))
		return soap->error;
	if (soap_out_int(soap, "operator", -1, &a->operator_, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "id", -1, &a->id, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "adgroupId", -1, &a->adgroupId, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "campaignId", -1, &a->campaignId, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__ChangedItemType * SOAP_FMAC4 soap_in_ns1__ChangedItemType(struct soap *soap, const char *tag, struct ns1__ChangedItemType *a, const char *type)
{
	size_t soap_flag_operator_ = 1;
	size_t soap_flag_id = 1;
	size_t soap_flag_adgroupId = 1;
	size_t soap_flag_campaignId = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__ChangedItemType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ChangedItemType, sizeof(struct ns1__ChangedItemType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__ChangedItemType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_operator_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "operator", &a->operator_, "xsd:int"))
				{	soap_flag_operator_--;
					continue;
				}
			if (soap_flag_id && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "id", &a->id, "xsd:long"))
				{	soap_flag_id--;
					continue;
				}
			if (soap_flag_adgroupId && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "adgroupId", &a->adgroupId, "xsd:long"))
				{	soap_flag_adgroupId--;
					continue;
				}
			if (soap_flag_campaignId && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "campaignId", &a->campaignId, "xsd:long"))
				{	soap_flag_campaignId--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__ChangedItemType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ChangedItemType, 0, sizeof(struct ns1__ChangedItemType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_operator_ > 0 || soap_flag_id > 0 || soap_flag_adgroupId > 0 || soap_flag_campaignId > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__ChangedItemType(struct soap *soap, const struct ns1__ChangedItemType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__ChangedItemType);
	if (soap_out_ns1__ChangedItemType(soap, tag?tag:"ns1:ChangedItemType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__ChangedItemType * SOAP_FMAC4 soap_get_ns1__ChangedItemType(struct soap *soap, struct ns1__ChangedItemType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ChangedItemType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__ChangedAdgroupIdType(struct soap *soap, struct ns1__ChangedAdgroupIdType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->operator_);
	soap_default_LONG64(soap, &a->campaignId);
	soap_default_LONG64(soap, &a->adgroupId);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__ChangedAdgroupIdType(struct soap *soap, const struct ns1__ChangedAdgroupIdType *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->operator_, SOAP_TYPE_int);
	soap_embedded(soap, &a->campaignId, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->adgroupId, SOAP_TYPE_LONG64);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ChangedAdgroupIdType(struct soap *soap, const char *tag, int id, const struct ns1__ChangedAdgroupIdType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ChangedAdgroupIdType), type))
		return soap->error;
	if (soap_out_int(soap, "operator", -1, &a->operator_, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "campaignId", -1, &a->campaignId, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "adgroupId", -1, &a->adgroupId, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__ChangedAdgroupIdType * SOAP_FMAC4 soap_in_ns1__ChangedAdgroupIdType(struct soap *soap, const char *tag, struct ns1__ChangedAdgroupIdType *a, const char *type)
{
	size_t soap_flag_operator_ = 1;
	size_t soap_flag_campaignId = 1;
	size_t soap_flag_adgroupId = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__ChangedAdgroupIdType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ChangedAdgroupIdType, sizeof(struct ns1__ChangedAdgroupIdType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__ChangedAdgroupIdType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_operator_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "operator", &a->operator_, "xsd:int"))
				{	soap_flag_operator_--;
					continue;
				}
			if (soap_flag_campaignId && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "campaignId", &a->campaignId, "xsd:long"))
				{	soap_flag_campaignId--;
					continue;
				}
			if (soap_flag_adgroupId && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "adgroupId", &a->adgroupId, "xsd:long"))
				{	soap_flag_adgroupId--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__ChangedAdgroupIdType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ChangedAdgroupIdType, 0, sizeof(struct ns1__ChangedAdgroupIdType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_operator_ > 0 || soap_flag_campaignId > 0 || soap_flag_adgroupId > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__ChangedAdgroupIdType(struct soap *soap, const struct ns1__ChangedAdgroupIdType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__ChangedAdgroupIdType);
	if (soap_out_ns1__ChangedAdgroupIdType(soap, tag?tag:"ns1:ChangedAdgroupIdType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__ChangedAdgroupIdType * SOAP_FMAC4 soap_get_ns1__ChangedAdgroupIdType(struct soap *soap, struct ns1__ChangedAdgroupIdType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ChangedAdgroupIdType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__ChangedCampaignIdType(struct soap *soap, struct ns1__ChangedCampaignIdType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->operator_);
	soap_default_LONG64(soap, &a->campaignId);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__ChangedCampaignIdType(struct soap *soap, const struct ns1__ChangedCampaignIdType *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->operator_, SOAP_TYPE_int);
	soap_embedded(soap, &a->campaignId, SOAP_TYPE_LONG64);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ChangedCampaignIdType(struct soap *soap, const char *tag, int id, const struct ns1__ChangedCampaignIdType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ChangedCampaignIdType), type))
		return soap->error;
	if (soap_out_int(soap, "operator", -1, &a->operator_, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "campaignId", -1, &a->campaignId, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__ChangedCampaignIdType * SOAP_FMAC4 soap_in_ns1__ChangedCampaignIdType(struct soap *soap, const char *tag, struct ns1__ChangedCampaignIdType *a, const char *type)
{
	size_t soap_flag_operator_ = 1;
	size_t soap_flag_campaignId = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__ChangedCampaignIdType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ChangedCampaignIdType, sizeof(struct ns1__ChangedCampaignIdType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__ChangedCampaignIdType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_operator_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "operator", &a->operator_, "xsd:int"))
				{	soap_flag_operator_--;
					continue;
				}
			if (soap_flag_campaignId && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "campaignId", &a->campaignId, "xsd:long"))
				{	soap_flag_campaignId--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__ChangedCampaignIdType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ChangedCampaignIdType, 0, sizeof(struct ns1__ChangedCampaignIdType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_operator_ > 0 || soap_flag_campaignId > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__ChangedCampaignIdType(struct soap *soap, const struct ns1__ChangedCampaignIdType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__ChangedCampaignIdType);
	if (soap_out_ns1__ChangedCampaignIdType(soap, tag?tag:"ns1:ChangedCampaignIdType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__ChangedCampaignIdType * SOAP_FMAC4 soap_get_ns1__ChangedCampaignIdType(struct soap *soap, struct ns1__ChangedCampaignIdType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ChangedCampaignIdType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__OptType(struct soap *soap, struct ns2__OptType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeoptString = 0;
	a->optString = NULL;
	a->__sizeoptInt = 0;
	a->optInt = NULL;
	a->__sizeoptLong = 0;
	a->optLong = NULL;
	a->__sizeoptFloat = 0;
	a->optFloat = NULL;
	a->__sizeoptDouble = 0;
	a->optDouble = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__OptType(struct soap *soap, const struct ns2__OptType *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->optString)
	{	int i;
		for (i = 0; i < a->__sizeoptString; i++)
		{
			soap_embedded(soap, a->optString + i, SOAP_TYPE_ns2__StringMapItemType);
			soap_serialize_ns2__StringMapItemType(soap, a->optString + i);
		}
	}
	if (a->optInt)
	{	int i;
		for (i = 0; i < a->__sizeoptInt; i++)
		{
			soap_embedded(soap, a->optInt + i, SOAP_TYPE_ns2__IntMapItemType);
			soap_serialize_ns2__IntMapItemType(soap, a->optInt + i);
		}
	}
	if (a->optLong)
	{	int i;
		for (i = 0; i < a->__sizeoptLong; i++)
		{
			soap_embedded(soap, a->optLong + i, SOAP_TYPE_ns2__LongMapItemType);
			soap_serialize_ns2__LongMapItemType(soap, a->optLong + i);
		}
	}
	if (a->optFloat)
	{	int i;
		for (i = 0; i < a->__sizeoptFloat; i++)
		{
			soap_embedded(soap, a->optFloat + i, SOAP_TYPE_ns2__FloatMapItemType);
			soap_serialize_ns2__FloatMapItemType(soap, a->optFloat + i);
		}
	}
	if (a->optDouble)
	{	int i;
		for (i = 0; i < a->__sizeoptDouble; i++)
		{
			soap_embedded(soap, a->optDouble + i, SOAP_TYPE_ns2__DoubleMapItemType);
			soap_serialize_ns2__DoubleMapItemType(soap, a->optDouble + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__OptType(struct soap *soap, const char *tag, int id, const struct ns2__OptType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__OptType), type))
		return soap->error;
	if (a->optString)
	{	int i;
		for (i = 0; i < a->__sizeoptString; i++)
			if (soap_out_ns2__StringMapItemType(soap, "ns2:optString", -1, a->optString + i, ""))
				return soap->error;
	}
	if (a->optInt)
	{	int i;
		for (i = 0; i < a->__sizeoptInt; i++)
			if (soap_out_ns2__IntMapItemType(soap, "ns2:optInt", -1, a->optInt + i, ""))
				return soap->error;
	}
	if (a->optLong)
	{	int i;
		for (i = 0; i < a->__sizeoptLong; i++)
			if (soap_out_ns2__LongMapItemType(soap, "ns2:optLong", -1, a->optLong + i, ""))
				return soap->error;
	}
	if (a->optFloat)
	{	int i;
		for (i = 0; i < a->__sizeoptFloat; i++)
			if (soap_out_ns2__FloatMapItemType(soap, "ns2:optFloat", -1, a->optFloat + i, ""))
				return soap->error;
	}
	if (a->optDouble)
	{	int i;
		for (i = 0; i < a->__sizeoptDouble; i++)
			if (soap_out_ns2__DoubleMapItemType(soap, "ns2:optDouble", -1, a->optDouble + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__OptType * SOAP_FMAC4 soap_in_ns2__OptType(struct soap *soap, const char *tag, struct ns2__OptType *a, const char *type)
{
	struct soap_blist *soap_blist_optString = NULL;
	struct soap_blist *soap_blist_optInt = NULL;
	struct soap_blist *soap_blist_optLong = NULL;
	struct soap_blist *soap_blist_optFloat = NULL;
	struct soap_blist *soap_blist_optDouble = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__OptType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__OptType, sizeof(struct ns2__OptType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__OptType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns2:optString", 1, NULL))
			{	if (a->optString == NULL)
				{	if (soap_blist_optString == NULL)
						soap_blist_optString = soap_new_block(soap);
					a->optString = (struct ns2__StringMapItemType *)soap_push_block(soap, soap_blist_optString, sizeof(struct ns2__StringMapItemType));
					if (a->optString == NULL)
						return NULL;
					soap_default_ns2__StringMapItemType(soap, a->optString);
				}
				soap_revert(soap);
				if (soap_in_ns2__StringMapItemType(soap, "ns2:optString", a->optString, "ns2:StringMapItemType"))
				{	a->__sizeoptString++;
					a->optString = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns2:optInt", 1, NULL))
			{	if (a->optInt == NULL)
				{	if (soap_blist_optInt == NULL)
						soap_blist_optInt = soap_new_block(soap);
					a->optInt = (struct ns2__IntMapItemType *)soap_push_block(soap, soap_blist_optInt, sizeof(struct ns2__IntMapItemType));
					if (a->optInt == NULL)
						return NULL;
					soap_default_ns2__IntMapItemType(soap, a->optInt);
				}
				soap_revert(soap);
				if (soap_in_ns2__IntMapItemType(soap, "ns2:optInt", a->optInt, "ns2:IntMapItemType"))
				{	a->__sizeoptInt++;
					a->optInt = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns2:optLong", 1, NULL))
			{	if (a->optLong == NULL)
				{	if (soap_blist_optLong == NULL)
						soap_blist_optLong = soap_new_block(soap);
					a->optLong = (struct ns2__LongMapItemType *)soap_push_block(soap, soap_blist_optLong, sizeof(struct ns2__LongMapItemType));
					if (a->optLong == NULL)
						return NULL;
					soap_default_ns2__LongMapItemType(soap, a->optLong);
				}
				soap_revert(soap);
				if (soap_in_ns2__LongMapItemType(soap, "ns2:optLong", a->optLong, "ns2:LongMapItemType"))
				{	a->__sizeoptLong++;
					a->optLong = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns2:optFloat", 1, NULL))
			{	if (a->optFloat == NULL)
				{	if (soap_blist_optFloat == NULL)
						soap_blist_optFloat = soap_new_block(soap);
					a->optFloat = (struct ns2__FloatMapItemType *)soap_push_block(soap, soap_blist_optFloat, sizeof(struct ns2__FloatMapItemType));
					if (a->optFloat == NULL)
						return NULL;
					soap_default_ns2__FloatMapItemType(soap, a->optFloat);
				}
				soap_revert(soap);
				if (soap_in_ns2__FloatMapItemType(soap, "ns2:optFloat", a->optFloat, "ns2:FloatMapItemType"))
				{	a->__sizeoptFloat++;
					a->optFloat = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns2:optDouble", 1, NULL))
			{	if (a->optDouble == NULL)
				{	if (soap_blist_optDouble == NULL)
						soap_blist_optDouble = soap_new_block(soap);
					a->optDouble = (struct ns2__DoubleMapItemType *)soap_push_block(soap, soap_blist_optDouble, sizeof(struct ns2__DoubleMapItemType));
					if (a->optDouble == NULL)
						return NULL;
					soap_default_ns2__DoubleMapItemType(soap, a->optDouble);
				}
				soap_revert(soap);
				if (soap_in_ns2__DoubleMapItemType(soap, "ns2:optDouble", a->optDouble, "ns2:DoubleMapItemType"))
				{	a->__sizeoptDouble++;
					a->optDouble = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->optString)
			soap_pop_block(soap, soap_blist_optString);
		if (a->__sizeoptString)
			a->optString = (struct ns2__StringMapItemType *)soap_save_block(soap, soap_blist_optString, NULL, 1);
		else
		{	a->optString = NULL;
			if (soap_blist_optString)
				soap_end_block(soap, soap_blist_optString);
		}
		if (a->optInt)
			soap_pop_block(soap, soap_blist_optInt);
		if (a->__sizeoptInt)
			a->optInt = (struct ns2__IntMapItemType *)soap_save_block(soap, soap_blist_optInt, NULL, 1);
		else
		{	a->optInt = NULL;
			if (soap_blist_optInt)
				soap_end_block(soap, soap_blist_optInt);
		}
		if (a->optLong)
			soap_pop_block(soap, soap_blist_optLong);
		if (a->__sizeoptLong)
			a->optLong = (struct ns2__LongMapItemType *)soap_save_block(soap, soap_blist_optLong, NULL, 1);
		else
		{	a->optLong = NULL;
			if (soap_blist_optLong)
				soap_end_block(soap, soap_blist_optLong);
		}
		if (a->optFloat)
			soap_pop_block(soap, soap_blist_optFloat);
		if (a->__sizeoptFloat)
			a->optFloat = (struct ns2__FloatMapItemType *)soap_save_block(soap, soap_blist_optFloat, NULL, 1);
		else
		{	a->optFloat = NULL;
			if (soap_blist_optFloat)
				soap_end_block(soap, soap_blist_optFloat);
		}
		if (a->optDouble)
			soap_pop_block(soap, soap_blist_optDouble);
		if (a->__sizeoptDouble)
			a->optDouble = (struct ns2__DoubleMapItemType *)soap_save_block(soap, soap_blist_optDouble, NULL, 1);
		else
		{	a->optDouble = NULL;
			if (soap_blist_optDouble)
				soap_end_block(soap, soap_blist_optDouble);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__OptType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__OptType, 0, sizeof(struct ns2__OptType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__OptType(struct soap *soap, const struct ns2__OptType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__OptType);
	if (soap_out_ns2__OptType(soap, tag?tag:"ns2:OptType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__OptType * SOAP_FMAC4 soap_get_ns2__OptType(struct soap *soap, struct ns2__OptType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__OptType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__AccountInfoType(struct soap *soap, struct ns1__AccountInfoType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->userid = NULL;
	a->balance = NULL;
	a->cost = NULL;
	a->payment = NULL;
	a->budget = NULL;
	a->type = NULL;
	a->__sizeregionTarget = 0;
	a->regionTarget = NULL;
	a->__sizeexcludeIp = 0;
	a->excludeIp = NULL;
	a->__sizeopenDomains = 0;
	a->openDomains = NULL;
	a->ns2__opt = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__AccountInfoType(struct soap *soap, const struct ns1__AccountInfoType *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToLONG64(soap, &a->userid);
	soap_serialize_PointerTodouble(soap, &a->balance);
	soap_serialize_PointerTodouble(soap, &a->cost);
	soap_serialize_PointerTodouble(soap, &a->payment);
	soap_serialize_PointerTodouble(soap, &a->budget);
	soap_serialize_PointerToint(soap, &a->type);
	if (a->regionTarget)
	{	int i;
		for (i = 0; i < a->__sizeregionTarget; i++)
		{
			soap_embedded(soap, a->regionTarget + i, SOAP_TYPE_int);
		}
	}
	if (a->excludeIp)
	{	int i;
		for (i = 0; i < a->__sizeexcludeIp; i++)
		{
			soap_serialize_string(soap, a->excludeIp + i);
		}
	}
	if (a->openDomains)
	{	int i;
		for (i = 0; i < a->__sizeopenDomains; i++)
		{
			soap_serialize_string(soap, a->openDomains + i);
		}
	}
	soap_serialize_PointerTons2__OptType(soap, &a->ns2__opt);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__AccountInfoType(struct soap *soap, const char *tag, int id, const struct ns1__AccountInfoType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__AccountInfoType), type))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "userid", -1, &a->userid, ""))
		return soap->error;
	if (soap_out_PointerTodouble(soap, "balance", -1, &a->balance, ""))
		return soap->error;
	if (soap_out_PointerTodouble(soap, "cost", -1, &a->cost, ""))
		return soap->error;
	if (soap_out_PointerTodouble(soap, "payment", -1, &a->payment, ""))
		return soap->error;
	if (soap_out_PointerTodouble(soap, "budget", -1, &a->budget, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "type", -1, &a->type, ""))
		return soap->error;
	if (a->regionTarget)
	{	int i;
		for (i = 0; i < a->__sizeregionTarget; i++)
			if (soap_out_int(soap, "regionTarget", -1, a->regionTarget + i, ""))
				return soap->error;
	}
	if (a->excludeIp)
	{	int i;
		for (i = 0; i < a->__sizeexcludeIp; i++)
			if (soap_out_string(soap, "excludeIp", -1, a->excludeIp + i, ""))
				return soap->error;
	}
	if (a->openDomains)
	{	int i;
		for (i = 0; i < a->__sizeopenDomains; i++)
			if (soap_out_string(soap, "openDomains", -1, a->openDomains + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTons2__OptType(soap, "ns2:opt", -1, &a->ns2__opt, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__AccountInfoType * SOAP_FMAC4 soap_in_ns1__AccountInfoType(struct soap *soap, const char *tag, struct ns1__AccountInfoType *a, const char *type)
{
	size_t soap_flag_userid = 1;
	size_t soap_flag_balance = 1;
	size_t soap_flag_cost = 1;
	size_t soap_flag_payment = 1;
	size_t soap_flag_budget = 1;
	size_t soap_flag_type = 1;
	struct soap_blist *soap_blist_regionTarget = NULL;
	struct soap_blist *soap_blist_excludeIp = NULL;
	struct soap_blist *soap_blist_openDomains = NULL;
	size_t soap_flag_ns2__opt = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__AccountInfoType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__AccountInfoType, sizeof(struct ns1__AccountInfoType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__AccountInfoType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_userid && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "userid", &a->userid, "xsd:long"))
				{	soap_flag_userid--;
					continue;
				}
			if (soap_flag_balance && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTodouble(soap, "balance", &a->balance, "xsd:double"))
				{	soap_flag_balance--;
					continue;
				}
			if (soap_flag_cost && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTodouble(soap, "cost", &a->cost, "xsd:double"))
				{	soap_flag_cost--;
					continue;
				}
			if (soap_flag_payment && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTodouble(soap, "payment", &a->payment, "xsd:double"))
				{	soap_flag_payment--;
					continue;
				}
			if (soap_flag_budget && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTodouble(soap, "budget", &a->budget, "xsd:double"))
				{	soap_flag_budget--;
					continue;
				}
			if (soap_flag_type && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "type", &a->type, "xsd:int"))
				{	soap_flag_type--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "regionTarget", 1, NULL))
			{	if (a->regionTarget == NULL)
				{	if (soap_blist_regionTarget == NULL)
						soap_blist_regionTarget = soap_new_block(soap);
					a->regionTarget = (int *)soap_push_block(soap, soap_blist_regionTarget, sizeof(int));
					if (a->regionTarget == NULL)
						return NULL;
					soap_default_int(soap, a->regionTarget);
				}
				soap_revert(soap);
				if (soap_in_int(soap, "regionTarget", a->regionTarget, "xsd:int"))
				{	a->__sizeregionTarget++;
					a->regionTarget = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "excludeIp", 1, NULL))
			{	if (a->excludeIp == NULL)
				{	if (soap_blist_excludeIp == NULL)
						soap_blist_excludeIp = soap_new_block(soap);
					a->excludeIp = (char **)soap_push_block(soap, soap_blist_excludeIp, sizeof(char *));
					if (a->excludeIp == NULL)
						return NULL;
					*a->excludeIp = NULL;
				}
				soap_revert(soap);
				if (soap_in_string(soap, "excludeIp", a->excludeIp, "xsd:string"))
				{	a->__sizeexcludeIp++;
					a->excludeIp = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "openDomains", 1, NULL))
			{	if (a->openDomains == NULL)
				{	if (soap_blist_openDomains == NULL)
						soap_blist_openDomains = soap_new_block(soap);
					a->openDomains = (char **)soap_push_block(soap, soap_blist_openDomains, sizeof(char *));
					if (a->openDomains == NULL)
						return NULL;
					*a->openDomains = NULL;
				}
				soap_revert(soap);
				if (soap_in_string(soap, "openDomains", a->openDomains, "xsd:string"))
				{	a->__sizeopenDomains++;
					a->openDomains = NULL;
					continue;
				}
			}
			if (soap_flag_ns2__opt && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__OptType(soap, "ns2:opt", &a->ns2__opt, "ns2:OptType"))
				{	soap_flag_ns2__opt--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->regionTarget)
			soap_pop_block(soap, soap_blist_regionTarget);
		if (a->__sizeregionTarget)
			a->regionTarget = (int *)soap_save_block(soap, soap_blist_regionTarget, NULL, 1);
		else
		{	a->regionTarget = NULL;
			if (soap_blist_regionTarget)
				soap_end_block(soap, soap_blist_regionTarget);
		}
		if (a->excludeIp)
			soap_pop_block(soap, soap_blist_excludeIp);
		if (a->__sizeexcludeIp)
			a->excludeIp = (char **)soap_save_block(soap, soap_blist_excludeIp, NULL, 1);
		else
		{	a->excludeIp = NULL;
			if (soap_blist_excludeIp)
				soap_end_block(soap, soap_blist_excludeIp);
		}
		if (a->openDomains)
			soap_pop_block(soap, soap_blist_openDomains);
		if (a->__sizeopenDomains)
			a->openDomains = (char **)soap_save_block(soap, soap_blist_openDomains, NULL, 1);
		else
		{	a->openDomains = NULL;
			if (soap_blist_openDomains)
				soap_end_block(soap, soap_blist_openDomains);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__AccountInfoType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__AccountInfoType, 0, sizeof(struct ns1__AccountInfoType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__AccountInfoType(struct soap *soap, const struct ns1__AccountInfoType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__AccountInfoType);
	if (soap_out_ns1__AccountInfoType(soap, tag?tag:"ns1:AccountInfoType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__AccountInfoType * SOAP_FMAC4 soap_get_ns1__AccountInfoType(struct soap *soap, struct ns1__AccountInfoType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__AccountInfoType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Reason);
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetChangedNewCreativeIdResponse(struct soap *soap, struct _ns1__GetChangedNewCreativeIdResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetChangedNewCreativeIdResponse))
		soap_serialize__ns1__GetChangedNewCreativeIdResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetChangedNewCreativeIdResponse(struct soap *soap, const char *tag, int id, struct _ns1__GetChangedNewCreativeIdResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetChangedNewCreativeIdResponse);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__GetChangedNewCreativeIdResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__GetChangedNewCreativeIdResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetChangedNewCreativeIdResponse(struct soap *soap, const char *tag, struct _ns1__GetChangedNewCreativeIdResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__GetChangedNewCreativeIdResponse **)soap_malloc(soap, sizeof(struct _ns1__GetChangedNewCreativeIdResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__GetChangedNewCreativeIdResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__GetChangedNewCreativeIdResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetChangedNewCreativeIdResponse, sizeof(struct _ns1__GetChangedNewCreativeIdResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetChangedNewCreativeIdResponse(struct soap *soap, struct _ns1__GetChangedNewCreativeIdResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetChangedNewCreativeIdResponse);
	if (soap_out_PointerTo_ns1__GetChangedNewCreativeIdResponse(soap, tag?tag:"ns1:GetChangedNewCreativeIdResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__GetChangedNewCreativeIdResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetChangedNewCreativeIdResponse(struct soap *soap, struct _ns1__GetChangedNewCreativeIdResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetChangedNewCreativeIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetChangedNewCreativeIdRequest(struct soap *soap, struct _ns1__GetChangedNewCreativeIdRequest *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetChangedNewCreativeIdRequest))
		soap_serialize__ns1__GetChangedNewCreativeIdRequest(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetChangedNewCreativeIdRequest(struct soap *soap, const char *tag, int id, struct _ns1__GetChangedNewCreativeIdRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetChangedNewCreativeIdRequest);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__GetChangedNewCreativeIdRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__GetChangedNewCreativeIdRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetChangedNewCreativeIdRequest(struct soap *soap, const char *tag, struct _ns1__GetChangedNewCreativeIdRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__GetChangedNewCreativeIdRequest **)soap_malloc(soap, sizeof(struct _ns1__GetChangedNewCreativeIdRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__GetChangedNewCreativeIdRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__GetChangedNewCreativeIdRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetChangedNewCreativeIdRequest, sizeof(struct _ns1__GetChangedNewCreativeIdRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetChangedNewCreativeIdRequest(struct soap *soap, struct _ns1__GetChangedNewCreativeIdRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetChangedNewCreativeIdRequest);
	if (soap_out_PointerTo_ns1__GetChangedNewCreativeIdRequest(soap, tag?tag:"ns1:GetChangedNewCreativeIdRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__GetChangedNewCreativeIdRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetChangedNewCreativeIdRequest(struct soap *soap, struct _ns1__GetChangedNewCreativeIdRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetChangedNewCreativeIdRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getAccountBudgetResponse(struct soap *soap, struct _ns1__getAccountBudgetResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getAccountBudgetResponse))
		soap_serialize__ns1__getAccountBudgetResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getAccountBudgetResponse(struct soap *soap, const char *tag, int id, struct _ns1__getAccountBudgetResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getAccountBudgetResponse);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__getAccountBudgetResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__getAccountBudgetResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__getAccountBudgetResponse(struct soap *soap, const char *tag, struct _ns1__getAccountBudgetResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__getAccountBudgetResponse **)soap_malloc(soap, sizeof(struct _ns1__getAccountBudgetResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__getAccountBudgetResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__getAccountBudgetResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getAccountBudgetResponse, sizeof(struct _ns1__getAccountBudgetResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getAccountBudgetResponse(struct soap *soap, struct _ns1__getAccountBudgetResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getAccountBudgetResponse);
	if (soap_out_PointerTo_ns1__getAccountBudgetResponse(soap, tag?tag:"ns1:getAccountBudgetResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getAccountBudgetResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__getAccountBudgetResponse(struct soap *soap, struct _ns1__getAccountBudgetResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getAccountBudgetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getAccountBudgetRequest(struct soap *soap, struct _ns1__getAccountBudgetRequest *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getAccountBudgetRequest))
		soap_serialize__ns1__getAccountBudgetRequest(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getAccountBudgetRequest(struct soap *soap, const char *tag, int id, struct _ns1__getAccountBudgetRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getAccountBudgetRequest);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__getAccountBudgetRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__getAccountBudgetRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__getAccountBudgetRequest(struct soap *soap, const char *tag, struct _ns1__getAccountBudgetRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__getAccountBudgetRequest **)soap_malloc(soap, sizeof(struct _ns1__getAccountBudgetRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__getAccountBudgetRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__getAccountBudgetRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getAccountBudgetRequest, sizeof(struct _ns1__getAccountBudgetRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getAccountBudgetRequest(struct soap *soap, struct _ns1__getAccountBudgetRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getAccountBudgetRequest);
	if (soap_out_PointerTo_ns1__getAccountBudgetRequest(soap, tag?tag:"ns1:getAccountBudgetRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getAccountBudgetRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__getAccountBudgetRequest(struct soap *soap, struct _ns1__getAccountBudgetRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getAccountBudgetRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__updateAccountBudgetResponse(struct soap *soap, struct _ns1__updateAccountBudgetResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__updateAccountBudgetResponse))
		soap_serialize__ns1__updateAccountBudgetResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__updateAccountBudgetResponse(struct soap *soap, const char *tag, int id, struct _ns1__updateAccountBudgetResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__updateAccountBudgetResponse);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__updateAccountBudgetResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__updateAccountBudgetResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__updateAccountBudgetResponse(struct soap *soap, const char *tag, struct _ns1__updateAccountBudgetResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__updateAccountBudgetResponse **)soap_malloc(soap, sizeof(struct _ns1__updateAccountBudgetResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__updateAccountBudgetResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__updateAccountBudgetResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__updateAccountBudgetResponse, sizeof(struct _ns1__updateAccountBudgetResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__updateAccountBudgetResponse(struct soap *soap, struct _ns1__updateAccountBudgetResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__updateAccountBudgetResponse);
	if (soap_out_PointerTo_ns1__updateAccountBudgetResponse(soap, tag?tag:"ns1:updateAccountBudgetResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__updateAccountBudgetResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__updateAccountBudgetResponse(struct soap *soap, struct _ns1__updateAccountBudgetResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__updateAccountBudgetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__updateAccountBudgetRequest(struct soap *soap, struct _ns1__updateAccountBudgetRequest *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__updateAccountBudgetRequest))
		soap_serialize__ns1__updateAccountBudgetRequest(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__updateAccountBudgetRequest(struct soap *soap, const char *tag, int id, struct _ns1__updateAccountBudgetRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__updateAccountBudgetRequest);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__updateAccountBudgetRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__updateAccountBudgetRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__updateAccountBudgetRequest(struct soap *soap, const char *tag, struct _ns1__updateAccountBudgetRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__updateAccountBudgetRequest **)soap_malloc(soap, sizeof(struct _ns1__updateAccountBudgetRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__updateAccountBudgetRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__updateAccountBudgetRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__updateAccountBudgetRequest, sizeof(struct _ns1__updateAccountBudgetRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__updateAccountBudgetRequest(struct soap *soap, struct _ns1__updateAccountBudgetRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__updateAccountBudgetRequest);
	if (soap_out_PointerTo_ns1__updateAccountBudgetRequest(soap, tag?tag:"ns1:updateAccountBudgetRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__updateAccountBudgetRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__updateAccountBudgetRequest(struct soap *soap, struct _ns1__updateAccountBudgetRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__updateAccountBudgetRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__gettopNKeywordsDataResponse(struct soap *soap, struct _ns1__gettopNKeywordsDataResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__gettopNKeywordsDataResponse))
		soap_serialize__ns1__gettopNKeywordsDataResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__gettopNKeywordsDataResponse(struct soap *soap, const char *tag, int id, struct _ns1__gettopNKeywordsDataResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__gettopNKeywordsDataResponse);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__gettopNKeywordsDataResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__gettopNKeywordsDataResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__gettopNKeywordsDataResponse(struct soap *soap, const char *tag, struct _ns1__gettopNKeywordsDataResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__gettopNKeywordsDataResponse **)soap_malloc(soap, sizeof(struct _ns1__gettopNKeywordsDataResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__gettopNKeywordsDataResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__gettopNKeywordsDataResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__gettopNKeywordsDataResponse, sizeof(struct _ns1__gettopNKeywordsDataResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__gettopNKeywordsDataResponse(struct soap *soap, struct _ns1__gettopNKeywordsDataResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__gettopNKeywordsDataResponse);
	if (soap_out_PointerTo_ns1__gettopNKeywordsDataResponse(soap, tag?tag:"ns1:gettopNKeywordsDataResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__gettopNKeywordsDataResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__gettopNKeywordsDataResponse(struct soap *soap, struct _ns1__gettopNKeywordsDataResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__gettopNKeywordsDataResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__gettopNKeywordsDataRequest(struct soap *soap, struct _ns1__gettopNKeywordsDataRequest *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__gettopNKeywordsDataRequest))
		soap_serialize__ns1__gettopNKeywordsDataRequest(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__gettopNKeywordsDataRequest(struct soap *soap, const char *tag, int id, struct _ns1__gettopNKeywordsDataRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__gettopNKeywordsDataRequest);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__gettopNKeywordsDataRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__gettopNKeywordsDataRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__gettopNKeywordsDataRequest(struct soap *soap, const char *tag, struct _ns1__gettopNKeywordsDataRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__gettopNKeywordsDataRequest **)soap_malloc(soap, sizeof(struct _ns1__gettopNKeywordsDataRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__gettopNKeywordsDataRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__gettopNKeywordsDataRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__gettopNKeywordsDataRequest, sizeof(struct _ns1__gettopNKeywordsDataRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__gettopNKeywordsDataRequest(struct soap *soap, struct _ns1__gettopNKeywordsDataRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__gettopNKeywordsDataRequest);
	if (soap_out_PointerTo_ns1__gettopNKeywordsDataRequest(soap, tag?tag:"ns1:gettopNKeywordsDataRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__gettopNKeywordsDataRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__gettopNKeywordsDataRequest(struct soap *soap, struct _ns1__gettopNKeywordsDataRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__gettopNKeywordsDataRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getAllChangedObjectsPathResponse(struct soap *soap, struct _ns1__getAllChangedObjectsPathResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getAllChangedObjectsPathResponse))
		soap_serialize__ns1__getAllChangedObjectsPathResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getAllChangedObjectsPathResponse(struct soap *soap, const char *tag, int id, struct _ns1__getAllChangedObjectsPathResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getAllChangedObjectsPathResponse);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__getAllChangedObjectsPathResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__getAllChangedObjectsPathResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__getAllChangedObjectsPathResponse(struct soap *soap, const char *tag, struct _ns1__getAllChangedObjectsPathResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__getAllChangedObjectsPathResponse **)soap_malloc(soap, sizeof(struct _ns1__getAllChangedObjectsPathResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__getAllChangedObjectsPathResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__getAllChangedObjectsPathResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getAllChangedObjectsPathResponse, sizeof(struct _ns1__getAllChangedObjectsPathResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getAllChangedObjectsPathResponse(struct soap *soap, struct _ns1__getAllChangedObjectsPathResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getAllChangedObjectsPathResponse);
	if (soap_out_PointerTo_ns1__getAllChangedObjectsPathResponse(soap, tag?tag:"ns1:getAllChangedObjectsPathResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getAllChangedObjectsPathResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__getAllChangedObjectsPathResponse(struct soap *soap, struct _ns1__getAllChangedObjectsPathResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getAllChangedObjectsPathResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getAllChangedObjectsPathRequest(struct soap *soap, struct _ns1__getAllChangedObjectsPathRequest *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getAllChangedObjectsPathRequest))
		soap_serialize__ns1__getAllChangedObjectsPathRequest(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getAllChangedObjectsPathRequest(struct soap *soap, const char *tag, int id, struct _ns1__getAllChangedObjectsPathRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getAllChangedObjectsPathRequest);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__getAllChangedObjectsPathRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__getAllChangedObjectsPathRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__getAllChangedObjectsPathRequest(struct soap *soap, const char *tag, struct _ns1__getAllChangedObjectsPathRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__getAllChangedObjectsPathRequest **)soap_malloc(soap, sizeof(struct _ns1__getAllChangedObjectsPathRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__getAllChangedObjectsPathRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__getAllChangedObjectsPathRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getAllChangedObjectsPathRequest, sizeof(struct _ns1__getAllChangedObjectsPathRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getAllChangedObjectsPathRequest(struct soap *soap, struct _ns1__getAllChangedObjectsPathRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getAllChangedObjectsPathRequest);
	if (soap_out_PointerTo_ns1__getAllChangedObjectsPathRequest(soap, tag?tag:"ns1:getAllChangedObjectsPathRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getAllChangedObjectsPathRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__getAllChangedObjectsPathRequest(struct soap *soap, struct _ns1__getAllChangedObjectsPathRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getAllChangedObjectsPathRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getAllChangedObjectsResponse(struct soap *soap, struct _ns1__getAllChangedObjectsResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getAllChangedObjectsResponse))
		soap_serialize__ns1__getAllChangedObjectsResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getAllChangedObjectsResponse(struct soap *soap, const char *tag, int id, struct _ns1__getAllChangedObjectsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getAllChangedObjectsResponse);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__getAllChangedObjectsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__getAllChangedObjectsResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__getAllChangedObjectsResponse(struct soap *soap, const char *tag, struct _ns1__getAllChangedObjectsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__getAllChangedObjectsResponse **)soap_malloc(soap, sizeof(struct _ns1__getAllChangedObjectsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__getAllChangedObjectsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__getAllChangedObjectsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getAllChangedObjectsResponse, sizeof(struct _ns1__getAllChangedObjectsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getAllChangedObjectsResponse(struct soap *soap, struct _ns1__getAllChangedObjectsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getAllChangedObjectsResponse);
	if (soap_out_PointerTo_ns1__getAllChangedObjectsResponse(soap, tag?tag:"ns1:getAllChangedObjectsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getAllChangedObjectsResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__getAllChangedObjectsResponse(struct soap *soap, struct _ns1__getAllChangedObjectsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getAllChangedObjectsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getAllChangedObjectsRequest(struct soap *soap, struct _ns1__getAllChangedObjectsRequest *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getAllChangedObjectsRequest))
		soap_serialize__ns1__getAllChangedObjectsRequest(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getAllChangedObjectsRequest(struct soap *soap, const char *tag, int id, struct _ns1__getAllChangedObjectsRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getAllChangedObjectsRequest);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__getAllChangedObjectsRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__getAllChangedObjectsRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__getAllChangedObjectsRequest(struct soap *soap, const char *tag, struct _ns1__getAllChangedObjectsRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__getAllChangedObjectsRequest **)soap_malloc(soap, sizeof(struct _ns1__getAllChangedObjectsRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__getAllChangedObjectsRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__getAllChangedObjectsRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getAllChangedObjectsRequest, sizeof(struct _ns1__getAllChangedObjectsRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getAllChangedObjectsRequest(struct soap *soap, struct _ns1__getAllChangedObjectsRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getAllChangedObjectsRequest);
	if (soap_out_PointerTo_ns1__getAllChangedObjectsRequest(soap, tag?tag:"ns1:getAllChangedObjectsRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getAllChangedObjectsRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__getAllChangedObjectsRequest(struct soap *soap, struct _ns1__getAllChangedObjectsRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getAllChangedObjectsRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getSelectedObjectsPathResponse(struct soap *soap, struct _ns1__getSelectedObjectsPathResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getSelectedObjectsPathResponse))
		soap_serialize__ns1__getSelectedObjectsPathResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getSelectedObjectsPathResponse(struct soap *soap, const char *tag, int id, struct _ns1__getSelectedObjectsPathResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getSelectedObjectsPathResponse);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__getSelectedObjectsPathResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__getSelectedObjectsPathResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__getSelectedObjectsPathResponse(struct soap *soap, const char *tag, struct _ns1__getSelectedObjectsPathResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__getSelectedObjectsPathResponse **)soap_malloc(soap, sizeof(struct _ns1__getSelectedObjectsPathResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__getSelectedObjectsPathResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__getSelectedObjectsPathResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getSelectedObjectsPathResponse, sizeof(struct _ns1__getSelectedObjectsPathResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getSelectedObjectsPathResponse(struct soap *soap, struct _ns1__getSelectedObjectsPathResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getSelectedObjectsPathResponse);
	if (soap_out_PointerTo_ns1__getSelectedObjectsPathResponse(soap, tag?tag:"ns1:getSelectedObjectsPathResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getSelectedObjectsPathResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__getSelectedObjectsPathResponse(struct soap *soap, struct _ns1__getSelectedObjectsPathResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getSelectedObjectsPathResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getSelectedObjectsPathRequest(struct soap *soap, struct _ns1__getSelectedObjectsPathRequest *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getSelectedObjectsPathRequest))
		soap_serialize__ns1__getSelectedObjectsPathRequest(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getSelectedObjectsPathRequest(struct soap *soap, const char *tag, int id, struct _ns1__getSelectedObjectsPathRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getSelectedObjectsPathRequest);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__getSelectedObjectsPathRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__getSelectedObjectsPathRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__getSelectedObjectsPathRequest(struct soap *soap, const char *tag, struct _ns1__getSelectedObjectsPathRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__getSelectedObjectsPathRequest **)soap_malloc(soap, sizeof(struct _ns1__getSelectedObjectsPathRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__getSelectedObjectsPathRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__getSelectedObjectsPathRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getSelectedObjectsPathRequest, sizeof(struct _ns1__getSelectedObjectsPathRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getSelectedObjectsPathRequest(struct soap *soap, struct _ns1__getSelectedObjectsPathRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getSelectedObjectsPathRequest);
	if (soap_out_PointerTo_ns1__getSelectedObjectsPathRequest(soap, tag?tag:"ns1:getSelectedObjectsPathRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getSelectedObjectsPathRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__getSelectedObjectsPathRequest(struct soap *soap, struct _ns1__getSelectedObjectsPathRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getSelectedObjectsPathRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getAllObjectsPathResponse(struct soap *soap, struct _ns1__getAllObjectsPathResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getAllObjectsPathResponse))
		soap_serialize__ns1__getAllObjectsPathResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getAllObjectsPathResponse(struct soap *soap, const char *tag, int id, struct _ns1__getAllObjectsPathResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getAllObjectsPathResponse);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__getAllObjectsPathResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__getAllObjectsPathResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__getAllObjectsPathResponse(struct soap *soap, const char *tag, struct _ns1__getAllObjectsPathResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__getAllObjectsPathResponse **)soap_malloc(soap, sizeof(struct _ns1__getAllObjectsPathResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__getAllObjectsPathResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__getAllObjectsPathResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getAllObjectsPathResponse, sizeof(struct _ns1__getAllObjectsPathResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getAllObjectsPathResponse(struct soap *soap, struct _ns1__getAllObjectsPathResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getAllObjectsPathResponse);
	if (soap_out_PointerTo_ns1__getAllObjectsPathResponse(soap, tag?tag:"ns1:getAllObjectsPathResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getAllObjectsPathResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__getAllObjectsPathResponse(struct soap *soap, struct _ns1__getAllObjectsPathResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getAllObjectsPathResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getAllObjectsPathRequest(struct soap *soap, struct _ns1__getAllObjectsPathRequest *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getAllObjectsPathRequest))
		soap_serialize__ns1__getAllObjectsPathRequest(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getAllObjectsPathRequest(struct soap *soap, const char *tag, int id, struct _ns1__getAllObjectsPathRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getAllObjectsPathRequest);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__getAllObjectsPathRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__getAllObjectsPathRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__getAllObjectsPathRequest(struct soap *soap, const char *tag, struct _ns1__getAllObjectsPathRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__getAllObjectsPathRequest **)soap_malloc(soap, sizeof(struct _ns1__getAllObjectsPathRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__getAllObjectsPathRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__getAllObjectsPathRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getAllObjectsPathRequest, sizeof(struct _ns1__getAllObjectsPathRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getAllObjectsPathRequest(struct soap *soap, struct _ns1__getAllObjectsPathRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getAllObjectsPathRequest);
	if (soap_out_PointerTo_ns1__getAllObjectsPathRequest(soap, tag?tag:"ns1:getAllObjectsPathRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getAllObjectsPathRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__getAllObjectsPathRequest(struct soap *soap, struct _ns1__getAllObjectsPathRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getAllObjectsPathRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getFileStateResponse(struct soap *soap, struct _ns1__getFileStateResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getFileStateResponse))
		soap_serialize__ns1__getFileStateResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getFileStateResponse(struct soap *soap, const char *tag, int id, struct _ns1__getFileStateResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getFileStateResponse);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__getFileStateResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__getFileStateResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__getFileStateResponse(struct soap *soap, const char *tag, struct _ns1__getFileStateResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__getFileStateResponse **)soap_malloc(soap, sizeof(struct _ns1__getFileStateResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__getFileStateResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__getFileStateResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getFileStateResponse, sizeof(struct _ns1__getFileStateResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getFileStateResponse(struct soap *soap, struct _ns1__getFileStateResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getFileStateResponse);
	if (soap_out_PointerTo_ns1__getFileStateResponse(soap, tag?tag:"ns1:getFileStateResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getFileStateResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__getFileStateResponse(struct soap *soap, struct _ns1__getFileStateResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getFileStateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getFileStateRequest(struct soap *soap, struct _ns1__getFileStateRequest *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getFileStateRequest))
		soap_serialize__ns1__getFileStateRequest(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getFileStateRequest(struct soap *soap, const char *tag, int id, struct _ns1__getFileStateRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getFileStateRequest);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__getFileStateRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__getFileStateRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__getFileStateRequest(struct soap *soap, const char *tag, struct _ns1__getFileStateRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__getFileStateRequest **)soap_malloc(soap, sizeof(struct _ns1__getFileStateRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__getFileStateRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__getFileStateRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getFileStateRequest, sizeof(struct _ns1__getFileStateRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getFileStateRequest(struct soap *soap, struct _ns1__getFileStateRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getFileStateRequest);
	if (soap_out_PointerTo_ns1__getFileStateRequest(soap, tag?tag:"ns1:getFileStateRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getFileStateRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__getFileStateRequest(struct soap *soap, struct _ns1__getFileStateRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getFileStateRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getSelectedObjectsResponse(struct soap *soap, struct _ns1__getSelectedObjectsResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getSelectedObjectsResponse))
		soap_serialize__ns1__getSelectedObjectsResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getSelectedObjectsResponse(struct soap *soap, const char *tag, int id, struct _ns1__getSelectedObjectsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getSelectedObjectsResponse);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__getSelectedObjectsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__getSelectedObjectsResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__getSelectedObjectsResponse(struct soap *soap, const char *tag, struct _ns1__getSelectedObjectsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__getSelectedObjectsResponse **)soap_malloc(soap, sizeof(struct _ns1__getSelectedObjectsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__getSelectedObjectsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__getSelectedObjectsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getSelectedObjectsResponse, sizeof(struct _ns1__getSelectedObjectsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getSelectedObjectsResponse(struct soap *soap, struct _ns1__getSelectedObjectsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getSelectedObjectsResponse);
	if (soap_out_PointerTo_ns1__getSelectedObjectsResponse(soap, tag?tag:"ns1:getSelectedObjectsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getSelectedObjectsResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__getSelectedObjectsResponse(struct soap *soap, struct _ns1__getSelectedObjectsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getSelectedObjectsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getSelectedObjectsRequest(struct soap *soap, struct _ns1__getSelectedObjectsRequest *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getSelectedObjectsRequest))
		soap_serialize__ns1__getSelectedObjectsRequest(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getSelectedObjectsRequest(struct soap *soap, const char *tag, int id, struct _ns1__getSelectedObjectsRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getSelectedObjectsRequest);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__getSelectedObjectsRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__getSelectedObjectsRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__getSelectedObjectsRequest(struct soap *soap, const char *tag, struct _ns1__getSelectedObjectsRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__getSelectedObjectsRequest **)soap_malloc(soap, sizeof(struct _ns1__getSelectedObjectsRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__getSelectedObjectsRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__getSelectedObjectsRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getSelectedObjectsRequest, sizeof(struct _ns1__getSelectedObjectsRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getSelectedObjectsRequest(struct soap *soap, struct _ns1__getSelectedObjectsRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getSelectedObjectsRequest);
	if (soap_out_PointerTo_ns1__getSelectedObjectsRequest(soap, tag?tag:"ns1:getSelectedObjectsRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getSelectedObjectsRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__getSelectedObjectsRequest(struct soap *soap, struct _ns1__getSelectedObjectsRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getSelectedObjectsRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getChangedScaleResponse(struct soap *soap, struct _ns1__getChangedScaleResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getChangedScaleResponse))
		soap_serialize__ns1__getChangedScaleResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getChangedScaleResponse(struct soap *soap, const char *tag, int id, struct _ns1__getChangedScaleResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getChangedScaleResponse);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__getChangedScaleResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__getChangedScaleResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__getChangedScaleResponse(struct soap *soap, const char *tag, struct _ns1__getChangedScaleResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__getChangedScaleResponse **)soap_malloc(soap, sizeof(struct _ns1__getChangedScaleResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__getChangedScaleResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__getChangedScaleResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getChangedScaleResponse, sizeof(struct _ns1__getChangedScaleResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getChangedScaleResponse(struct soap *soap, struct _ns1__getChangedScaleResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getChangedScaleResponse);
	if (soap_out_PointerTo_ns1__getChangedScaleResponse(soap, tag?tag:"ns1:getChangedScaleResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getChangedScaleResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__getChangedScaleResponse(struct soap *soap, struct _ns1__getChangedScaleResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getChangedScaleResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getChangedScaleRequest(struct soap *soap, struct _ns1__getChangedScaleRequest *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getChangedScaleRequest))
		soap_serialize__ns1__getChangedScaleRequest(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getChangedScaleRequest(struct soap *soap, const char *tag, int id, struct _ns1__getChangedScaleRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getChangedScaleRequest);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__getChangedScaleRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__getChangedScaleRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__getChangedScaleRequest(struct soap *soap, const char *tag, struct _ns1__getChangedScaleRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__getChangedScaleRequest **)soap_malloc(soap, sizeof(struct _ns1__getChangedScaleRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__getChangedScaleRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__getChangedScaleRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getChangedScaleRequest, sizeof(struct _ns1__getChangedScaleRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getChangedScaleRequest(struct soap *soap, struct _ns1__getChangedScaleRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getChangedScaleRequest);
	if (soap_out_PointerTo_ns1__getChangedScaleRequest(soap, tag?tag:"ns1:getChangedScaleRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getChangedScaleRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__getChangedScaleRequest(struct soap *soap, struct _ns1__getChangedScaleRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getChangedScaleRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getAllObjectsResponse(struct soap *soap, struct _ns1__getAllObjectsResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getAllObjectsResponse))
		soap_serialize__ns1__getAllObjectsResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getAllObjectsResponse(struct soap *soap, const char *tag, int id, struct _ns1__getAllObjectsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getAllObjectsResponse);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__getAllObjectsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__getAllObjectsResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__getAllObjectsResponse(struct soap *soap, const char *tag, struct _ns1__getAllObjectsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__getAllObjectsResponse **)soap_malloc(soap, sizeof(struct _ns1__getAllObjectsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__getAllObjectsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__getAllObjectsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getAllObjectsResponse, sizeof(struct _ns1__getAllObjectsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getAllObjectsResponse(struct soap *soap, struct _ns1__getAllObjectsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getAllObjectsResponse);
	if (soap_out_PointerTo_ns1__getAllObjectsResponse(soap, tag?tag:"ns1:getAllObjectsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getAllObjectsResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__getAllObjectsResponse(struct soap *soap, struct _ns1__getAllObjectsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getAllObjectsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getAllObjectsRequest(struct soap *soap, struct _ns1__getAllObjectsRequest *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getAllObjectsRequest))
		soap_serialize__ns1__getAllObjectsRequest(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getAllObjectsRequest(struct soap *soap, const char *tag, int id, struct _ns1__getAllObjectsRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getAllObjectsRequest);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__getAllObjectsRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__getAllObjectsRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__getAllObjectsRequest(struct soap *soap, const char *tag, struct _ns1__getAllObjectsRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__getAllObjectsRequest **)soap_malloc(soap, sizeof(struct _ns1__getAllObjectsRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__getAllObjectsRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__getAllObjectsRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getAllObjectsRequest, sizeof(struct _ns1__getAllObjectsRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getAllObjectsRequest(struct soap *soap, struct _ns1__getAllObjectsRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getAllObjectsRequest);
	if (soap_out_PointerTo_ns1__getAllObjectsRequest(soap, tag?tag:"ns1:getAllObjectsRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getAllObjectsRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__getAllObjectsRequest(struct soap *soap, struct _ns1__getAllObjectsRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getAllObjectsRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getChangedIdResponse(struct soap *soap, struct _ns1__getChangedIdResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getChangedIdResponse))
		soap_serialize__ns1__getChangedIdResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getChangedIdResponse(struct soap *soap, const char *tag, int id, struct _ns1__getChangedIdResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getChangedIdResponse);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__getChangedIdResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__getChangedIdResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__getChangedIdResponse(struct soap *soap, const char *tag, struct _ns1__getChangedIdResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__getChangedIdResponse **)soap_malloc(soap, sizeof(struct _ns1__getChangedIdResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__getChangedIdResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__getChangedIdResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getChangedIdResponse, sizeof(struct _ns1__getChangedIdResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getChangedIdResponse(struct soap *soap, struct _ns1__getChangedIdResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getChangedIdResponse);
	if (soap_out_PointerTo_ns1__getChangedIdResponse(soap, tag?tag:"ns1:getChangedIdResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getChangedIdResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__getChangedIdResponse(struct soap *soap, struct _ns1__getChangedIdResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getChangedIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getChangedIdRequest(struct soap *soap, struct _ns1__getChangedIdRequest *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getChangedIdRequest))
		soap_serialize__ns1__getChangedIdRequest(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getChangedIdRequest(struct soap *soap, const char *tag, int id, struct _ns1__getChangedIdRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getChangedIdRequest);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__getChangedIdRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__getChangedIdRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__getChangedIdRequest(struct soap *soap, const char *tag, struct _ns1__getChangedIdRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__getChangedIdRequest **)soap_malloc(soap, sizeof(struct _ns1__getChangedIdRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__getChangedIdRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__getChangedIdRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getChangedIdRequest, sizeof(struct _ns1__getChangedIdRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getChangedIdRequest(struct soap *soap, struct _ns1__getChangedIdRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getChangedIdRequest);
	if (soap_out_PointerTo_ns1__getChangedIdRequest(soap, tag?tag:"ns1:getChangedIdRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getChangedIdRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__getChangedIdRequest(struct soap *soap, struct _ns1__getChangedIdRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getChangedIdRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getChangedItemIdResponse(struct soap *soap, struct _ns1__getChangedItemIdResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getChangedItemIdResponse))
		soap_serialize__ns1__getChangedItemIdResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getChangedItemIdResponse(struct soap *soap, const char *tag, int id, struct _ns1__getChangedItemIdResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getChangedItemIdResponse);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__getChangedItemIdResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__getChangedItemIdResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__getChangedItemIdResponse(struct soap *soap, const char *tag, struct _ns1__getChangedItemIdResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__getChangedItemIdResponse **)soap_malloc(soap, sizeof(struct _ns1__getChangedItemIdResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__getChangedItemIdResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__getChangedItemIdResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getChangedItemIdResponse, sizeof(struct _ns1__getChangedItemIdResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getChangedItemIdResponse(struct soap *soap, struct _ns1__getChangedItemIdResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getChangedItemIdResponse);
	if (soap_out_PointerTo_ns1__getChangedItemIdResponse(soap, tag?tag:"ns1:getChangedItemIdResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getChangedItemIdResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__getChangedItemIdResponse(struct soap *soap, struct _ns1__getChangedItemIdResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getChangedItemIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getChangedItemIdRequest(struct soap *soap, struct _ns1__getChangedItemIdRequest *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getChangedItemIdRequest))
		soap_serialize__ns1__getChangedItemIdRequest(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getChangedItemIdRequest(struct soap *soap, const char *tag, int id, struct _ns1__getChangedItemIdRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getChangedItemIdRequest);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__getChangedItemIdRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__getChangedItemIdRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__getChangedItemIdRequest(struct soap *soap, const char *tag, struct _ns1__getChangedItemIdRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__getChangedItemIdRequest **)soap_malloc(soap, sizeof(struct _ns1__getChangedItemIdRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__getChangedItemIdRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__getChangedItemIdRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getChangedItemIdRequest, sizeof(struct _ns1__getChangedItemIdRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getChangedItemIdRequest(struct soap *soap, struct _ns1__getChangedItemIdRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getChangedItemIdRequest);
	if (soap_out_PointerTo_ns1__getChangedItemIdRequest(soap, tag?tag:"ns1:getChangedItemIdRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getChangedItemIdRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__getChangedItemIdRequest(struct soap *soap, struct _ns1__getChangedItemIdRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getChangedItemIdRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getChangedAdgroupIdResponse(struct soap *soap, struct _ns1__getChangedAdgroupIdResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getChangedAdgroupIdResponse))
		soap_serialize__ns1__getChangedAdgroupIdResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getChangedAdgroupIdResponse(struct soap *soap, const char *tag, int id, struct _ns1__getChangedAdgroupIdResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getChangedAdgroupIdResponse);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__getChangedAdgroupIdResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__getChangedAdgroupIdResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__getChangedAdgroupIdResponse(struct soap *soap, const char *tag, struct _ns1__getChangedAdgroupIdResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__getChangedAdgroupIdResponse **)soap_malloc(soap, sizeof(struct _ns1__getChangedAdgroupIdResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__getChangedAdgroupIdResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__getChangedAdgroupIdResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getChangedAdgroupIdResponse, sizeof(struct _ns1__getChangedAdgroupIdResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getChangedAdgroupIdResponse(struct soap *soap, struct _ns1__getChangedAdgroupIdResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getChangedAdgroupIdResponse);
	if (soap_out_PointerTo_ns1__getChangedAdgroupIdResponse(soap, tag?tag:"ns1:getChangedAdgroupIdResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getChangedAdgroupIdResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__getChangedAdgroupIdResponse(struct soap *soap, struct _ns1__getChangedAdgroupIdResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getChangedAdgroupIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getChangedAdgroupIdRequest(struct soap *soap, struct _ns1__getChangedAdgroupIdRequest *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getChangedAdgroupIdRequest))
		soap_serialize__ns1__getChangedAdgroupIdRequest(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getChangedAdgroupIdRequest(struct soap *soap, const char *tag, int id, struct _ns1__getChangedAdgroupIdRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getChangedAdgroupIdRequest);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__getChangedAdgroupIdRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__getChangedAdgroupIdRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__getChangedAdgroupIdRequest(struct soap *soap, const char *tag, struct _ns1__getChangedAdgroupIdRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__getChangedAdgroupIdRequest **)soap_malloc(soap, sizeof(struct _ns1__getChangedAdgroupIdRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__getChangedAdgroupIdRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__getChangedAdgroupIdRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getChangedAdgroupIdRequest, sizeof(struct _ns1__getChangedAdgroupIdRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getChangedAdgroupIdRequest(struct soap *soap, struct _ns1__getChangedAdgroupIdRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getChangedAdgroupIdRequest);
	if (soap_out_PointerTo_ns1__getChangedAdgroupIdRequest(soap, tag?tag:"ns1:getChangedAdgroupIdRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getChangedAdgroupIdRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__getChangedAdgroupIdRequest(struct soap *soap, struct _ns1__getChangedAdgroupIdRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getChangedAdgroupIdRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getChangedCampaignIdResponse(struct soap *soap, struct _ns1__getChangedCampaignIdResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getChangedCampaignIdResponse))
		soap_serialize__ns1__getChangedCampaignIdResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getChangedCampaignIdResponse(struct soap *soap, const char *tag, int id, struct _ns1__getChangedCampaignIdResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getChangedCampaignIdResponse);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__getChangedCampaignIdResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__getChangedCampaignIdResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__getChangedCampaignIdResponse(struct soap *soap, const char *tag, struct _ns1__getChangedCampaignIdResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__getChangedCampaignIdResponse **)soap_malloc(soap, sizeof(struct _ns1__getChangedCampaignIdResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__getChangedCampaignIdResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__getChangedCampaignIdResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getChangedCampaignIdResponse, sizeof(struct _ns1__getChangedCampaignIdResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getChangedCampaignIdResponse(struct soap *soap, struct _ns1__getChangedCampaignIdResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getChangedCampaignIdResponse);
	if (soap_out_PointerTo_ns1__getChangedCampaignIdResponse(soap, tag?tag:"ns1:getChangedCampaignIdResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getChangedCampaignIdResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__getChangedCampaignIdResponse(struct soap *soap, struct _ns1__getChangedCampaignIdResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getChangedCampaignIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getChangedCampaignIdRequest(struct soap *soap, struct _ns1__getChangedCampaignIdRequest *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getChangedCampaignIdRequest))
		soap_serialize__ns1__getChangedCampaignIdRequest(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getChangedCampaignIdRequest(struct soap *soap, const char *tag, int id, struct _ns1__getChangedCampaignIdRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getChangedCampaignIdRequest);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__getChangedCampaignIdRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__getChangedCampaignIdRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__getChangedCampaignIdRequest(struct soap *soap, const char *tag, struct _ns1__getChangedCampaignIdRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__getChangedCampaignIdRequest **)soap_malloc(soap, sizeof(struct _ns1__getChangedCampaignIdRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__getChangedCampaignIdRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__getChangedCampaignIdRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getChangedCampaignIdRequest, sizeof(struct _ns1__getChangedCampaignIdRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getChangedCampaignIdRequest(struct soap *soap, struct _ns1__getChangedCampaignIdRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getChangedCampaignIdRequest);
	if (soap_out_PointerTo_ns1__getChangedCampaignIdRequest(soap, tag?tag:"ns1:getChangedCampaignIdRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getChangedCampaignIdRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__getChangedCampaignIdRequest(struct soap *soap, struct _ns1__getChangedCampaignIdRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getChangedCampaignIdRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__updateAccountInfoResponse(struct soap *soap, struct _ns1__updateAccountInfoResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__updateAccountInfoResponse))
		soap_serialize__ns1__updateAccountInfoResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__updateAccountInfoResponse(struct soap *soap, const char *tag, int id, struct _ns1__updateAccountInfoResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__updateAccountInfoResponse);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__updateAccountInfoResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__updateAccountInfoResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__updateAccountInfoResponse(struct soap *soap, const char *tag, struct _ns1__updateAccountInfoResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__updateAccountInfoResponse **)soap_malloc(soap, sizeof(struct _ns1__updateAccountInfoResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__updateAccountInfoResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__updateAccountInfoResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__updateAccountInfoResponse, sizeof(struct _ns1__updateAccountInfoResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__updateAccountInfoResponse(struct soap *soap, struct _ns1__updateAccountInfoResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__updateAccountInfoResponse);
	if (soap_out_PointerTo_ns1__updateAccountInfoResponse(soap, tag?tag:"ns1:updateAccountInfoResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__updateAccountInfoResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__updateAccountInfoResponse(struct soap *soap, struct _ns1__updateAccountInfoResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__updateAccountInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__updateAccountInfoRequest(struct soap *soap, struct _ns1__updateAccountInfoRequest *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__updateAccountInfoRequest))
		soap_serialize__ns1__updateAccountInfoRequest(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__updateAccountInfoRequest(struct soap *soap, const char *tag, int id, struct _ns1__updateAccountInfoRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__updateAccountInfoRequest);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__updateAccountInfoRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__updateAccountInfoRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__updateAccountInfoRequest(struct soap *soap, const char *tag, struct _ns1__updateAccountInfoRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__updateAccountInfoRequest **)soap_malloc(soap, sizeof(struct _ns1__updateAccountInfoRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__updateAccountInfoRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__updateAccountInfoRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__updateAccountInfoRequest, sizeof(struct _ns1__updateAccountInfoRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__updateAccountInfoRequest(struct soap *soap, struct _ns1__updateAccountInfoRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__updateAccountInfoRequest);
	if (soap_out_PointerTo_ns1__updateAccountInfoRequest(soap, tag?tag:"ns1:updateAccountInfoRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__updateAccountInfoRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__updateAccountInfoRequest(struct soap *soap, struct _ns1__updateAccountInfoRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__updateAccountInfoRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getAccountInfoResponse(struct soap *soap, struct _ns1__getAccountInfoResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getAccountInfoResponse))
		soap_serialize__ns1__getAccountInfoResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getAccountInfoResponse(struct soap *soap, const char *tag, int id, struct _ns1__getAccountInfoResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getAccountInfoResponse);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__getAccountInfoResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__getAccountInfoResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__getAccountInfoResponse(struct soap *soap, const char *tag, struct _ns1__getAccountInfoResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__getAccountInfoResponse **)soap_malloc(soap, sizeof(struct _ns1__getAccountInfoResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__getAccountInfoResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__getAccountInfoResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getAccountInfoResponse, sizeof(struct _ns1__getAccountInfoResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getAccountInfoResponse(struct soap *soap, struct _ns1__getAccountInfoResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getAccountInfoResponse);
	if (soap_out_PointerTo_ns1__getAccountInfoResponse(soap, tag?tag:"ns1:getAccountInfoResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getAccountInfoResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__getAccountInfoResponse(struct soap *soap, struct _ns1__getAccountInfoResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getAccountInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getAccountInfoRequest(struct soap *soap, struct _ns1__getAccountInfoRequest *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getAccountInfoRequest))
		soap_serialize__ns1__getAccountInfoRequest(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getAccountInfoRequest(struct soap *soap, const char *tag, int id, struct _ns1__getAccountInfoRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getAccountInfoRequest);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__getAccountInfoRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__getAccountInfoRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__getAccountInfoRequest(struct soap *soap, const char *tag, struct _ns1__getAccountInfoRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__getAccountInfoRequest **)soap_malloc(soap, sizeof(struct _ns1__getAccountInfoRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__getAccountInfoRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__getAccountInfoRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getAccountInfoRequest, sizeof(struct _ns1__getAccountInfoRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getAccountInfoRequest(struct soap *soap, struct _ns1__getAccountInfoRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getAccountInfoRequest);
	if (soap_out_PointerTo_ns1__getAccountInfoRequest(soap, tag?tag:"ns1:getAccountInfoRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getAccountInfoRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__getAccountInfoRequest(struct soap *soap, struct _ns1__getAccountInfoRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getAccountInfoRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ResHeader(struct soap *soap, struct ns2__ResHeader *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ResHeader))
		soap_serialize_ns2__ResHeader(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ResHeader(struct soap *soap, const char *tag, int id, struct ns2__ResHeader *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ResHeader);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__ResHeader(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__ResHeader ** SOAP_FMAC4 soap_in_PointerTons2__ResHeader(struct soap *soap, const char *tag, struct ns2__ResHeader **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__ResHeader **)soap_malloc(soap, sizeof(struct ns2__ResHeader *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__ResHeader(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__ResHeader **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ResHeader, sizeof(struct ns2__ResHeader), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ResHeader(struct soap *soap, struct ns2__ResHeader *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__ResHeader);
	if (soap_out_PointerTons2__ResHeader(soap, tag?tag:"ns2:ResHeader", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__ResHeader ** SOAP_FMAC4 soap_get_PointerTons2__ResHeader(struct soap *soap, struct ns2__ResHeader **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ResHeader(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__AuthHeader(struct soap *soap, struct ns2__AuthHeader *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__AuthHeader))
		soap_serialize_ns2__AuthHeader(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__AuthHeader(struct soap *soap, const char *tag, int id, struct ns2__AuthHeader *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__AuthHeader);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__AuthHeader(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__AuthHeader ** SOAP_FMAC4 soap_in_PointerTons2__AuthHeader(struct soap *soap, const char *tag, struct ns2__AuthHeader **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__AuthHeader **)soap_malloc(soap, sizeof(struct ns2__AuthHeader *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__AuthHeader(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__AuthHeader **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__AuthHeader, sizeof(struct ns2__AuthHeader), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__AuthHeader(struct soap *soap, struct ns2__AuthHeader *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__AuthHeader);
	if (soap_out_PointerTons2__AuthHeader(soap, tag?tag:"ns2:AuthHeader", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__AuthHeader ** SOAP_FMAC4 soap_get_PointerTons2__AuthHeader(struct soap *soap, struct ns2__AuthHeader **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__AuthHeader(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__Failure(struct soap *soap, struct ns2__Failure *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__Failure))
		soap_serialize_ns2__Failure(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__Failure(struct soap *soap, const char *tag, int id, struct ns2__Failure *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__Failure);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__Failure(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__Failure ** SOAP_FMAC4 soap_in_PointerTons2__Failure(struct soap *soap, const char *tag, struct ns2__Failure **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__Failure **)soap_malloc(soap, sizeof(struct ns2__Failure *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__Failure(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__Failure **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__Failure, sizeof(struct ns2__Failure), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__Failure(struct soap *soap, struct ns2__Failure *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__Failure);
	if (soap_out_PointerTons2__Failure(soap, tag?tag:"ns2:Failure", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__Failure ** SOAP_FMAC4 soap_get_PointerTons2__Failure(struct soap *soap, struct ns2__Failure **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__Failure(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__DoubleMapItemType(struct soap *soap, struct ns2__DoubleMapItemType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__DoubleMapItemType))
		soap_serialize_ns2__DoubleMapItemType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__DoubleMapItemType(struct soap *soap, const char *tag, int id, struct ns2__DoubleMapItemType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__DoubleMapItemType);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__DoubleMapItemType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__DoubleMapItemType ** SOAP_FMAC4 soap_in_PointerTons2__DoubleMapItemType(struct soap *soap, const char *tag, struct ns2__DoubleMapItemType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__DoubleMapItemType **)soap_malloc(soap, sizeof(struct ns2__DoubleMapItemType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__DoubleMapItemType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__DoubleMapItemType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__DoubleMapItemType, sizeof(struct ns2__DoubleMapItemType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__DoubleMapItemType(struct soap *soap, struct ns2__DoubleMapItemType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__DoubleMapItemType);
	if (soap_out_PointerTons2__DoubleMapItemType(soap, tag?tag:"ns2:DoubleMapItemType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__DoubleMapItemType ** SOAP_FMAC4 soap_get_PointerTons2__DoubleMapItemType(struct soap *soap, struct ns2__DoubleMapItemType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__DoubleMapItemType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__FloatMapItemType(struct soap *soap, struct ns2__FloatMapItemType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__FloatMapItemType))
		soap_serialize_ns2__FloatMapItemType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__FloatMapItemType(struct soap *soap, const char *tag, int id, struct ns2__FloatMapItemType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__FloatMapItemType);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__FloatMapItemType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__FloatMapItemType ** SOAP_FMAC4 soap_in_PointerTons2__FloatMapItemType(struct soap *soap, const char *tag, struct ns2__FloatMapItemType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__FloatMapItemType **)soap_malloc(soap, sizeof(struct ns2__FloatMapItemType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__FloatMapItemType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__FloatMapItemType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__FloatMapItemType, sizeof(struct ns2__FloatMapItemType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__FloatMapItemType(struct soap *soap, struct ns2__FloatMapItemType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__FloatMapItemType);
	if (soap_out_PointerTons2__FloatMapItemType(soap, tag?tag:"ns2:FloatMapItemType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__FloatMapItemType ** SOAP_FMAC4 soap_get_PointerTons2__FloatMapItemType(struct soap *soap, struct ns2__FloatMapItemType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__FloatMapItemType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__LongMapItemType(struct soap *soap, struct ns2__LongMapItemType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__LongMapItemType))
		soap_serialize_ns2__LongMapItemType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__LongMapItemType(struct soap *soap, const char *tag, int id, struct ns2__LongMapItemType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__LongMapItemType);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__LongMapItemType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__LongMapItemType ** SOAP_FMAC4 soap_in_PointerTons2__LongMapItemType(struct soap *soap, const char *tag, struct ns2__LongMapItemType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__LongMapItemType **)soap_malloc(soap, sizeof(struct ns2__LongMapItemType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__LongMapItemType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__LongMapItemType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__LongMapItemType, sizeof(struct ns2__LongMapItemType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__LongMapItemType(struct soap *soap, struct ns2__LongMapItemType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__LongMapItemType);
	if (soap_out_PointerTons2__LongMapItemType(soap, tag?tag:"ns2:LongMapItemType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__LongMapItemType ** SOAP_FMAC4 soap_get_PointerTons2__LongMapItemType(struct soap *soap, struct ns2__LongMapItemType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__LongMapItemType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__IntMapItemType(struct soap *soap, struct ns2__IntMapItemType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__IntMapItemType))
		soap_serialize_ns2__IntMapItemType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__IntMapItemType(struct soap *soap, const char *tag, int id, struct ns2__IntMapItemType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__IntMapItemType);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__IntMapItemType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__IntMapItemType ** SOAP_FMAC4 soap_in_PointerTons2__IntMapItemType(struct soap *soap, const char *tag, struct ns2__IntMapItemType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__IntMapItemType **)soap_malloc(soap, sizeof(struct ns2__IntMapItemType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__IntMapItemType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__IntMapItemType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__IntMapItemType, sizeof(struct ns2__IntMapItemType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__IntMapItemType(struct soap *soap, struct ns2__IntMapItemType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__IntMapItemType);
	if (soap_out_PointerTons2__IntMapItemType(soap, tag?tag:"ns2:IntMapItemType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__IntMapItemType ** SOAP_FMAC4 soap_get_PointerTons2__IntMapItemType(struct soap *soap, struct ns2__IntMapItemType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__IntMapItemType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__StringMapItemType(struct soap *soap, struct ns2__StringMapItemType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__StringMapItemType))
		soap_serialize_ns2__StringMapItemType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__StringMapItemType(struct soap *soap, const char *tag, int id, struct ns2__StringMapItemType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__StringMapItemType);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__StringMapItemType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__StringMapItemType ** SOAP_FMAC4 soap_in_PointerTons2__StringMapItemType(struct soap *soap, const char *tag, struct ns2__StringMapItemType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__StringMapItemType **)soap_malloc(soap, sizeof(struct ns2__StringMapItemType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__StringMapItemType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__StringMapItemType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__StringMapItemType, sizeof(struct ns2__StringMapItemType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__StringMapItemType(struct soap *soap, struct ns2__StringMapItemType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__StringMapItemType);
	if (soap_out_PointerTons2__StringMapItemType(soap, tag?tag:"ns2:StringMapItemType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__StringMapItemType ** SOAP_FMAC4 soap_get_PointerTons2__StringMapItemType(struct soap *soap, struct ns2__StringMapItemType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__StringMapItemType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ChangedNewCreativeType(struct soap *soap, struct ns1__ChangedNewCreativeType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ChangedNewCreativeType))
		soap_serialize_ns1__ChangedNewCreativeType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ChangedNewCreativeType(struct soap *soap, const char *tag, int id, struct ns1__ChangedNewCreativeType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ChangedNewCreativeType);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__ChangedNewCreativeType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__ChangedNewCreativeType ** SOAP_FMAC4 soap_in_PointerTons1__ChangedNewCreativeType(struct soap *soap, const char *tag, struct ns1__ChangedNewCreativeType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__ChangedNewCreativeType **)soap_malloc(soap, sizeof(struct ns1__ChangedNewCreativeType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__ChangedNewCreativeType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__ChangedNewCreativeType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ChangedNewCreativeType, sizeof(struct ns1__ChangedNewCreativeType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ChangedNewCreativeType(struct soap *soap, struct ns1__ChangedNewCreativeType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ChangedNewCreativeType);
	if (soap_out_PointerTons1__ChangedNewCreativeType(soap, tag?tag:"ns1:ChangedNewCreativeType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__ChangedNewCreativeType ** SOAP_FMAC4 soap_get_PointerTons1__ChangedNewCreativeType(struct soap *soap, struct ns1__ChangedNewCreativeType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ChangedNewCreativeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__TopNkeywordsData(struct soap *soap, struct ns1__TopNkeywordsData *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__TopNkeywordsData))
		soap_serialize_ns1__TopNkeywordsData(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__TopNkeywordsData(struct soap *soap, const char *tag, int id, struct ns1__TopNkeywordsData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__TopNkeywordsData);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__TopNkeywordsData(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__TopNkeywordsData ** SOAP_FMAC4 soap_in_PointerTons1__TopNkeywordsData(struct soap *soap, const char *tag, struct ns1__TopNkeywordsData **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__TopNkeywordsData **)soap_malloc(soap, sizeof(struct ns1__TopNkeywordsData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__TopNkeywordsData(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__TopNkeywordsData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__TopNkeywordsData, sizeof(struct ns1__TopNkeywordsData), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__TopNkeywordsData(struct soap *soap, struct ns1__TopNkeywordsData *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__TopNkeywordsData);
	if (soap_out_PointerTons1__TopNkeywordsData(soap, tag?tag:"ns1:TopNkeywordsData", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__TopNkeywordsData ** SOAP_FMAC4 soap_get_PointerTons1__TopNkeywordsData(struct soap *soap, struct ns1__TopNkeywordsData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__TopNkeywordsData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ChangedNewCreativeScaleType(struct soap *soap, struct ns1__ChangedNewCreativeScaleType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ChangedNewCreativeScaleType))
		soap_serialize_ns1__ChangedNewCreativeScaleType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ChangedNewCreativeScaleType(struct soap *soap, const char *tag, int id, struct ns1__ChangedNewCreativeScaleType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ChangedNewCreativeScaleType);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__ChangedNewCreativeScaleType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__ChangedNewCreativeScaleType ** SOAP_FMAC4 soap_in_PointerTons1__ChangedNewCreativeScaleType(struct soap *soap, const char *tag, struct ns1__ChangedNewCreativeScaleType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__ChangedNewCreativeScaleType **)soap_malloc(soap, sizeof(struct ns1__ChangedNewCreativeScaleType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__ChangedNewCreativeScaleType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__ChangedNewCreativeScaleType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ChangedNewCreativeScaleType, sizeof(struct ns1__ChangedNewCreativeScaleType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ChangedNewCreativeScaleType(struct soap *soap, struct ns1__ChangedNewCreativeScaleType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ChangedNewCreativeScaleType);
	if (soap_out_PointerTons1__ChangedNewCreativeScaleType(soap, tag?tag:"ns1:ChangedNewCreativeScaleType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__ChangedNewCreativeScaleType ** SOAP_FMAC4 soap_get_PointerTons1__ChangedNewCreativeScaleType(struct soap *soap, struct ns1__ChangedNewCreativeScaleType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ChangedNewCreativeScaleType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__VariableColumn(struct soap *soap, struct ns1__VariableColumn *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__VariableColumn))
		soap_serialize_ns1__VariableColumn(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__VariableColumn(struct soap *soap, const char *tag, int id, struct ns1__VariableColumn *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__VariableColumn);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__VariableColumn(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__VariableColumn ** SOAP_FMAC4 soap_in_PointerTons1__VariableColumn(struct soap *soap, const char *tag, struct ns1__VariableColumn **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__VariableColumn **)soap_malloc(soap, sizeof(struct ns1__VariableColumn *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__VariableColumn(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__VariableColumn **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__VariableColumn, sizeof(struct ns1__VariableColumn), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__VariableColumn(struct soap *soap, struct ns1__VariableColumn *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__VariableColumn);
	if (soap_out_PointerTons1__VariableColumn(soap, tag?tag:"ns1:VariableColumn", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__VariableColumn ** SOAP_FMAC4 soap_get_PointerTons1__VariableColumn(struct soap *soap, struct ns1__VariableColumn **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__VariableColumn(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ChangedItemType(struct soap *soap, struct ns1__ChangedItemType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ChangedItemType))
		soap_serialize_ns1__ChangedItemType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ChangedItemType(struct soap *soap, const char *tag, int id, struct ns1__ChangedItemType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ChangedItemType);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__ChangedItemType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__ChangedItemType ** SOAP_FMAC4 soap_in_PointerTons1__ChangedItemType(struct soap *soap, const char *tag, struct ns1__ChangedItemType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__ChangedItemType **)soap_malloc(soap, sizeof(struct ns1__ChangedItemType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__ChangedItemType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__ChangedItemType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ChangedItemType, sizeof(struct ns1__ChangedItemType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ChangedItemType(struct soap *soap, struct ns1__ChangedItemType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ChangedItemType);
	if (soap_out_PointerTons1__ChangedItemType(soap, tag?tag:"ns1:ChangedItemType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__ChangedItemType ** SOAP_FMAC4 soap_get_PointerTons1__ChangedItemType(struct soap *soap, struct ns1__ChangedItemType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ChangedItemType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ChangedAdgroupIdType(struct soap *soap, struct ns1__ChangedAdgroupIdType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ChangedAdgroupIdType))
		soap_serialize_ns1__ChangedAdgroupIdType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ChangedAdgroupIdType(struct soap *soap, const char *tag, int id, struct ns1__ChangedAdgroupIdType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ChangedAdgroupIdType);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__ChangedAdgroupIdType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__ChangedAdgroupIdType ** SOAP_FMAC4 soap_in_PointerTons1__ChangedAdgroupIdType(struct soap *soap, const char *tag, struct ns1__ChangedAdgroupIdType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__ChangedAdgroupIdType **)soap_malloc(soap, sizeof(struct ns1__ChangedAdgroupIdType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__ChangedAdgroupIdType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__ChangedAdgroupIdType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ChangedAdgroupIdType, sizeof(struct ns1__ChangedAdgroupIdType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ChangedAdgroupIdType(struct soap *soap, struct ns1__ChangedAdgroupIdType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ChangedAdgroupIdType);
	if (soap_out_PointerTons1__ChangedAdgroupIdType(soap, tag?tag:"ns1:ChangedAdgroupIdType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__ChangedAdgroupIdType ** SOAP_FMAC4 soap_get_PointerTons1__ChangedAdgroupIdType(struct soap *soap, struct ns1__ChangedAdgroupIdType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ChangedAdgroupIdType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ChangedCampaignIdType(struct soap *soap, struct ns1__ChangedCampaignIdType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ChangedCampaignIdType))
		soap_serialize_ns1__ChangedCampaignIdType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ChangedCampaignIdType(struct soap *soap, const char *tag, int id, struct ns1__ChangedCampaignIdType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ChangedCampaignIdType);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__ChangedCampaignIdType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__ChangedCampaignIdType ** SOAP_FMAC4 soap_in_PointerTons1__ChangedCampaignIdType(struct soap *soap, const char *tag, struct ns1__ChangedCampaignIdType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__ChangedCampaignIdType **)soap_malloc(soap, sizeof(struct ns1__ChangedCampaignIdType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__ChangedCampaignIdType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__ChangedCampaignIdType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ChangedCampaignIdType, sizeof(struct ns1__ChangedCampaignIdType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ChangedCampaignIdType(struct soap *soap, struct ns1__ChangedCampaignIdType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ChangedCampaignIdType);
	if (soap_out_PointerTons1__ChangedCampaignIdType(soap, tag?tag:"ns1:ChangedCampaignIdType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__ChangedCampaignIdType ** SOAP_FMAC4 soap_get_PointerTons1__ChangedCampaignIdType(struct soap *soap, struct ns1__ChangedCampaignIdType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ChangedCampaignIdType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotime(struct soap *soap, time_t *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_time);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotime(struct soap *soap, const char *tag, int id, time_t *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_time);
	if (id < 0)
		return soap->error;
	return soap_out_time(soap, tag, id, *a, type);
}

SOAP_FMAC3 time_t ** SOAP_FMAC4 soap_in_PointerTotime(struct soap *soap, const char *tag, time_t **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (time_t **)soap_malloc(soap, sizeof(time_t *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_time(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (time_t **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_time, sizeof(time_t), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotime(struct soap *soap, time_t *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTotime);
	if (soap_out_PointerTotime(soap, tag?tag:"dateTime", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 time_t ** SOAP_FMAC4 soap_get_PointerTotime(struct soap *soap, time_t **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__boolean(struct soap *soap, enum xsd__boolean *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_xsd__boolean);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__boolean(struct soap *soap, const char *tag, int id, enum xsd__boolean *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__boolean);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__boolean(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum xsd__boolean ** SOAP_FMAC4 soap_in_PointerToxsd__boolean(struct soap *soap, const char *tag, enum xsd__boolean **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum xsd__boolean **)soap_malloc(soap, sizeof(enum xsd__boolean *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__boolean(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum xsd__boolean **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__boolean, sizeof(enum xsd__boolean), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__boolean(struct soap *soap, enum xsd__boolean *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__boolean);
	if (soap_out_PointerToxsd__boolean(soap, tag?tag:"xsd:boolean", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum xsd__boolean ** SOAP_FMAC4 soap_get_PointerToxsd__boolean(struct soap *soap, enum xsd__boolean **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__boolean(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__AccountInfoType(struct soap *soap, struct ns1__AccountInfoType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__AccountInfoType))
		soap_serialize_ns1__AccountInfoType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__AccountInfoType(struct soap *soap, const char *tag, int id, struct ns1__AccountInfoType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__AccountInfoType);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__AccountInfoType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__AccountInfoType ** SOAP_FMAC4 soap_in_PointerTons1__AccountInfoType(struct soap *soap, const char *tag, struct ns1__AccountInfoType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__AccountInfoType **)soap_malloc(soap, sizeof(struct ns1__AccountInfoType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__AccountInfoType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__AccountInfoType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__AccountInfoType, sizeof(struct ns1__AccountInfoType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__AccountInfoType(struct soap *soap, struct ns1__AccountInfoType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__AccountInfoType);
	if (soap_out_PointerTons1__AccountInfoType(soap, tag?tag:"ns1:AccountInfoType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__AccountInfoType ** SOAP_FMAC4 soap_get_PointerTons1__AccountInfoType(struct soap *soap, struct ns1__AccountInfoType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__AccountInfoType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__OptType(struct soap *soap, struct ns2__OptType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__OptType))
		soap_serialize_ns2__OptType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__OptType(struct soap *soap, const char *tag, int id, struct ns2__OptType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__OptType);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__OptType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns2__OptType ** SOAP_FMAC4 soap_in_PointerTons2__OptType(struct soap *soap, const char *tag, struct ns2__OptType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns2__OptType **)soap_malloc(soap, sizeof(struct ns2__OptType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__OptType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns2__OptType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__OptType, sizeof(struct ns2__OptType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__OptType(struct soap *soap, struct ns2__OptType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__OptType);
	if (soap_out_PointerTons2__OptType(soap, tag?tag:"ns2:OptType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__OptType ** SOAP_FMAC4 soap_get_PointerTons2__OptType(struct soap *soap, struct ns2__OptType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__OptType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostring(struct soap *soap, char **const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_string))
		soap_serialize_string(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostring(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_string);
	if (id < 0)
		return soap->error;
	return soap_out_string(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_in_PointerTostring(struct soap *soap, const char *tag, char ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (char ***)soap_malloc(soap, sizeof(char **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_string, sizeof(char *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostring(struct soap *soap, char **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTostring);
	if (soap_out_PointerTostring(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerTostring(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostring(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToint(struct soap *soap, int *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToint(struct soap *soap, const char *tag, int id, int *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_int);
	if (id < 0)
		return soap->error;
	return soap_out_int(soap, tag, id, *a, type);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_in_PointerToint(struct soap *soap, const char *tag, int **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (int **)soap_malloc(soap, sizeof(int *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_int(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (int **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_int, sizeof(int), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToint(struct soap *soap, int *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToint);
	if (soap_out_PointerToint(soap, tag?tag:"int", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_get_PointerToint(struct soap *soap, int **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTodouble(struct soap *soap, double *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_double);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTodouble(struct soap *soap, const char *tag, int id, double *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_double);
	if (id < 0)
		return soap->error;
	return soap_out_double(soap, tag, id, *a, type);
}

SOAP_FMAC3 double ** SOAP_FMAC4 soap_in_PointerTodouble(struct soap *soap, const char *tag, double **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (double **)soap_malloc(soap, sizeof(double *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_double(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (double **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_double, sizeof(double), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTodouble(struct soap *soap, double *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTodouble);
	if (soap_out_PointerTodouble(soap, tag?tag:"double", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 double ** SOAP_FMAC4 soap_get_PointerTodouble(struct soap *soap, double **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTodouble(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToLONG64(struct soap *soap, LONG64 *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_LONG64);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToLONG64(struct soap *soap, const char *tag, int id, LONG64 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_LONG64);
	if (id < 0)
		return soap->error;
	return soap_out_LONG64(soap, tag, id, *a, type);
}

SOAP_FMAC3 LONG64 ** SOAP_FMAC4 soap_in_PointerToLONG64(struct soap *soap, const char *tag, LONG64 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (LONG64 **)soap_malloc(soap, sizeof(LONG64 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_LONG64(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (LONG64 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_LONG64, sizeof(LONG64), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToLONG64(struct soap *soap, LONG64 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToLONG64);
	if (soap_out_PointerToLONG64(soap, tag?tag:"long", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 LONG64 ** SOAP_FMAC4 soap_get_PointerToLONG64(struct soap *soap, LONG64 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToLONG64(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE__QName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__QName);
	if (soap_out__QName(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_string);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_string);
	if (soap_out_string(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifdef __cplusplus
}
#endif

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC.c */
